<?xml version="1.0" encoding="UTF-8" ?><!-- Created from PDF via Acrobat SaveAsXML --><!-- Mapping Table version: 28-February-2003 --><TaggedPDF-doc><?xpacket begin='﻿' id='W5M0MpCehiHzreSzNTczkc9d'?><?xpacket begin="﻿" id="W5M0MpCehiHzreSzNTczkc9d"?>
<x:xmpmeta xmlns:x="adobe:ns:meta/" x:xmptk="Adobe XMP Core 5.2-c001 63.139439, 2010/09/27-13:37:26        ">
   <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
      <rdf:Description rdf:about=""
            xmlns:pdf="http://ns.adobe.com/pdf/1.3/">
         <pdf:Producer>Acrobat Distiller 7.0.5 (Windows)</pdf:Producer>
      </rdf:Description>
      <rdf:Description rdf:about=""
            xmlns:pdfx="http://ns.adobe.com/pdfx/1.3/">
         <pdfx:Company>Altium Limited</pdfx:Company>
         <pdfx:SourceModified>D:20080526082707</pdfx:SourceModified>
      </rdf:Description>
      <rdf:Description rdf:about=""
            xmlns:xmp="http://ns.adobe.com/xap/1.0/">
         <xmp:CreatorTool>Acrobat PDFMaker 7.0.7 for Word</xmp:CreatorTool>
         <xmp:ModifyDate>2008-05-26T18:27:55+10:00</xmp:ModifyDate>
         <xmp:CreateDate>2008-05-26T18:27:21+10:00</xmp:CreateDate>
         <xmp:MetadataDate>2008-05-26T18:27:55+10:00</xmp:MetadataDate>
      </rdf:Description>
      <rdf:Description rdf:about=""
            xmlns:xmpMM="http://ns.adobe.com/xap/1.0/mm/">
         <xmpMM:DocumentID>uuid:8a2a5d46-d073-4fe7-94ff-0510a44c2e55</xmpMM:DocumentID>
         <xmpMM:InstanceID>uuid:c5a56cfb-5bd8-e645-b2b4-71de82fe89dc</xmpMM:InstanceID>
         <xmpMM:VersionID>
            <rdf:Seq>
               <rdf:li>143</rdf:li>
            </rdf:Seq>
         </xmpMM:VersionID>
      </rdf:Description>
      <rdf:Description rdf:about=""
            xmlns:dc="http://purl.org/dc/elements/1.1/">
         <dc:format>xml</dc:format>
         <dc:title>
            <rdf:Alt>
               <rdf:li xml:lang="x-default"> </rdf:li>
            </rdf:Alt>
         </dc:title>
         <dc:creator>
            <rdf:Seq>
               <rdf:li>Jason Howie</rdf:li>
            </rdf:Seq>
         </dc:creator>
         <dc:subject>
            <rdf:Bag>
               <rdf:li/>
            </rdf:Bag>
         </dc:subject>
      </rdf:Description>
      <rdf:Description rdf:about=""
            xmlns:photoshop="http://ns.adobe.com/photoshop/1.0/">
         <photoshop:headline>
            <rdf:Seq>
               <rdf:li/>
            </rdf:Seq>
         </photoshop:headline>
      </rdf:Description>
   </rdf:RDF>
</x:xmpmeta>
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                           
<?xpacket end="w"?><?xpacket end='r'?><bookmark-tree><bookmark title="Features "><destination structID="LinkTarget_1961"/></bookmark><bookmark title="Available Devices "><destination structID="LinkTarget_1969"/></bookmark><bookmark title="IEEE 754 Standard "><destination structID="LinkTarget_1973"/><bookmark title="Single Precision Format "><destination structID="LinkTarget_1975"/><bookmark title="Sign"><destination structID="LinkTarget_1990"/></bookmark><bookmark title="Exponent"><destination structID="LinkTarget_1992"/></bookmark><bookmark title="Significand"><destination structID="LinkTarget_1788"/></bookmark><bookmark title="Floating-Point Encoding Example"><destination structID="LinkTarget_1799"/></bookmark></bookmark><bookmark title="Valid Range for Floating-Point Numbers "><destination structID="LinkTarget_1823"/></bookmark><bookmark title="Special Values "><destination structID="LinkTarget_1656"/><bookmark title="A Word about NaNs"><destination structID="LinkTarget_1686"/></bookmark></bookmark><bookmark title="Normalized Numbers "><destination structID="LinkTarget_1694"/><bookmark title="Denormalized Numbers"><destination structID="LinkTarget_1711"/></bookmark></bookmark><bookmark title="Floating-Point Algorithms "><destination structID="LinkTarget_1491"/><bookmark title="Conversions"><destination structID="LinkTarget_1493"/></bookmark><bookmark title="Calculations"><destination structID="LinkTarget_1495"/><bookmark title="Addition"><destination structID="LinkTarget_1497"/></bookmark><bookmark title="Subtraction"><destination structID="LinkTarget_1567"/></bookmark><bookmark title="Multiplication"><destination structID="LinkTarget_1248"/></bookmark><bookmark title="Division"><destination structID="LinkTarget_1316"/></bookmark></bookmark></bookmark><bookmark title="Rounding "><destination structID="LinkTarget_1063"/></bookmark></bookmark><bookmark title=" Functional Description "><destination structID="LinkTarget_881"/><bookmark title="Symbol "><destination structID="LinkTarget_882"/></bookmark><bookmark title="Pin Description "><destination structID="LinkTarget_886"/></bookmark></bookmark><bookmark title=" Hardware Description "><destination structID="LinkTarget_860"/><bookmark title="Block Diagram "><destination structID="LinkTarget_861"/></bookmark><bookmark title="Internal Units "><destination structID="LinkTarget_859"/><bookmark title="Denormalization Units"><destination structID="LinkTarget_859"/></bookmark><bookmark title="Conversion Units"><destination structID="LinkTarget_823"/></bookmark><bookmark title="Addition Unit"><destination structID="LinkTarget_827"/></bookmark><bookmark title="Subtraction Unit"><destination structID="LinkTarget_832"/></bookmark><bookmark title="Multiplication Unit"><destination structID="LinkTarget_839"/></bookmark><bookmark title="Division Unit"><destination structID="LinkTarget_842"/></bookmark><bookmark title="Normalization Units"><destination structID="LinkTarget_677"/><bookmark title="Effect of Special Bits"><destination structID="LinkTarget_679"/></bookmark><bookmark title="Exponent Underflow and Overflow Detection"><destination structID="LinkTarget_702"/></bookmark></bookmark></bookmark><bookmark title="Internal Registers "><destination structID="LinkTarget_706"/><bookmark title="Status Address (STATUS)"><destination structID="LinkTarget_708"/></bookmark><bookmark title="Operand A Address (OPA)"><destination structID="LinkTarget_611"/></bookmark><bookmark title="Operand B Address (OPB)"><destination structID="LinkTarget_620"/></bookmark><bookmark title="Addition Result Address (ADD)"><destination structID="LinkTarget_628"/></bookmark><bookmark title="Subtraction Result Address (SUB)"><destination structID="LinkTarget_521"/><bookmark title="Dual Operand Loading"><destination structID="LinkTarget_530"/></bookmark></bookmark><bookmark title="Multiplication Result Address (MUL)"><destination structID="LinkTarget_535"/></bookmark><bookmark title="Division Result Address (DIV)"><destination structID="LinkTarget_543"/></bookmark><bookmark title="Integer to Float Result Address (ITOF)"><destination structID="LinkTarget_551"/></bookmark><bookmark title="Float to Integer Result Address (FTOI)"><destination structID="LinkTarget_559"/></bookmark></bookmark></bookmark><bookmark title=" Interfacing to a 32-bit Processor "><destination structID="LinkTarget_501"/><bookmark title="Host to Controller Communications "><destination structID="LinkTarget_466"/><bookmark title="Writing to an Internal Register"><destination structID="LinkTarget_468"/></bookmark><bookmark title="Reading from an Internal Register"><destination structID="LinkTarget_475"/></bookmark></bookmark></bookmark><bookmark title=" Operational Overview "><destination structID="LinkTarget_425"/><bookmark title="Example Code "><destination structID="LinkTarget_427"/><bookmark title="Addition"><destination structID="LinkTarget_429"/></bookmark><bookmark title="Subtraction"><destination structID="LinkTarget_444"/></bookmark><bookmark title=" Multiplication"><destination structID="LinkTarget_380"/></bookmark><bookmark title="Division"><destination structID="LinkTarget_396"/></bookmark><bookmark title="Involution"><destination structID="LinkTarget_412"/></bookmark><bookmark title=" Integer to Float Conversion"><destination structID="LinkTarget_306"/></bookmark><bookmark title="Float to Integer Conversion"><destination structID="LinkTarget_320"/></bookmark></bookmark></bookmark><bookmark title="Revision History "><destination structID="LinkTarget_334"/></bookmark></bookmark-tree><Sect><Table><TBody><TR><TD><Body><InlineShape><ImageData src="images/fpu_ip_altium_2008_img_0.jpg"/></InlineShape> </Body></TD><TD><Title1>WB_FPU Floating-point Unit </Title1></TD></TR><TR><TD><Summary1>Summary  </Summary1></TD><TD><Summarytext>This document provides detailed reference information with respect to the WB_FPU peripheral device. </Summarytext></TD></TR><TR><TD><Summarytext2>Core Reference CR0171 (v2.0) March 11, 2008 </Summarytext2></TD><TD><Summary1/></TD></TR><TR><TD><cell> </cell></TD></TR></TBody></Table><Body> </Body><Body>Altium Designer's floating-point unit – WB_FPU – facilitates the conversion of 32-bit integer values into single precision floating-point numbers, and vice-versa. This hardware peripheral performs these conversions and additional, standard mathematical calculations, with greater speed when compared with previous, software-based floating-point support. </Body><Body>Incorporating the standard Wishbone interface, the WB_FPU can be used with any of the 32-bit processors available in Altium Designer. </Body><Normal id="LinkTarget_1961">Features </Normal><L><LI><LBody>• Converts 32-bit integer values to single precision floating-point numbers, in accordance with the IEEE-754 standard </LBody></LI><LI><LBody>• Converts single precision floating-point numbers to 32-bit integer values </LBody></LI><LI><LBody>• Perform addition of two single precision floating-point numbers </LBody></LI><LI><LBody>• Perform subtraction of two single precision floating-point numbers </LBody></LI><LI><LBody>• Perform multiplication of two single precision floating-point numbers </LBody></LI><LI><LBody>• Perform division of two single precision floating-point numbers </LBody></LI><LI><LBody>• Wishbone-compliant. </LBody></LI></L><Normal id="LinkTarget_1969">Available Devices </Normal><Body>The WB_FPU device can be found in the FPGA Peripherals integrated library (FPGA Peripherals.IntLib), located in the \Library\Fpga folder of the installation. </Body><Normal id="LinkTarget_1973">IEEE 754 Standard </Normal><Body>Before discussing the actual WB_FPU peripheral in detail – including its functional and hardware descriptions – it is worth spending some time to look at the standard to which the floating-point numbers adhere, the IEEE Standard for Binary Floating-point Arithmetic (IEEE 754). This standard not only specifies how floating-point numbers are to be represented, but also how arithmetic calculations on these numbers should be performed. </Body><Normal id="LinkTarget_1975">Single Precision Format </Normal><Body>The WB_FPU supports single precision (32-bit) binary floating-point numbers, formatted in accordance with the IEEE 754 Standard. Figure 1 shows the composition of a binary floating-point number under this standard. </Body><Table><TBody><TR><TD><Body>MSB </Body></TD><TD><Centered> </Centered></TD><TD><Centered> </Centered></TD><TD><Centered> </Centered></TD><TD><Centered> </Centered></TD><TD><RightJustified>LSB </RightJustified></TD></TR><TR><TD><Centered>31       </Centered></TD><TD><Centered>30                                        23 </Centered></TD><TD><Centered>22                                                                                                                          0 </Centered></TD></TR><TR><TD><Centered>Sign </Centered></TD><TD><Centered>Exponent </Centered></TD><TD><Centered>Significand </Centered></TD></TR></TBody></Table><Normal>Figure 1. IEEE 754 floating-point number format. </Normal><heading-3 id="LinkTarget_1990">Sign </heading-3><Body>The Sign consists of a single bit. If this bit is '1', then the number is negative. If this bit is '0', then the number is positive. </Body><heading-3 id="LinkTarget_1992">Exponent </heading-3><Body>The Exponent consists of 8 bits. The base system used is binary (base 2). This base is implicit and is therefore not stored as part of the 32-bit format. </Body><Body>To facilitate both positive and negative exponent values, a bias value is added to the actual exponent to arrive at the 8-bit value that gets stored. For IEEE 754 single precision floats, the bias value used is 127. </Body><heading-3 id="LinkTarget_1788">Significand </heading-3><Body>The significand represents the precision bits of the number. The WB_FPU supports normalized floating-point numbers (see Normalized numbers). Normalization leads to two important points: </Body><L><LI><LBody>• The radix point is always placed after the first non-zero digit (e.g. 1101 becomes 1.101 x 23<Superscript/>) </LBody></LI><LI><LBody>• The leading bit – to the left of the radix point – is required to be non-zero. As we are using the binary system, this bit can only be 1. As such, the leading bit is implicit and not stored as part of the significand. <indent>The significand therefore effectively has 24-bit resolution, but only 23 bits are used to represent the fractional part of the number only – the digits to the right of the radix point. If the fractional part of the number (written in binary notation) is less than 23 bits, the remaining right-hand bits are padded with zeroes. For example 1.101 x 23<Superscript/> would yield a significand of 10100000000000000000000. </indent></LBody></LI></L><heading-3 id="LinkTarget_1799">Floating-Point Encoding Example </heading-3><Body>Understanding more clearly how an integer is encoded into this floating-point format can be demonstrated using a simple example. Consider the integer value 276. We need to obtain the Sign, Exponent and Significand in order to fully represent this integer in binary floating-point format. </Body><L><LI><LBody>• This is a positive integer, so the sign bit of the binary floating-point representation will be 0. </LBody></LI><LI><LBody>• Convert the integer into binary notation – giving us 100010100. </LBody></LI><LI><LBody>• If we normalize this value, moving the radix point to the right of the leading 1, our binary value 100010100 becomes 1.00010100 x 28<Superscript/>. </LBody></LI><LI><LBody>• The actual exponent for this value is 8. The exponent that gets stored is 8 + 127 (the bias value). Thus, 135 will be stored as the 8-bit exponent value 10000111. </LBody></LI><LI><LBody>• The entry for the significand is the fractional part of the number (highlighted in gray), padded with zeroes to obtain the required 23 bits. In this example, the significand is 00010100000000000000000. </LBody></LI></L><Body>This is all the information we need to fully represent the integer in floating-point form: </Body><Table><TBody><TR><TD><Centered>276 </Centered></TD><TD><Centered>= </Centered></TD><TD><Body>0</Body></TD><TD><Body>10000111</Body></TD><TD><Body> 00010100000000000000000</Body></TD></TR></TBody></Table><Normal id="LinkTarget_1823">Valid Range for Floating-Point Numbers </Normal><Body>The valid range for normalized (non-zero) numbers in single precision floating-point format can be defined as: </Body><Graphic-Indent>2minexp ≤ FloatValue ≤ (2 – 21-precisionbits) x 2maxexp <Superscript/>...Positive values </Graphic-Indent><Graphic-Indent>-2minexp ≥ FloatValue ≥ -(2 – 21-precisionbits) x 2maxexp <Superscript/>...Negative values </Graphic-Indent><Body>where, </Body><Body>minexp is the minimum legal exponent value for normalized numbers being encoded. For single precision floating-point format this value is -126 which, when the bias value (127) is added, will give a biased exponent of 1 (00000001b). </Body><Body>maxexp is the maximum legal exponent value for normalized numbers being encoded. For single precision floating-point format this value is 127 which, when the bias value (127) is added, will give a biased exponent of 254 (11111110b). </Body><Body>precisionbits is the number of bits of significand precision for the floating-point format you are using. For single precision, this value is 24 – remembering that the MSB is always 1 and so is hidden (or implicit). </Body><Body>Feeding the above values back into the expressions gives the following ranges: </Body><Graphic-Indent>2-126 ≤ Value ≤ (2 – 2-23) x 2127 <Superscript/>...Positive values<SuperEntry/></Graphic-Indent><Graphic-Indent>-2-126 ≥ Value ≥ -(2 – 2-23) x 2127 <Superscript/>...Negative values </Graphic-Indent><Body>These ranges can be reduced to a single range governing all values, positive and negative: </Body><Graphic-Indent>+/-(2 – 2-23) x 2127<Superscript/></Graphic-Indent><Body>The value 0 (or more specifically +0 and -0) is treated as a special case and is discussed in the next section. </Body><Normal id="LinkTarget_1656">Special Values </Normal><Body>The IEEE 754 standard reserves effective exponent values of 0 and 255, which are used in conjunction with particular significand values to denote special binary floating-point values. Table 1 lists the special values supported by the WB_FPU. </Body><Normal>Table 1. Special values. </Normal><Table><TBody><TR><TD><BoldCentered>Sign </BoldCentered></TD><TD><BoldCentered>Exponent </BoldCentered></TD><TD><BoldCentered>Significand </BoldCentered></TD><TD><BoldCentered>Describes </BoldCentered></TD></TR><TR><TD><Centered>0 </Centered></TD><TD><Centered>00h </Centered></TD><TD><Centered>000000h </Centered></TD><TD><Body>Positive zero </Body></TD></TR><TR><TD><Centered>1 </Centered></TD><TD><Centered>00h </Centered></TD><TD><Centered>000000h </Centered></TD><TD><Body>Negative zero </Body></TD></TR><TR><TD><Centered>0 </Centered></TD><TD><Centered>FFh </Centered></TD><TD><Centered>000000h </Centered></TD><TD><Body>Positive infinity </Body></TD></TR><TR><TD><Centered>1 </Centered></TD><TD><Centered>FFh </Centered></TD><TD><Centered>000000h </Centered></TD><TD><Body>Negative infinity </Body></TD></TR><TR><TD><Centered>0 </Centered></TD><TD><Centered>FFh </Centered></TD><TD><Centered>&gt; 000000h </Centered></TD><TD><Body>NaN – Not a Number </Body></TD></TR></TBody></Table><Body>Note: -0 and +0 are distinct values, but are equal for comparison purposes. </Body><heading-3 id="LinkTarget_1686">A Word about NaNs </heading-3><Body>The value NaN (Not a Number) is used to represent a value that does not represent a real number. As illustrated in Table 1, NaNs are represented by a bit pattern with an exponent of all ones and a non-zero significand. The sign bit can be 0 or 1 – it has no bearing. </Body><Body>There are two categories of NaNs: </Body><L><LI><LBody>• QNaN (Quiet NaN) – arising when the result of an arithmetic operation is mathematically undefined. The MSB of the significand is '1' for this type of NaN. </LBody></LI><LI><LBody>• SNaN (Signaling NaN) – used to signal an exception when an invalid operation is performed. The MSB of the significand is '0' for this type of NaN. <indent>The difference between QNaN and SNaN is not implemented in the WB_FPU. </indent></LBody></LI></L><Normal id="LinkTarget_1694">Normalized Numbers </Normal><Body>The majority of numbers in the IEEE 754 floating-point format are normalized. Such a value has an assumed '1' for the hidden 24th bit of the significand, after which directly follows the radix point. A normalized floating-point value can be summarized using the following expression: </Body><Graphic-Indent>NormalizedFloatValue = s x 2e-b x 1.f </Graphic-Indent><Body>where, </Body><Body>s is defined by the sign bit and is +1 for sign=0 and -1 for sign=1. </Body><Body>e is the biased exponent </Body><Body>b is the bias value of 127. </Body><Body>f is the 23-bit 'fractional value' of the significand, to the right of the radix point. </Body><Body>The 24-bit significand (1.f ) of a normalized binary floating-point number will therefore always be in the range: </Body><Graphic-Indent>1 ≤ significand &lt; 2 </Graphic-Indent><heading-3 id="LinkTarget_1711">Denormalized Numbers </heading-3><Body>When a calculation involving two floating-point values results in an exponent that is too small to be properly represented – at values less than 1.f x 2-127 – an underflow event occurs. The IEEE 754 standard includes the provision for 'gradual underflow', through the use of denormalized (or subnormal) numbers. </Body><Body>A denormalized number has a biased exponent of zero. When a number becomes denormalized, the significand is shifted by one bit to the right, in order to include the hidden 24th bit. This bit is set to zero. To compensate, the un-biased exponent is incremented by 1. </Body><Body>A denormalized floating-point value can be summarized using the following expression: </Body><Graphic-Indent>DenormalizedFloatValue = s x 2-126 x 0.f </Graphic-Indent><Body>The actual term for the un-biased exponent is 2e-b+1<Superscript/>, but as the biased exponent (e) is 0 for denormalized numbers and the bias (b) is 127, this reduces to 2-126<Superscript/>. </Body><Shape><ImageData src="images/fpu_ip_altium_2008_img_1.jpg"/></Shape><Shape><ImageData src="images/fpu_ip_altium_2008_img_2.jpg"/></Shape><indent>Denormalized numbers are not implemented in the WB_FPU. Instead, numbers with an exponent overflow will be rounded to infinity and numbers with an exponent underflow will be rounded to zero. </indent><Normal id="LinkTarget_1491">Floating-Point Algorithms </Normal><Body>The following sections look at algorithms defined by the IEEE 754 standard for conversion and base arithmetic calculations, and which are implemented in the WB_FPU. </Body><heading-3 id="LinkTarget_1493">Conversions </heading-3><Body>The WB_FPU provides conversion from integer to the IEEE 754 single precision floating-point format and vice-versa. </Body><heading-3 id="LinkTarget_1495">Calculations </heading-3><Body>The WB_FPU supports the following calculations involving two floating-point values – Addition, Subtraction, Multiplication and Division. </Body><heading-4 id="LinkTarget_1497">Addition </heading-4><Body>Addition of two floating-point values requires that the exponents of both operands be first made equal. This involves shifting the significand of the operand with the smallest exponent, to the right, such that both exponents become equal. The significands are then added. </Body><Body>When adding significands, an overflow may occur. This overflow can be corrected by shifting the resulting significand one bit position to the right and adjusting the exponent accordingly. </Body><Body>The addition process takes a single clock cycle. </Body><Normal>Table 2 summarizes the possible resulting values based on additions involving the various combinations of floating-point operands, including the special values listed in Table 1 (refer back to the section <Link>Special values</Link>). </Normal><Normal>Table 2. Addition of operands. </Normal><Table><THead><TR><TD><RightJustified>OP1  </RightJustified><Body>OP2 </Body></TD><TD><BoldCentered>NaN </BoldCentered></TD><TD><BoldCentered>+Infinity </BoldCentered></TD><TD><BoldCentered>-Infinity </BoldCentered></TD><TD><BoldCentered>+0 </BoldCentered></TD><TD><BoldCentered>-0 </BoldCentered></TD><TD><BoldCentered>+Num </BoldCentered></TD><TD><BoldCentered>-Num </BoldCentered></TD></TR></THead><TBody><TR><TD><RightJustified>NaN</RightJustified></TD><TD><Centered>NaN </Centered></TD><TD><Centered>NaN </Centered></TD><TD><Centered>NaN </Centered></TD><TD><Centered>NaN </Centered></TD><TD><Centered>NaN </Centered></TD><TD><Centered>NaN </Centered></TD><TD><Centered>NaN </Centered></TD></TR><TR><TD><RightJustified>+Infinity</RightJustified></TD><TD><Centered>NaN </Centered></TD><TD><Centered>+Infinity </Centered></TD><TD><Centered>NaN </Centered></TD><TD><Centered>+Infinity </Centered></TD><TD><Centered>+Infinity </Centered></TD><TD><Centered>+Infinity </Centered></TD><TD><Centered>+Infinity </Centered></TD></TR><TR><TD><RightJustified>-Infinity</RightJustified></TD><TD><Centered>NaN </Centered></TD><TD><Centered>NaN </Centered></TD><TD><Centered>-Infinity </Centered></TD><TD><Centered>-Infinity </Centered></TD><TD><Centered>-Infinity </Centered></TD><TD><Centered>-Infinity </Centered></TD><TD><Centered>-Infinity </Centered></TD></TR><TR><TD><RightJustified>+0</RightJustified></TD><TD><Centered>NaN </Centered></TD><TD><Centered>+Infinity </Centered></TD><TD><Centered>-Infinity </Centered></TD><TD><Centered>+0 </Centered></TD><TD><Centered>+0 </Centered></TD><TD><Centered>+Num </Centered></TD><TD><Centered>-Num </Centered></TD></TR><TR><TD><RightJustified>-0</RightJustified></TD><TD><Centered>NaN </Centered></TD><TD><Centered>+Infinity </Centered></TD><TD><Centered>-Infinity </Centered></TD><TD><Centered>+0 </Centered></TD><TD><Centered>-0 </Centered></TD><TD><Centered>+Num </Centered></TD><TD><Centered>-Num </Centered></TD></TR><TR><TD><RightJustified>+Num</RightJustified></TD><TD><Centered>NaN </Centered></TD><TD><Centered>+Infinity </Centered></TD><TD><Centered>-Infinity </Centered></TD><TD><Centered>+Num </Centered></TD><TD><Centered>+Num </Centered></TD><TD><Centered>+Num +Infinity </Centered></TD><TD><Centered>±Num +0 </Centered></TD></TR><TR><TD><RightJustified>-Num</RightJustified></TD><TD><Centered>NaN </Centered></TD><TD><Centered>+Infinity </Centered></TD><TD><Centered>-Infinity </Centered></TD><TD><Centered>-Num </Centered></TD><TD><Centered>-Num </Centered></TD><TD><Centered>±Num +0 </Centered></TD><TD><Centered>-Num -Infinity </Centered></TD></TR></TBody></Table><heading-4 id="LinkTarget_1567">Subtraction </heading-4><Body>Subtraction is similar to addition. It involves making the exponents of both operands equal and then subtracting the resulting significands. In order to make things less complicated, care is taken to ensure that the smaller operand is always subtracted from the larger one. </Body><Body>In order to keep the WB_FPU synthesizable for reasonable clock frequencies (e.g. 50MHz on a Spartan Virtex-II device) the subtraction process takes two clock cycles instead of one. </Body><Normal>Table 3 summarizes the possible resulting values based on subtractions involving the various combinations of floating-point operands, including the special values listed in Table 1(refer back to the section <Link>Special values</Link>). </Normal><Shape><ImageData src="images/fpu_ip_altium_2008_img_3.jpg"/></Shape><Normal>Table 3. Subtraction of operands. </Normal><Table><THead><TR><TD><RightJustified>OP1  </RightJustified><Body>OP2 </Body></TD><TD><BoldCentered>NaN </BoldCentered></TD><TD><BoldCentered>+Infinity </BoldCentered></TD><TD><BoldCentered>-Infinity </BoldCentered></TD><TD><BoldCentered>+0 </BoldCentered></TD><TD><BoldCentered>-0 </BoldCentered></TD><TD><BoldCentered>+Num </BoldCentered></TD><TD><BoldCentered>-Num </BoldCentered></TD></TR></THead><TBody><TR><TD><RightJustified>NaN</RightJustified></TD><TD><Centered>NaN </Centered></TD><TD><Centered>NaN </Centered></TD><TD><Centered>NaN </Centered></TD><TD><Centered>NaN </Centered></TD><TD><Centered>NaN </Centered></TD><TD><Centered>NaN </Centered></TD><TD><Centered>NaN </Centered></TD></TR><TR><TD><RightJustified>+Infinity</RightJustified></TD><TD><Centered>NaN </Centered></TD><TD><Centered>NaN </Centered></TD><TD><Centered>-Infinity </Centered></TD><TD><Centered>-Infinity </Centered></TD><TD><Centered>-Infinity </Centered></TD><TD><Centered>-Infinity </Centered></TD><TD><Centered>-Infinity </Centered></TD></TR><TR><TD><RightJustified>-Infinity</RightJustified></TD><TD><Centered>NaN </Centered></TD><TD><Centered>+Infinity </Centered></TD><TD><Centered>NaN </Centered></TD><TD><Centered>+Infinity </Centered></TD><TD><Centered>+Infinity </Centered></TD><TD><Centered>+Infinity </Centered></TD><TD><Centered>+Infinity </Centered></TD></TR><TR><TD><RightJustified>+0</RightJustified></TD><TD><Centered>NaN </Centered></TD><TD><Centered>+Infinity </Centered></TD><TD><Centered>-Infinity </Centered></TD><TD><Centered>+0 </Centered></TD><TD><Centered>-0 </Centered></TD><TD><Centered>+Num </Centered></TD><TD><Centered>-Num </Centered></TD></TR><TR><TD><RightJustified>-0</RightJustified></TD><TD><Centered>NaN </Centered></TD><TD><Centered>+Infinity </Centered></TD><TD><Centered>-Infinity </Centered></TD><TD><Centered>+0 </Centered></TD><TD><Centered>+0 </Centered></TD><TD><Centered>+Num </Centered></TD><TD><Centered>-Num </Centered></TD></TR><TR><TD><RightJustified>+Num</RightJustified></TD><TD><Centered>NaN </Centered></TD><TD><Centered>+Infinity </Centered></TD><TD><Centered>-Infinity </Centered></TD><TD><Centered>-Num </Centered></TD><TD><Centered>-Num </Centered></TD><TD><Centered>±Num +0 </Centered></TD><TD><Centered>-Num -Infinity </Centered></TD></TR><TR><TD><RightJustified>-Num</RightJustified></TD><TD><Centered>NaN </Centered></TD><TD><Centered>+Infinity </Centered></TD><TD><Centered>-Infinity </Centered></TD><TD><Centered>+Num </Centered></TD><TD><Centered>+Num </Centered></TD><TD><Centered>+Num +Infinity </Centered></TD><TD><Centered>±Num +0 </Centered></TD></TR></TBody></Table><heading-4 id="LinkTarget_1248">Multiplication </heading-4><Body>Multiplication of two floating-point values involves addition of their exponents and multiplication of their significands. The resulting sign is an XOR function of the signs of both operands. </Body><Normal>Table 4 summarizes the possible resulting values based on multiplications involving the various combinations of floating-point operands, including the special values listed in Table 1 (refer back to the section <Link>Special values</Link>). </Normal><Normal>Table 4. Multiplication of operands. </Normal><Table><THead><TR><TD><RightJustified>OP1  </RightJustified><Body>OP2 </Body></TD><TD><BoldCentered>NaN </BoldCentered></TD><TD><BoldCentered>+Infinity </BoldCentered></TD><TD><BoldCentered>-Infinity </BoldCentered></TD><TD><BoldCentered>+0 </BoldCentered></TD><TD><BoldCentered>-0 </BoldCentered></TD><TD><BoldCentered>+Num </BoldCentered></TD><TD><BoldCentered>-Num </BoldCentered></TD></TR></THead><TBody><TR><TD><RightJustified>NaN</RightJustified></TD><TD><Centered>NaN </Centered></TD><TD><Centered>NaN </Centered></TD><TD><Centered>NaN </Centered></TD><TD><Centered>NaN </Centered></TD><TD><Centered>NaN </Centered></TD><TD><Centered>NaN </Centered></TD><TD><Centered>NaN </Centered></TD></TR><TR><TD><RightJustified>+Infinity</RightJustified></TD><TD><Centered>NaN </Centered></TD><TD><Centered>+Infinity </Centered></TD><TD><Centered>-Infinity </Centered></TD><TD><Centered>NaN </Centered></TD><TD><Centered>NaN </Centered></TD><TD><Centered>+Infinity </Centered></TD><TD><Centered>-Infinity </Centered></TD></TR><TR><TD><RightJustified>-Infinity</RightJustified></TD><TD><Centered>NaN </Centered></TD><TD><Centered>-Infinity </Centered></TD><TD><Centered>+Infinity </Centered></TD><TD><Centered>NaN </Centered></TD><TD><Centered>NaN </Centered></TD><TD><Centered>-Infinity </Centered></TD><TD><Centered>+Infinity </Centered></TD></TR><TR><TD><RightJustified>+0</RightJustified></TD><TD><Centered>NaN </Centered></TD><TD><Centered>NaN </Centered></TD><TD><Centered>NaN </Centered></TD><TD><Centered>+0 </Centered></TD><TD><Centered>-0 </Centered></TD><TD><Centered>+0 </Centered></TD><TD><Centered>-0 </Centered></TD></TR><TR><TD><RightJustified>-0</RightJustified></TD><TD><Centered>NaN </Centered></TD><TD><Centered>NaN </Centered></TD><TD><Centered>NaN </Centered></TD><TD><Centered>-0 </Centered></TD><TD><Centered>+0 </Centered></TD><TD><Centered>-0 </Centered></TD><TD><Centered>+0 </Centered></TD></TR><TR><TD><RightJustified>+Num</RightJustified></TD><TD><Centered>NaN </Centered></TD><TD><Centered>+Infinity </Centered></TD><TD><Centered>-Infinity </Centered></TD><TD><Centered>+0 </Centered></TD><TD><Centered>-0 </Centered></TD><TD><Centered>+Num +Infinity </Centered></TD><TD><Centered>-Num -Infinity </Centered></TD></TR><TR><TD><RightJustified>-Num</RightJustified></TD><TD><Centered>NaN </Centered></TD><TD><Centered>+Infinity </Centered></TD><TD><Centered>+Infinity </Centered></TD><TD><Centered>-0 </Centered></TD><TD><Centered>+0 </Centered></TD><TD><Centered>-Num -Infinity </Centered></TD><TD><Centered>+Num +Infinity </Centered></TD></TR></TBody></Table><heading-4 id="LinkTarget_1316">Division </heading-4><Body>Division of two floating-point numbers is similar to multiplication. It involves subtraction of their exponents and division of their significands. The resulting sign is an XOR function of the signs of both operands. </Body><Normal>Table 5 summarizes the possible resulting values based on divisions involving the various combinations of floating-point operands, including the special values listed in Table 1 (refer back to the section <Link>Special values</Link>). </Normal><Normal>Table 5. Division of operands. </Normal><Table><THead><TR><TD><RightJustified>OP1  </RightJustified><Body>OP2 </Body></TD><TD><BoldCentered>NaN </BoldCentered></TD><TD><BoldCentered>+Infinity </BoldCentered></TD><TD><BoldCentered>-Infinity </BoldCentered></TD><TD><BoldCentered>+0 </BoldCentered></TD><TD><BoldCentered>-0 </BoldCentered></TD><TD><BoldCentered>+Num </BoldCentered></TD><TD><BoldCentered>-Num </BoldCentered></TD></TR></THead><TBody><TR><TD><RightJustified>NaN</RightJustified></TD><TD><Centered>NaN </Centered></TD><TD><Centered>NaN </Centered></TD><TD><Centered>NaN </Centered></TD><TD><Centered>NaN </Centered></TD><TD><Centered>NaN </Centered></TD><TD><Centered>NaN </Centered></TD><TD><Centered>NaN </Centered></TD></TR><TR><TD><RightJustified>+Infinity</RightJustified></TD><TD><Centered>NaN </Centered></TD><TD><Centered>NaN </Centered></TD><TD><Centered>NaN </Centered></TD><TD><Centered>+0 </Centered></TD><TD><Centered>-0 </Centered></TD><TD><Centered>+0 </Centered></TD><TD><Centered>-0 </Centered></TD></TR><TR><TD><RightJustified>-Infinity</RightJustified></TD><TD><Centered>NaN </Centered></TD><TD><Centered>NaN </Centered></TD><TD><Centered>NaN </Centered></TD><TD><Centered>-0 </Centered></TD><TD><Centered>+0 </Centered></TD><TD><Centered>-0 </Centered></TD><TD><Centered>+0 </Centered></TD></TR><TR><TD><RightJustified>+0</RightJustified></TD><TD><Centered>NaN </Centered></TD><TD><Centered>+Infinity </Centered></TD><TD><Centered>-Infinity </Centered></TD><TD><Centered>NaN </Centered></TD><TD><Centered>NaN </Centered></TD><TD><Centered>+Infinity </Centered></TD><TD><Centered>-Infinity </Centered></TD></TR><TR><TD><RightJustified>-0</RightJustified></TD><TD><Centered>NaN </Centered></TD><TD><Centered>-Infinity </Centered></TD><TD><Centered>+Infinity </Centered></TD><TD><Centered>NaN </Centered></TD><TD><Centered>NaN </Centered></TD><TD><Centered>-Infinity </Centered></TD><TD><Centered>+Infinity </Centered></TD></TR><TR><TD><RightJustified>+Num</RightJustified></TD><TD><Centered>NaN </Centered></TD><TD><Centered>+Infinity </Centered></TD><TD><Centered>-Infinity </Centered></TD><TD><Centered>+0 </Centered></TD><TD><Centered>-0 </Centered></TD><TD><Centered>+Num </Centered></TD><TD><Centered>-Num </Centered></TD></TR><TR><TD><RightJustified>-Num</RightJustified></TD><TD><Centered>NaN </Centered></TD><TD><Centered>-Infinity </Centered></TD><TD><Centered>+Infinity </Centered></TD><TD><Centered>-0 </Centered></TD><TD><Centered>+0 </Centered></TD><TD><Centered>-Num </Centered></TD><TD><Centered>+Num </Centered></TD></TR></TBody></Table><Normal id="LinkTarget_1063">Rounding </Normal><Body>The IEEE 754 standard describes the following four rounding methods: </Body><L><LI><LBody>• Truncate </LBody></LI><LI><LBody>• Round down (towards –infinity) </LBody></LI><LI><LBody>• Round up (towards +infinity) </LBody></LI><LI><LBody>• Round to nearest even. </LBody></LI></L><Body>The WB_FPU implements the last of these – round to nearest even – since this is the method used in standard C programming. This method implements rounding to the nearest possible value, except where the initial value is mid-way between the higher and lower values. In such cases, even values will be rounded down and odd values will be rounded up. </Body><Body>Rounding in the WB_FPU is performed as follows: </Body><Body>if (guard &amp;&amp; (LSB or sticky)) then </Body><Body>   round_up(); </Body><Body>else </Body><Body>   round_down(); </Body><Body>end if; </Body><Body>LSB is the least significant bit of the significand resulting from a calculation. The Guard and Sticky bits are used as an aid in rounding and can be summarized as follows: </Body><L><LI><LBody>• Guard bit – this is the first bit that does not fit into a significand (i.e. the bit to the right of the significand's LSB) </LBody></LI><LI><LBody>• Sticky bit – this is an OR-reduced term for the complete set of bits that do not fit in the significand (i.e. bits to the right of the LSB and guard bits). </LBody></LI></L><Normal id="LinkTarget_881">Functional Description </Normal><Normal id="LinkTarget_882">Symbol </Normal><Graphic-Centered><InlineShape><ImageData src="images/fpu_ip_altium_2008_img_4.jpg"/></InlineShape> </Graphic-Centered><Normal>Figure 2. WB_FPU Symbol. </Normal><Normal id="LinkTarget_886">Pin Description </Normal><Normal>Table 6. WB_FPU pin description </Normal><Table><THead><TR><TD><Body>Name</Body></TD><TD><Body>Type</Body></TD><TD><Body>Polarity/ Bus size</Body></TD><TD><Body>Description</Body></TD></TR></THead><TBody><TR><TD><BoldCentered>Control Signals </BoldCentered></TD></TR><TR><TD><Body>CLK_I </Body></TD><TD><Centered>I </Centered></TD><TD><Centered>Rise </Centered></TD><TD><Body>External (system) clock signal </Body></TD></TR><TR><TD><Body>RST_I </Body></TD><TD><Centered>I </Centered></TD><TD><Centered>High </Centered></TD><TD><Body>External (system) reset </Body></TD></TR><TR><TD><BoldCentered>Host Processor Interface Signals </BoldCentered></TD></TR><TR><TD><Body>STB_I </Body></TD><TD><Centered>I </Centered></TD><TD><Centered>High </Centered></TD><TD><Body>Strobe signal. When asserted, indicates the start of a valid Wishbone data transfer cycle </Body></TD></TR><TR><TD><Body>CYC_I </Body></TD><TD><Centered>I </Centered></TD><TD><Centered>High </Centered></TD><TD><Body>Cycle signal. When asserted, indicates the start of a valid Wishbone cycle </Body></TD></TR><TR><TD><Body>ACK_O </Body></TD><TD><Centered>O </Centered></TD><TD><Centered>High </Centered></TD><TD><Body>Standard Wishbone device acknowledgement signal. When this signal goes high, the Floating-point Unit (Wishbone Slave) has finished execution of the requested action and the current bus cycle is terminated </Body></TD></TR><TR><TD><Body>ADR_I </Body></TD><TD><Centered>I </Centered></TD><TD><Centered>3 </Centered></TD><TD><Body>Address bus, used to select an internal register of the device for writing to/reading from </Body></TD></TR><TR><TD><Body>DAT_O </Body></TD><TD><Centered>O </Centered></TD><TD><Centered>32 </Centered></TD><TD><Body>Data to be sent to host processor </Body></TD></TR><TR><TD><Body>DAT_I </Body></TD><TD><Centered>I </Centered></TD><TD><Centered>32 </Centered></TD><TD><Body>Data received from host processor </Body></TD></TR><TR><TD><Body>WE_I </Body></TD><TD><Centered>I </Centered></TD><TD><Centered>Level </Centered></TD><TD><Body>Write enable signal. Used to indicate whether the current local bus cycle is a Read or Write cycle: </Body><Body>0 = Read </Body><Body>1 = Write </Body></TD></TR></TBody></Table><Normal id="LinkTarget_860">Hardware Description </Normal><Normal id="LinkTarget_861">Block Diagram </Normal><Normal> </Normal><Normal>Figure 3. WB_FPU block diagram. </Normal><Normal>Internal Units </Normal><Body>The following sections detail the various units that constitute the WB_FPU. </Body><heading-3>Denormalization Units </heading-3><Body>Denormalized numbers themselves are not supported in the WB_FPU. However, for the purposes of calculation, it is necessary to internally perform a light form of denormalization. The Denormalization Unit takes an IEEE 754-formatted floating-point number and splits it into a &quot;float&quot; typed signal containing the following information bits: </Body><L><LI><LBody>• NaN, Infinity and Zero bits – indicating special values </LBody></LI><LI><LBody>• 1-bit Sign </LBody></LI><LI><LBody>• 10-bit Exponent </LBody></LI><LI><LBody>• 24-bit Significand – consisting the implicit or hidden bit as the MSB, followed by the fraction </LBody></LI><LI><LBody>• Guard and Sticky bits – used as an aid in rounding. </LBody></LI></L><Normal>The internal representation of the exponent has two extra bits – MSB and MSB-1 – both of which are initially set to '0'. These bits are used to facilitate easy detection of exponent underflow and overflow in the calculation units (see <Link>Normalization Units</Link>). </Normal><Normal>When the Denormalization Unit has finished constructing the internal float value it will set a ready flag, to indicate that this value is ready for further processing. </Normal><TextBox><Normal id="LinkTarget_859">The exponent in the denormalized value is still biased. This avoids the need for extra hardware to perform bias handling in both Denormalization and Normalization units. </Normal></TextBox><indent>Two Denormalization Units are included, for operand A and operand B respectively. Each unit takes its input directly from the Wishbone interface (on the DAT_I bus), provided a write to the corresponding operand address (1h for OPA and 2h for OPB) is being performed. </indent><heading-3 id="LinkTarget_823">Conversion Units </heading-3><Body>The WB_FPU contains two conversion units – one for floating-point-to-integer (FTOI) conversion and one for integer-to-floating-point (ITOF) conversion. </Body><Body>The ITOF Unit takes its input (a 32-bit integer value) directly from the Wishbone interface (on the DAT_I bus), provided a write to the OPA address (1h) is being performed. The unit generates an internal float-typed signal and a ready signal – to signal the subsequent Normalization Unit that the converted value is ready for processing. </Body><Body>The FTOI Unit takes its input (an internal float-typed value) from the Denormalization Unit associated with OPA, which in turn takes its input (an IEEE 754-formatted floating-point value) directly from the Wishbone interface (on the DAT_I bus), provided a write to the OPA address (1h) is being performed. The unit converts the float-typed value to a 32-bit integer and generates a ready flag – to signal that the converted value is ready for transfer over the Wishbone interface. </Body><heading-3 id="LinkTarget_827">Addition Unit </heading-3><Body>The Addition Unit is able to add two IEEE 754 floating-point values (OPA and OPB) without taking signs into account. </Body><Body>The unit takes its operand inputs from the Denormalization Units. The result of the addition may have Guard and Sticky bits set for rounding purposes, and the special value bits (NaN, Infinity, Zero) will be updated if required. Once the calculation is complete a ready flag will be set, to signal the subsequent Normalization Unit that a new value is ready. </Body><Body>The resulting Sign bit will be that of OPA. </Body><indent>Since addition is performed without regard for sign, operands with different signs should be subtracted rather than added. When reading the result of an addition (reading address 2h) featuring operands of equal sign, the normalized result from the Addition Unit will be obtained. When the signs differ, the normalized result from the Subtraction Unit will be obtained instead. </indent><heading-3 id="LinkTarget_832">Subtraction Unit </heading-3><Body>The Subtraction Unit is able to subtract two IEEE 754 floating-point values (OPA and OPB) without taking signs into account. The smaller value is always subtracted from the larger. </Body><Body>The unit takes its operand inputs from the Denormalization Units. The result of the subtraction may have Guard and Sticky bits set for rounding purposes, and the special value bits (NaN, Infinity, Zero) will be updated if required. Once the calculation is complete a ready flag will be set, to signal the subsequent Normalization Unit that a new value is ready. </Body><Body>The resulting Sign bit will depend on the initial operand values: </Body><L><LI><LBody>• If OPA &lt; OPB, then the resulting Sign bit will be the inverse of the original Sign bit for OPA </LBody></LI><LI><LBody>• If OPA &gt; OPB, then the resulting Sign bit will be that of OPA. <indent>Since subtraction is performed without regard for sign, operands with different signs should be added rather than subtracted. When reading the result of a subtraction (reading address 3h) featuring operands of equal sign, the normalized result from the Subtraction Unit will be obtained. When the signs differ, the normalized result from the Addition Unit will be obtained instead. </indent></LBody></LI></L><heading-3 id="LinkTarget_839">Multiplication Unit </heading-3><Body>The Multiplication Unit multiplies two IEEE 754 floating-point values (OPA and OPB). </Body><Body>The unit takes its operand inputs from the Denormalization Units. The result of the multiplication may have Guard and Sticky bits set for rounding purposes, and the special value bits (NaN, Infinity, Zero) will be updated if required. Once the calculation is complete a ready flag will be set, to signal the subsequent Normalization Unit that a new value is ready. </Body><heading-3 id="LinkTarget_842">Division Unit </heading-3><Body>The Division Unit divides two IEEE 754 floating-point values (OPA by OPB). </Body><Body>The unit takes its operand inputs from the Denormalization Units. The result of the division may have Guard and Sticky bits set for rounding purposes, and the special value bits (NaN, Infinity, Zero) will be updated if required. Once the calculation is complete a ready flag will be set, to signal the subsequent Normalization Unit that a new value is ready. </Body><indent>Division is not a ready-to-use operational block in VHDL. Therefore a successive approximation algorithm has been implemented that determines one bit of the significand per cycle of CLK_I. As a result, the floating-point division operator is slower in comparison to the other operators. </indent><Shape><ImageData src="images/fpu_ip_altium_2008_img_5.jpg"/></Shape><Shape><ImageData src="images/fpu_ip_altium_2008_img_6.jpg"/></Shape><Shape><ImageData src="images/fpu_ip_altium_2008_img_7.jpg"/></Shape><Shape><ImageData src="images/fpu_ip_altium_2008_img_8.jpg"/></Shape><heading-3 id="LinkTarget_677">Normalization Units </heading-3><Body>The Normalization Unit takes as input an internally-formatted float-typed number and constructs the corresponding IEEE 754-formatted floating-point value. The value will be rounded in accordance with the significand LSB, the Guard and Sticky bits. Once construction of the IEEE 754 floating-point value is complete, the unit generates a ready flag – to signal that the value is ready for transfer over the Wishbone interface. </Body><heading-4 id="LinkTarget_679">Effect of Special Bits </heading-4><Body>The special value bits of the input number (NaN, Infinity, Zero) are checked, with the following influence on the resulting IEEE 754 floating-point value: </Body><L><LI><LBody>• If the NaN bit of the input value is '1', then the Sign of the resulting IEEE 754 float will be set to '0' and all other bits (30..0) set to '1'. </LBody></LI></L><Table><TBody><TR><TD><Centered>Sign </Centered></TD><TD><Centered>Exponent </Centered></TD><TD><Centered>Significand </Centered></TD></TR><TR><TD><Centered>0 </Centered></TD><TD><Centered>11111111 </Centered></TD><TD><Centered>11111111111111111111111 </Centered></TD></TR></TBody></Table><L><LI><LBody>• If the Infinity bit is '1', then the Sign of the IEEE 754 float will be set to that of the input number, the Exponent will be set to all '1's and the Significand set to all '0's. </LBody></LI></L><Table><TBody><TR><TD><Centered>Sign </Centered></TD><TD><Centered>Exponent </Centered></TD><TD><Centered>Significand </Centered></TD></TR><TR><TD><Centered>Input Sign </Centered></TD><TD><Centered>11111111 </Centered></TD><TD><Centered>00000000000000000000000 </Centered></TD></TR></TBody></Table><L><LI><LBody>• If the Zero bit of the input value is '1', then the Sign of the IEEE 754 float will be set to that of the input number and all other bits (30..0) set to '0'. </LBody></LI></L><Table><TBody><TR><TD><Centered>Sign </Centered></TD><TD><Centered>Exponent </Centered></TD><TD><Centered>Significand </Centered></TD></TR><TR><TD><Centered>Input Sign </Centered></TD><TD><Centered>00000000 </Centered></TD><TD><Centered>00000000000000000000000 </Centered></TD></TR></TBody></Table><heading-4 id="LinkTarget_702">Exponent Underflow and Overflow Detection </heading-4><Body>As mentioned previously, the internal representation of the exponent has two extra bits – MSB and MSB-1 – both of which are used to facilitate easy detection of exponent underflow and overflow in a calculation unit. Detection is as follows: </Body><L><LI><LBody>• If MSB of exponent is '1', the resulting exponent underflows and the IEEE 754 floating-point number returned will be rounded to zero by the Normalization Unit (i.e. all exponent and significand bits set to '0'). </LBody></LI><LI><LBody>• If MSB of exponent is '0' but MSB-1 is '1', the resulting exponent overflows and the IEEE 754 floating-point number returned will be rounded to infinity by the Normalization Unit (i.e. all exponent bits set to '1' and all significand bits set to '0'). </LBody></LI></L><Normal id="LinkTarget_706">Internal Registers </Normal><Body>Internal registers within the WB_FPU are not accessed directly. Their content is loaded or accessed by writing to/reading from a particular address (highlighted using a gray background in the block diagram of Figure 3). The following sections summarize each of these addresses. </Body><heading-3 id="LinkTarget_708">Status Address (STATUS) </heading-3><Body>Address: 0h </Body><Body>Access: Read only </Body><Body>Internal Register Accessed: BUSY </Body><Body>This address is used to access the BUSY register, which is used to determine the state of the calculation and conversion units – which are still busy and which are ready. </Body><Normal>Table 7. The BUSY register </Normal><Table><TBody><TR><TD><Body>MSB </Body></TD><TD><Centered> </Centered></TD><TD><Centered> </Centered></TD><TD><Centered> </Centered></TD><TD><Centered> </Centered></TD><TD><RightJustified>LSB </RightJustified></TD></TR><TR><TD><Body>31                                                                                                   6 </Body></TD><TD><Centered>5 </Centered></TD><TD><Centered>4 </Centered></TD><TD><Centered>3 </Centered></TD><TD><Centered>2 </Centered></TD><TD><Centered>1 </Centered></TD><TD><Centered>0 </Centered></TD></TR><TR><TD><Centered>- </Centered></TD><TD><Centered>ftoi </Centered></TD><TD><Centered>itof </Centered></TD><TD><Centered>div </Centered></TD><TD><Centered>mul </Centered></TD><TD><Centered>sub </Centered></TD><TD><Centered>add </Centered></TD></TR></TBody></Table><captionspace> </captionspace><Normal>Table 8. The BUSY register bit functions </Normal><Table><THead><TR><TD><BoldCentered>Bit </BoldCentered></TD><TD><BoldCentered>Symbol </BoldCentered></TD><TD><BoldCentered>Function </BoldCentered></TD></TR></THead><TBody><TR><TD><Body>BUSY.31..BUSY.6 </Body></TD><TD><Centered>- </Centered></TD><TD><Body>Not Used. </Body></TD></TR><TR><TD><Body>BUSY.5 </Body></TD><TD><Centered>ftoi </Centered></TD><TD><Body>Float to Integer Unit state. </Body><Body>0 = Ready </Body><Body>1 = Busy </Body></TD></TR><TR><TD><Body>BUSY.4 </Body></TD><TD><Centered>itof </Centered></TD><TD><Body>Integer to Float Unit state. </Body><Body>0 = Ready </Body><Body>1 = Busy </Body></TD></TR><TR><TD><Body>BUSY.3 </Body></TD><TD><Centered>div </Centered></TD><TD><Body>Division Unit state. </Body><Body>0 = Ready </Body><Body>1 = Busy </Body></TD></TR><TR><TD><Body>BUSY.2 </Body></TD><TD><Centered>mul </Centered></TD><TD><Body>Multiplication Unit state </Body><Body>0 = Ready </Body><Body>1 = Busy </Body></TD></TR><TR><TD><Body>BUSY.1 </Body></TD><TD><Centered>sub </Centered></TD><TD><Body>Subtraction Unit state. </Body><Body>0 = Ready </Body><Body>1 = Busy </Body></TD></TR><TR><TD><Body>BUSY.0 </Body></TD><TD><Centered>add </Centered></TD><TD><Body>Addition Unit state. </Body><Body>0 = Ready </Body><Body>1 = Busy </Body></TD></TR></TBody></Table><heading-3 id="LinkTarget_611">Operand A Address (OPA) </heading-3><Body>Address: 1h </Body><Body>Access: Write only </Body><Body>Write to this address to: </Body><L><LI><LBody>• Load a 32-bit integer value directly into the Integer to Float Unit for processing. </LBody></LI><LI><LBody>• Load an IEEE 754-formatted value directly into the Denormalization Unit associated with Operand A. </LBody></LI></L><Body>Writing to this address will cause the calculation units, the Float to Integer Unit and the Normalization units to be reset. The BUSY register will be loaded with all '1's during this time. The WB_FPU will send an Acknowledge signal that it has received the loaded data. </Body><heading-3 id="LinkTarget_620">Operand B Address (OPB) </heading-3><Body>Address: 2h </Body><Body>Access: Write </Body><Body>Write to this address to load an IEEE 754-formatted value directly into the Denormalization Unit associated with Operand B. </Body><Body>Writing to this address will cause the calculation units, the Float to Integer Unit and the Normalization Units to be reset. The BUSY register will be loaded with all '1's during this time. The WB_FPU will send an Acknowledge signal that it has received the loaded data. </Body><indent>This address is used for two purposes – loading operand B and reading the result of an addition. Provided you are performing a Write (WE_I input High) you will access the Denormalization Unit. </indent><heading-3 id="LinkTarget_628">Addition Result Address (ADD) </heading-3><Body>Address: 2h </Body><Body>Access: Read </Body><Body>Internal Register Accessed: ADD_RES </Body><Shape><ImageData src="images/fpu_ip_altium_2008_img_9.jpg"/></Shape><Body>This address is used to access the ADD_RES register, containing the normalized result of OPA + OPB. The resulting floating-point value will be set to infinity on overflow. </Body><indent>This address is used for two purposes – loading operand B and reading the result of an addition. Provided you are performing a Read (WE_I input Low) you will access the ADD_RES register. The exception to this is when the original operands (OPA and OPB) are of different sign. In this case, performing a read of this address will obtain the result stored in the SUB_RES register. </indent><heading-3 id="LinkTarget_521">Subtraction Result Address (SUB) </heading-3><Body>Address: 3h </Body><Body>Access: Read </Body><Body>Internal Register Accessed: SUB_RES </Body><Body>This address is used to access the SUB_RES register, containing the normalized result of OPA - OPB. The resulting floating-point value will be set to infinity on overflow. </Body><indent>This address is used for two purposes – loading operands A and B simultaneously (see next section) and reading the result of a subtraction. Provided you are performing a Read (WE_I input Low) you will access the SUB_RES register. The exception to this is when the original operands (OPA and OPB) are of different sign. In this case, performing a read of this address will obtain the result stored in the ADD_RES register. </indent><heading-4 id="LinkTarget_530">Dual Operand Loading </heading-4><Body>Provided you are performing a Write (WE_I input High) to address 3h, you can load the same floating-point value for both operands (OPA and OPB) simultaneously. You can then read the ADD_RES register (address 2h) or MUL_RES register (address 4h) to obtain a cheap 2x or x2<Superscript/> result. </Body><heading-3 id="LinkTarget_535">Multiplication Result Address (MUL) </heading-3><Body>Address: 4h </Body><Body>Access: Read only </Body><Body>Internal Register Accessed: MUL_RES </Body><Body>This address is used to access the MUL_RES register, containing the normalized result of OPA * OPB. The resulting floating-point value will be set to infinity on overflow and zero on underflow. </Body><heading-3 id="LinkTarget_543">Division Result Address (DIV) </heading-3><Body>Address: 5h </Body><Body>Access: Read only </Body><Body>Internal Register Accessed: DIV_RES </Body><Body>This address is used to access the DIV_RES register, containing the normalized result of OPA / OPB. The resulting floating-point value will be set to infinity on overflow or divide-by-zero, zero on underflow, and NaN for zero/zero. </Body><heading-3 id="LinkTarget_551">Integer to Float Result Address (ITOF) </heading-3><Body>Address: 6h </Body><Body>Access: Read only </Body><Body>Internal Register Accessed: ITOF_RES </Body><Body>This address is used to access the ITOF_RES register, containing the normalized result of the conversion from 32-bit integer value into IEEE 754-formatted floating-point value. </Body><heading-3 id="LinkTarget_559">Float to Integer Result Address (FTOI) </heading-3><Body>Address: 7h </Body><Body>Access: Read only </Body><Body>Internal Register Accessed: ITOF_RES </Body><Body>This address is used to access the FTOI_RES register, containing the result of the conversion from IEEE 754-formatted floating-point value into 32-bit integer. </Body><Shape><ImageData src="images/fpu_ip_altium_2008_img_10.jpg"/></Shape><Shape><ImageData src="images/fpu_ip_altium_2008_img_11.jpg"/></Shape><Normal id="LinkTarget_501">Interfacing to a 32-bit Processor </Normal><Body>Figure 4 shows an example of how a WB_FPU device can be wired into a design that uses a 32-bit processor – in this case a TSK3000A. A configurable Wishbone Interconnect device (WB_INTERCON) is used to simplify connection and also handle the word addressing – taking the 24-bit address line from the processor and mapping it to the 3-bit address line used to drive the WB_FPU. </Body><Graphic><InlineShape><ImageData src="images/fpu_ip_altium_2008_img_12.jpg"/></InlineShape> </Graphic><Normal>Figure 4. Example interfacing between a 32-bit processor (TSK3000A) and a WB_FPU. </Normal><Body>When configuring the WB_INTERCON device – in particular the WB_FPU slave interface – ensure that the Address Bus Mode is set to Word Addressing – ADR_O(0) &lt;= ADR_I(1 or 2). As the WB_FPU's data bus width is 32-bit, the two lowest address bits are not connected to the slave device. ADR_I(2) of the master is mapped to ADR_O(0) of the slave, providing sequential word addresses (or addresses at every 4 bytes). Bits 4..2 of the output address line from the host processor  (IO_ADR_O) are therefore mapped, through the WB_INTERCON, to bits 2..0 of the WB_FPU's input address line (ADR_I). </Body><Body>The actual 24-bit address sent out from the processor on its IO_ADR_O line is therefore constructed as follows: </Body><Graphic-Centered>WB_FPU Base Address + (Internal Register Address &amp; &quot;00&quot;) </Graphic-Centered><Body>The Base Address for the WB_FPU is specified as part of the peripheral’s definition when adding it as a slave to the Wishbone Interconnect. For example, if the base address entered for the device is 100000h (mapping it to address FF10_0000h in the processor’s address space), and you want to read the result of a multiplication from the MUL_RES register with address 4h, the value entered on the processor’s IO_ADR_O line would be: </Body><Graphic-Centered>100000h + 10h = 100010h </Graphic-Centered><Normal>For further information on the Wishbone Interconnect, refer to the <Link>WB_INTERCON Configurable Wishbone Interconnect</Link> core reference. </Normal><Normal>For further information on the TSK3000A processor, refer to the <Link>TSK3000A 32-bit RISC Processor</Link> core reference. Similar references can be found for other 32-bit processors supported by Altium Designer, by using the lower section of the Knowledge Center panel and navigating to the Documentation Library » Embedded Processors and Software Development » FPGA Based and Discrete Processors section. </Normal><Shape><ImageData src="images/fpu_ip_altium_2008_img_13.jpg"/></Shape><Shape><ImageData src="images/fpu_ip_altium_2008_img_13.jpg"/></Shape><Normal id="LinkTarget_466">Host to Controller Communications </Normal><Body>Communications between a 32-bit host processor and the WB_FPU are carried out over a standard Wishbone bus interface. The following sections detail the communication cycles involved  between Host and peripheral for writing to/reading from the internal registers. </Body><heading-3 id="LinkTarget_468">Writing to an Internal Register </heading-3><Body>Data is written from the host processor to an internal register in the WB_FPU, in accordance with the standard Wishbone data transfer handshaking protocol. The write operation occurs on the rising edge of the CLK_I signal and can be summarized as follows: </Body><L><LI><LBody>• The host presents the required 24-bit address based on the register to be written on its IO_ADR_O output and valid data on its IO_DAT_O output. It then asserts its IO_WE_O signal, to specify a write cycle </LBody></LI><LI><LBody>• The WB_FPU receives the 3-bit address on its ADR_I input and, identifying the addressed register, prepares to receive data into that register </LBody></LI><LI><LBody>• The host asserts its IO_STB_O and IO_CYC_O outputs, indicating that the transfer is to begin. The WB_FPU, which monitors its STB_I and CYC_I inputs on each rising edge of the CLK_I signal, reacts to this assertion by latching the data appearing at its DAT_I input into the target register and asserting its ACK_O signal – to indicate to the host that the data has been received </LBody></LI><LI><LBody>• The host, which monitors its IO_ACK_I input on each rising edge of the CLK_I signal, responds by negating the IO_STB_O and IO_CYC_O signals. At the same time, the WB_FPU negates the ACK_O signal and the data transfer cycle is naturally terminated. <indent>Remember that when writing to the OPA or OPB address, you are actually loading a value directly into the corresponding Denormalization Unit (and the Integer to Float Unit for OPA). </indent></LBody></LI></L><Normal id="LinkTarget_475">Reading from an Internal Register </Normal><Body>Data is read from an internal register in accordance with the standard Wishbone data transfer handshaking protocol. The read operation, which occurs on the rising edge of the CLK_I signal, can be summarized as follows: </Body><L><LI><LBody>• The host presents the required 24-bit address based on the register to be read on its IO_ADR_O output. It then negates its IO_WE_O signal, to specify a read cycle </LBody></LI><LI><LBody>• The WB_FPU receives the 3-bit address on its ADR_I input and, identifying the addressed register, prepares to transmit data from the selected register </LBody></LI><LI><LBody>• The host asserts its IO_STB_O and IO_CYC_O outputs, indicating that the transfer is to begin. The WB_FPU, which monitors its STB_I and CYC_I inputs on each rising edge of the CLK_I signal, reacts to this assertion by presenting the valid data on its DAT_O output. The WB_FPU will assert its ACK_O signal – to indicate to the host that valid data is present – only when the corresponding status flag (in the BUSY register) for the applicable calculation or conversion unit is '0'. </LBody></LI><LI><LBody>• The host, which monitors its IO_ACK_I input on each rising edge of the CLK_I signal, responds by latching the data appearing at its IO_DAT_I input and negating the IO_STB_O and IO_CYC_O signals. At the same time, the WB_FPU negates the ACK_O signal and the data transfer cycle is naturally terminated. </LBody></LI></L><Shape><ImageData src="images/fpu_ip_altium_2008_img_14.jpg"/></Shape><Normal id="LinkTarget_425">Operational Overview </Normal><Body>There is no initialization required for the WB_FPU. As soon as you write an operand value, the calculation and conversion units will be reset – clearing any stored values in the result registers. </Body><Normal id="LinkTarget_427">Example Code </Normal><Body>The following sections provide example code for each of the calculations and conversions supported by the WB_FPU. The coding assumes connection of the device to a 32-bit processor through a Wishbone Interconnect device (WB_INTERCON), and using the identifier &quot;FPU&quot; when configuring the slave interface therein. </Body><heading-3 id="LinkTarget_429">Addition </heading-3><Body>For addition, simply write the floating-point values for operand A and operand B and read the ADD_RES register (address 2h) for the result. Remember that if the operands are different in sign, reading this register will actually return the contents of the SUB_RES register. </Body><Code>#define fpu ((volatile float *) Base_FPU) </Code><Code> </Code><Code>#define OP1     fpu[1] </Code><Code>#define OP2     fpu[2] </Code><Code>#define ADD     fpu[2] </Code><Code> </Code><Code>// add(): returns a + b, negative or positive infinity on overflow </Code><Code>inline float add( float a, float b ) </Code><Code>{ </Code><Code> OP1 = a; </Code><Code> OP2 = b; </Code><Code> return ADD; </Code><Body>} </Body><heading-3 id="LinkTarget_444">Subtraction </heading-3><Body>For subtraction, simply write the floating-point values for operand A and operand B and read the SUB_RES register (address 3h) for the result. Remember that if the operands are different in sign, reading this register will actually return the contents of the ADD_RES register. </Body><Code>#define fpu ((volatile float *) Base_FPU) </Code><Code> </Code><Code>#define OP1     fpu[1] </Code><Code>#define OP2     fpu[2] </Code><Code>#define SUB     fpu[3] </Code><Code> </Code><Code>// sub(): returns a – b, negative or positive infinity on overflow </Code><Code>inline float sub( float a, float b ) </Code><Code>{ </Code><Code> OP1 = a; </Code><Code> OP2 = b; </Code><Code> return SUB; </Code><Body>} </Body><heading-3 id="LinkTarget_380">Multiplication </heading-3><Body>For multiplication, simply write the floating-point values for operand A and operand B and read the MUL_RES register (address 4h) for the result. </Body><Code>#define fpu ((volatile float *) Base_FPU) </Code><Code> </Code><Code>#define OP1     fpu[1] </Code><Code>#define OP2     fpu[2] </Code><Code>#define MUL     fpu[4] </Code><Code> </Code><Code>// mul(): returns a * b, negative or positive infinity on overflow, </Code><Code>//        zero on underflow </Code><Code>inline float mul( float a, float b ) </Code><Code>{ </Code><Code> OP1 = a; </Code><Code> OP2 = b; </Code><Code> return MUL; </Code><Body>} </Body><heading-3 id="LinkTarget_396">Division </heading-3><Body>For division, simply write the floating-point values for operand A and operand B and read the DIV_RES register (address 5h) for the result. </Body><Code>#define fpu ((volatile float *) Base_FPU) </Code><Code> </Code><Code>#define OP1     fpu[1] </Code><Code>#define OP2     fpu[2] </Code><Code>#define DIV     fpu[5] </Code><Code> </Code><Code>// div(): return a / b, positive or negative infinity on overflow or  </Code><Code>//        divide by zero. 0/0 returns NaN. Returns zero on underflow. </Code><Code>inline float div( float a, float b ) </Code><Code>{ </Code><Code> OP1 = a; </Code><Code> OP2 = b; </Code><Code> return DIV; </Code><Body>} </Body><heading-3 id="LinkTarget_412">Involution </heading-3><Body>To obtain a quick and cheap square of a single floating-point value, simply write the floating-point value to address 3h – effectively loading the same value for OPA and OPB – and read the MUL_RES register (address 4h) for the result. </Body><Code>#define fpu ((volatile float *) Base_FPU) </Code><Code> </Code><Code>#define OP12    fpu[3] </Code><Code>#define SQR     fpu[4] </Code><Code> </Code><Code>// sqr(): returns a * b, positive infinity on overflow or zero on  //        underflow </Code><Code>inline float sqr( float a ) </Code><Code>{ </Code><Code> OP12 = a; </Code><Code> return MUL; </Code><Body>} </Body><heading-3 id="LinkTarget_306">Integer to Float Conversion </heading-3><Body>To convert a 32-bit integer to an IEEE 754 floating-point value, simply write the integer to the address for operand A and read the ITOF_RES register (address 6h) for the result. </Body><Code>#define fpu ((volatile float *) Base_FPU) </Code><Code>#define xfpu ((volatile int *) Base_FPU) </Code><Code> </Code><Code>#define OP1     xfpu[1] </Code><Code>#define ITOF    fpu[6] </Code><Code> </Code><Code>// itof(): returns floating-point equivalent of a. </Code><Code>inline float itof( int a ) </Code><Code>{ </Code><Code> OP1 = a; </Code><Code> return ITOF; </Code><Code>} </Code><heading-3 id="LinkTarget_320">Float to Integer Conversion </heading-3><Body>To convert an IEEE 754 floating-point value to a 32-bit integer value, simply write the floating-point value to the address for operand A and read the FTOI_RES register (address 7h) for the result. </Body><Code>#define xfpu ((volatile int *) Base_FPU) </Code><Code>#define fpu ((volatile float *) Base_FPU) </Code><Code> </Code><Code>#define OP1     fpu[1] </Code><Code>#define FTOI    xfpu[7] </Code><Code> </Code><Code>// ftoi(): returns integer equivalent of a.  </Code><Code>inline float ftoi( int a ) </Code><Code>{ </Code><Code> OP1 = a; </Code><Code> return FTOI; </Code><Code>} </Code><Normal id="LinkTarget_334">Revision History </Normal><Table><TBody><TR><TD><Copyright>Date</Copyright></TD><TD><Copyright>Version No.</Copyright></TD><TD><Copyright>Revision<Bold/></Copyright></TD></TR><TR><TD><Copyright>12-Feb-2007 </Copyright></TD><TD><Copyright>1.0 </Copyright></TD><TD><Copyright>Initial release. </Copyright></TD></TR><TR><TD><Copyright>20-Sep-2007 </Copyright></TD><TD><Copyright>1.1 </Copyright></TD><TD><Copyright>Amended #define entries for fpu and xfpu in coding examples. </Copyright></TD></TR><TR><TD><Copyright>11-Mar-2008 </Copyright></TD><TD><Copyright>2.0 </Copyright></TD><TD><Copyright>Updated for Altium Designer Summer 08 </Copyright></TD></TR></TBody></Table><Copyright>Software, hardware, documentation and related materials:  </Copyright><Copyright>Copyright © 2008 Altium Limited. </Copyright><Copyright>All rights reserved. You are permitted to print this document provided that (1) the use of such is for personal use only and will not be copied or posted on any network computer or broadcast in any media, and (2) no modifications of the document is made. Unauthorized duplication, in whole or part, of this document by any means, mechanical or electronic, including translation into another language, except for brief excerpts in published reviews, is prohibited without the express written permission of Altium Limited. Unauthorized duplication of this work may also be prohibited by local statute. Violators may be subject to both criminal and civil penalties, including fines and/or imprisonment. Altium, Altium Designer, Board Insight, Design Explorer, DXP, LiveDesign, NanoBoard, NanoTalk, P-CAD, SimCode, Situs, TASKING, and Topological Autorouting and their respective logos are trademarks or registered trademarks of Altium Limited or its subsidiaries. All other registered or unregistered trademarks referenced herein are the property of their respective owners and no trademark rights to the same are claimed. </Copyright></Sect></TaggedPDF-doc>