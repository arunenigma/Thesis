<Part><H1>Test Article 0 
Datasheet 
</H1><P>Revision D 
May 13, 2008 
</P><P>University of Southern California 
Information Sciences Institute 
</P><Sect><H3>Table of Content 
</H3><P>Table of Content ............................................................................................................................. 2 
</P><P>1. Introduction................................................................................................................................. 3 
</P><P>2. Test Article and Floating-Point Unit Overview.......................................................................... 3 
2-1. Overall Test Article Architecture .................................................................................... 3 
2-2. Overall FPU Architecture................................................................................................ 4 
2-3. Supported Operations and Major Datapath Components ................................................ 6 
2-4. Instruction issue rate (latency and throughput) ............................................................... 6 
</P><P>3. Floating-Point Number Representation (Single Precision Â± 32bit) ............................................ 8 
3-1. Floating-point number ..................................................................................................... 8 
3-2. Rounding ....................................................................................................................... 11 
3-3. Exceptions ..................................................................................................................... 12 
</P><P>4. Instructions................................................................................................................................ 14 
4-1. Addition/Subtraction ..................................................................................................... 14 
4-2. Absolute Value/Negation .............................................................................................. 18 
4-3. Float-to-Integer.............................................................................................................. 21 
4-4. Integer-to-Float.............................................................................................................. 24 
4-5. Multiplication ................................................................................................................ 27 
4-6. Division ......................................................................................................................... 30 
</P><P>5. Test Article Pinout .................................................................................................................... 37 
</P><P>6. Timing Information................................................................................................................... 38 
</P><P>7. Physical Chip Dimensions and Core Locations........................................................................ 40 
</P></Sect><Sect><H3>1. Introduction </H3><P>This document represents the overall architecture of a test article designed at University of Southern California Information Sciences Institute. The test article contains four variants of a single-precision floating-point unit. First, an overview and block diagram are given for both the test article and floating-point unit. Then, floating-point number representation and algorithms used for each instruction are discussed. The FPU architecture including instruction latency and throughput is then presented. Finally, chip pinout and timing information is provided. </P><P>This FPU implements a subset of the functionality specified in the IEEE-754 floating-point standard. Only single-precision numbers are supported and the only supported rounding mode is Â³round to nearest even if tieÂ´. This implementation does not support denormalized inputs; thus, it is not fully IEEE-754 compliant with respect to gradual underflow. Similarly, the implementation of the inexact exception generation for the division operation is not fully IEEE754 compliant. </P></Sect><Sect><H3>2. Test Article and Floating-Point Unit Overview 2-1. Overall Test Article Architecture </H3><P>This test article contains four variants of a single-precision floating-point unit (FPU). The four FPU variants are connected together very simply by connecting all FPU inputs together and multiplexing FPU outputs. Therefore, the test article chip signals are identical to the signals required for each FPU, with the addition of two select bits for multiplexing between the outputs of the four FPU variants.  A depiction of the test article organization is shown below. </P><P>clk, resetn, opcode[2:0], </P><P>A[31:0], B[31:0], en, </P><P>en_input, start_div </P><P>sel[1] sel[0] </P><P>Test Article Inputs/Outputs </P><Figure><ImageData src="images/TA0_datasheet_revD_img_0.jpg"/>FPUA R[31:0], D0, IV, IX, OV, UD FPUB FPUC FPUD </Figure><P>Â‡ Inputs </P><P>Â± sel[1:0] : 2-bit selector for FPU output multiplexer </P><P>Â± opcode[2:0] : 3-bit opcode input for 8 operations </P><P>Â± clk : Clock signal </P><P>Â± resetn : Active-low synchronous reset signal </P><P>Â± en_input : Pipeline enable signal for FPU inputs </P><P>Â± en  : Pipeline enable signal </P><P>Â± A[31;0], B[31:0] : Operand A and Operand B </P><P>(MSB = A[31], B[31]) </P><P>Â± start_div : Start signal for division operation </P><P>Â‡ Outputs </P><P>Â± R[31:0] : FPU result output </P><P>(MSB = R[31]) </P><P>Â± D0 : Divide_By_Zero exception flag </P><P>Â± IV : Invalid exception flag </P><P>Â± IX : Inexact exception flag </P><P>Â± OV : Overflow exception flag </P><P>Â± UD : Underflow exception flag </P><P>Given that the test article simply consists of four variants of the same FPU architecture, the majority of the remainder of this document focuses on the FPU design. </P><Sect><H4>2-2. Overall FPU Architecture </H4><P>The FPU has a 5-stage pipelined architecture with a 2-stage pipelined multiplier for an optimized area-performance result. The overall block diagram is presented below. </P><P>clk, resetn opcode[2:0] A[31:0] B[31:0] start_div en_input </P><Figure><ImageData src="images/TA0_datasheet_revD_img_1.jpg"/>Stage1:OperandFormatterOperandSwapROMAccessenStage2:ExponentDifferenceÄºFractionAlignmentMultiplier(stage1)Stage3:FractionAdd/SubÄºLeadingZeroDetectMultiplier(stage2)Stage4:FractionNormalizationÄºRoundingStage5:ResultFormatterSquare/CubeUnit</Figure><Table><TR><TH>R[31:0] </TH><TH>D0 </TH><TH>IV </TH><TH>IX </TH><TH>OV </TH><TH>UD </TH></TR><TR><TH>FPU inputs/outputs </TH><TD/></TR><TR><TH>Â‡ </TH><TD>Inputs </TD><TD/><TD/></TR><TR><TH/><TD>Â± </TD><TD>opcode[2:0] </TD><TD>: 3-bit opcode input for 8 operations </TD></TR><TR><TH/><TD>Â± </TD><TD>clk </TD><TD>: Clock signal </TD></TR><TR><TH/><TD>Â± </TD><TD>resetn </TD><TD>: active-low synchronous reset signal </TD></TR><TR><TH/><TD>Â± </TD><TD>en_input </TD><TD>: Pipeline enable signal for FPU inputs </TD></TR><TR><TH/><TD>Â± </TD><TD>en  </TD><TD>: Pipeline enable signal </TD></TR><TR><TH/><TD>Â± </TD><TD>A[31;0], B[31:0] </TD><TD>: Operand A and Operand B </TD></TR><TR><TH/><TD>(MSB = A[31], B[31]) </TD></TR><TR><TH>Â± </TH><TD>start_div </TD><TD>: Start signal for division operation </TD></TR><TR><TH>Â‡ </TH><TD>Outputs </TD><TD/></TR></Table><Table><TR><TH>Â± </TH><TD>R[31:0] </TD><TD>: FPU result output </TD></TR><TR><TH/><TD/><TD>(MSB = R[31]) </TD></TR><TR><TH>Â± </TH><TD>D0 </TD><TD>: Divide_By_Zero exception flag </TD></TR><TR><TH>Â± </TH><TD>IV </TD><TD>: Invalid exception flag </TD></TR><TR><TH>Â± </TH><TD>IX </TD><TD>: Inexact exception flag </TD></TR><TR><TH>Â± </TH><TD>OV </TD><TD>: Overflow exception flag </TD></TR><TR><TH>Â± </TH><TD>UD </TD><TD>: Underflow exception flag </TD></TR></Table></Sect><Sect><H4>2-3. Supported Operations and Major Datapath Components</H4><P> The ISI FPU implementation supports 8 instructions, and these instructions are encoded with 3bit binary numbers: opcode[2:0] </P><P>OP_ADD (Addition) : 000 OP_SUB (Subtraction) : 001 OP_F2I (Float-to-Integer) : 010 OP_I2F (Integer-to-Float) : 011 OP_NEG (Negation) : 100 OP_ABS (Absolute) : 101 OP_MUL (Multiplication) : 110 OP_DIV (Division) : 111 </P><P>The major datapath components used in the FPU are listed below: </P><P>Â± Adder : 9-bit x 2, 32-bit, 34-bit Â± Incrementer : 9-bit, 34-bit Â± Multiplier : 33-bit by 26-bit (2-stage) Â± Shifter : Left (32-bit), Right (32-bit) Â± Comparator : 31-bit, 5-bit Â± Counter : 3-bit Â± Special components: </P><P>Operand formatters, Operand status checker, Stage controllers, RSA (right shift amount) generator, Leading-zero detector, Sticky-bit generators, Rounding logic, Squaring unit, Cubing unit, Accumulator, Exception generator, Result formatter, ROM (128 by 7-bit) </P><P>Â± Other components: pipeline registers, muxes </P></Sect><Sect><H4>2-4. Instruction issue rate (latency and throughput) </H4><P>(1) Division: non-linear pipeline </P><P>The latency of the division instruction is 12 clock cycles, but another division instruction can be issued every 5 clock cycles after the previous division instruction. If the next instruction immediately subsequent to a division instruction is not a division operation, the external </P><P>scheduler must wait 8 cycles to issue that instruction. The division instruction requires an extra 
signal, start_div, to initiate the division process called. For more information, refer to section 4-6. 
</P><Table><TR><TH>1 </TH><TD>2 </TD><TD>3 </TD><TD>4 </TD><TD>5 </TD><TD>6 </TD><TD>7 </TD><TD>8 B </TD><TD>9 </TD><TD>10 </TD><TD>11 </TD><TD>12 </TD></TR><TR><TH>S1 </TH></TR><TR><TH/><TD>S2 </TD><TD>S2 </TD><TD>S2 </TD><TD>S2 </TD></TR><TR><TD/><TD>S3 </TD><TD>S3 </TD><TD><Figure><ImageData src="images/TA0_datasheet_revD_img_2.jpg"/></Figure></TD><TD>S3 </TD><TD><Figure><ImageData src="images/TA0_datasheet_revD_img_3.jpg"/></Figure></TD><TD>S3 </TD></TR><TR><TD/><TD>S4 </TD><TD>S4 </TD><TD/><TD>S4 </TD><TD/><TD>S4 </TD></TR><TR><TD/><TD>AX </TD><TD/><TD>Qt </TD></TR><TR><TD/><TD>S5 </TD><TD/><TD/><TD>S5 </TD></TR><TR><TD/><TD/></TR></Table><P>[ Pipeline diagram of OP_DIV ] </P><P>OP_DIV OP_DIV OP_DIV OP_DIV 5 cycles </P><P><Figure><ImageData src="images/TA0_datasheet_revD_img_4.jpg"/></Figure>5 cycles </P><P><Figure><ImageData src="images/TA0_datasheet_revD_img_5.jpg"/></Figure>5 cycles </P><Figure><ImageData src="images/TA0_datasheet_revD_img_6.jpg"/></Figure><Figure><ImageData src="images/TA0_datasheet_revD_img_7.jpg"/></Figure><Figure><ImageData src="images/TA0_datasheet_revD_img_8.jpg"/></Figure><P>[ Example of consecutive division instruction ] </P><P>(2) Instructions other than division</P><P> For all instructions other than division, processing occurs in a linear pipeline fashion. Thus the latency is 5 clock cycles and an instruction can be issued at every clock cycle. </P><Table><TR><TH>1 </TH><TD>2 </TD><TD>3 </TD><TD>4 </TD><TD>5 </TD></TR><TR><TH>S1 </TH></TR><TR><TH/><TD>S2 </TD></TR><TR><TD/><TD>S3 </TD></TR><TR><TD/><TD>S4 </TD></TR><TR><TD/><TD>S5 </TD></TR><TR><TD/></TR></Table><P>[ Pipeline diagram of other instructions ] </P><P>MUL DIV DIV DIV ADD SUB </P><Figure><ImageData src="images/TA0_datasheet_revD_img_9.jpg"/>5cycles8cycles5cycles</Figure><P>[ Example of mixed instruction stream] </P></Sect></Sect><Sect><H3>3. Floating-Point Number Representation (Single Precision Â± 32bit) </H3><Sect><H4>3-1. Floating-point number </H4><P>The designer of a floating-point representation must find a compromise between size of the fraction and the size of the exponent because a fixed word size means you must take a bit from one to add a bit to the other. This trade-off is between accuracy and range: increasing the size of fraction enhances the accuracy of the fraction, while increasing the size of the exponent increases the range of numbers that can be represented. The data format of a single-precision floating-point number as described in the IEEE-754 standard is presented below. </P><P>S (EXP-127) </P><P>(-1)Ã— 2Ã— (1.FRAC) </P><P>3130 2322 0</P><Figure><ImageData src="images/TA0_datasheet_revD_img_10.jpg"/>S EXP FRAC </Figure><P> The IEEE-754 standard uses a sign-magnitude representation. </P><P>x S : Sign bit (1 bit) 
1 = negative 
0 = positive 
</P><P>x EXP : Exponent (8 bit) is biased by 127 </P><P>Biased representation: 
Since the exponent can be positive or negative, some method must be chosen to represent 
</P><P>LWV VLJQ 7KH ,((( VWDQGDUG GRHV QRW XVH HLWKHU VLJQPDJQLWXGH PHWKRG RU WZRÂ¶V </P><P>complement method, but instead uses a biased representation. In the case of single precision, where the exponent is stored in 8 bits, the bias is 127. What this means is that if e is the value of the exponent bits interpreted as an unsigned integer, then the exponent of the floating-point number is e Â± 127. Referring to the table below, single precision has emax = 127, emin = -126. The reason for having |emin| &lt; emax is so that the reciprocal of the </P><P>1 </P><P>smallest number ( ) will not overflow. Although it is true that the reciprocal of the </P><P>e min </P><P>2 largest number will underflow, underflow is usually less serious than overflow. </P><P>x FRAC : Fraction (23 bit) Â± also called as mantissa or significand </P><P>In the case of normalized floating-point numbers, the most significant bit of the fraction is always 1, and there is no reason to waste a bit of storage representing it. Formats that use this trick are said to have a Â³KLGGHQÂ´ELWSo the fraction is 24 bits, even though it is encoded using 23 bits. Therefore a leading 1 is implicit if the data is a normalized number)UDF [[[[Â«[[[[. </P><Table><TR><TD><Figure><ImageData src="images/TA0_datasheet_revD_img_11.jpg"/></Figure></TD><TD/></TR><TR><TD>Normalized Number </TD><TD>(-1)S Ã— 2(Exp-127) Ã— (1.Frac) </TD></TR><TR><TD>Denormalized Number </TD><TD>(-1)S Ã— 2(Exp-126) Ã— (0.Frac) </TD></TR><TR><TD>Positive Zero </TD><TD>S = 0, Exp = 0, Frac = 0 </TD></TR><TR><TD>Negative Zero </TD><TD>S = 1, Exp = 0, Frac = 0 </TD></TR><TR><TD>Signaling NaN ( Not a Number) </TD><TD>S = u, Exp = 2)UDFÂ)UDF06% 0 </TD></TR><TR><TD>Quiet NaN </TD><TD>6 X([S )UDFÂ)UDF06% 1 </TD></TR><TR><TD>Positive Infinity </TD><TD>S = 0, Exp = 255, Frac = 0 </TD></TR><TR><TD>Negative Infinity </TD><TD>S = 1, Exp = 255, Frac = 0 </TD></TR></Table><P>Denomalized FP </P><P>Â± max Â± Normalized FP </P><P><Figure><ImageData src="images/TA0_datasheet_revD_img_12.jpg"/></Figure>+ Nomalized FP max</P><P>Â±0</P><P>Â±Â’ </P><P><Figure><ImageData src="images/TA0_datasheet_revD_img_13.jpg"/></Figure>+Â’ </P><Figure><ImageData src="images/TA0_datasheet_revD_img_14.jpg"/>. . . . . . . . . . . . DenserSparser Denser Sparser </Figure><P>Overflow Underflow Overflow </P><P>[ IEEE-754 floating-point data formats ] </P><P>(1) Normalized numbers </P><P>Real numbers in the following range can be represented as normalized single-precision numbers: </P><P>2-126 Ã®Â«Â”|n| Â”127 Ã®Â« </P><P>(2) Zeros </P><P>Since the sign bit can take on two different values, there are two distinct zeros, +0 and -0. </P><P>The IEEE standard defines comparison so that -0 = +0, rather than -0 &lt; +0. When a </P><P>multiplication or division involves a signed zero, the usual sign rules apply in computing </P><P>the sign of the answer. Another example of the use of signed zero concerns underflow </P><P>and functions that have a discontinuity at 0. Although distinguishing between +0 and -0 </P><P>has advantages, it can occasionally be confusing. For example, signed zero destroys the </P><P>UHODWLRQ[ \Ä¼[ \ZKLFKLVIDOVHZKHQ[ DQG\ -[ Â’\ -Â’ </P><P>However, the IEEE committee decided that the advantages of utilizing the sign of zero </P><P>outweighed the disadvantages. </P><P>(3) NaN (Not a Number) </P><P>NaNs are the result of any invalid operation. Using NaNs allows a compiler to schedule instructions speculatively, and only at the end of a chain of computations check the validity of the result. Traditionally, the computation of 0/0 or </P><L><L><LI><Figure><ImageData src="images/TA0_datasheet_revD_img_15.jpg"/></Figure><LI_Label>1</LI_Label><LI_Title> has been treated as an unrecoverable error which causes a computation to halt. This problem can be avoided by introducing a special value called NaN, and specifying that the computation of </LI_Title></LI><LI>expressions like 0/0 and </LI></L><LI><LI_Label>1 </LI_Label><LI_Title>produce NaN, rather than halting. Implementations are free to put system-dependent information into the fraction field of NaN values; thus, there is not a unique NaN, but rather a whole family of NaNs. Any operation on a quiet NaN does not, in general, cause an exception. An operation on a signaling NaN causes an exception. Additionally, when one or both input operands is a NaN (either quiet or signaling), the FPU sets the result to 0x7FFF0000 (a quiet NaN value). </LI_Title></LI></L><Figure><ImageData src="images/TA0_datasheet_revD_img_16.jpg"/></Figure><P>(4) Infinity </P><P>Just as NaNs provide a way to continue a computation when expressions like 0/0 or </P><P><Figure><ImageData src="images/TA0_datasheet_revD_img_17.jpg"/></Figure>1 are encountered, infinities provide a way to continue when an overflow occurs. This is much safer than simply returning the largest representable number. You can distinguish between gettLQJÂ’EHFDXVHRIRYHUIORZDQGJHWWLQJÂ’EHFDXVHRIGLYLVLRQE\]HURE\ checking the exception flags. </P><P>(5) Denormalized numbers </P><P>Denormalized numbers are too small to be represented in the normalized format and allow underflowing calculations to proceed with limited precision. </P><P>The IEEE standard uses denormalized numbers. They are the most controversial part of the standard and probably accounted for the long delay in the approval of the IEEE-754 standard. Most high performance hardware that claims to be IEEE compatible does not support denormalized numbers directly, but rather traps when consuming or producing denormals, and leaves it to software to simulate the IEEE standard. </P><P>The range of real numbers that can be represented as denormalized single precision numbers is: </P><P>2-126 Ã®Â«Â”|n| Â”-126 Ã®Â« </P></Sect><Sect><H4>3-2. Rounding</H4><P> Squeezing infinitely many real numbers into a finite number of bits requires an approximate representation. The result of a floating-point calculation must often be rounded in order to fit back into its finite representation. IEEE-754 operations are specified to produce a result as if carried to infinite precision and then rounded according to one of four rounding modes. (Round WRZDUGÂ’5RXQGWRZDUG-Â’5RXQGWRZDUG5RXnd to nearest even if tie)</P><P> Provided there is no overflow, underflow, or invalid operation exceptions, IEEE-754 standard guarantees that the computed result is within Â½ulp. The only supported rounding mode in the ISI FPU design LVÂ³5RXQGWRQHDUHVWHYHQLI WLHÂ´ </P><P>x 	G(Guard), R(Round), S(Sticky) Â± 3 redundant bits are used to get Â½ ulp (units in the last place) error between real result and computed result </P><P>x 	Round to nearest (even if tie): :KHQWKHUHVXOWLVLQÂ³KDOIZD\Â´EHWZHHQWZRIORDWLQJ-point numbers (GRS = 100), round up only if result becomes even number; otherwise, round down (In decimal, 10.5 becomes 10, but 11.5 becomes 12). </P><Table><TR><TH>L </TH><TH>G </TH><TH>R </TH><TH>S </TH><TH>Roundup </TH><TH>L </TH><TH>G </TH><TH>R </TH><TH>S </TH><TH>Roundup </TH></TR><TR><TH>0 </TH><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>1 </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD></TR><TR><TH>0 </TH><TD>0 </TD><TD>0 </TD><TD>1 </TD><TD>0 </TD><TD>1 </TD><TD>0 </TD><TD>0 </TD><TD>1 </TD><TD>0 </TD></TR><TR><TH>0 </TH><TD>0 </TD><TD>1 </TD><TD>0 </TD><TD>0 </TD><TD>1 </TD><TD>0 </TD><TD>1 </TD><TD>0 </TD><TD>0 </TD></TR><TR><TH>0 </TH><TD>0 </TD><TD>1 </TD><TD>1 </TD><TD>0 </TD><TD>1 </TD><TD>0 </TD><TD>1 </TD><TD>1 </TD><TD>0 </TD></TR><TR><TH>0 </TH><TD>1 </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>1 </TD><TD>1 </TD><TD>0 </TD><TD>0 </TD><TD>1 </TD></TR><TR><TH>0 </TH><TD>1 </TD><TD>0 </TD><TD>1 </TD><TD>1 </TD><TD>1 </TD><TD>1 </TD><TD>0 </TD><TD>1 </TD><TD>1 </TD></TR><TR><TH>0 </TH><TD>1 </TD><TD>1 </TD><TD>0 </TD><TD>1 </TD><TD>1 </TD><TD>1 </TD><TD>1 </TD><TD>0 </TD><TD>1 </TD></TR><TR><TH>0 </TH><TD>1 </TD><TD>1 </TD><TD>1 </TD><TD>1 </TD><TD>1 </TD><TD>1 </TD><TD>1 </TD><TD>1 </TD><TD>1 </TD></TR></Table><P>&gt;7UXWKWDEOHRIÂ³5RXQGWRQHDUHVWHYHQLIWLH@ </P><P>*Roundup = LG + GR + GS = G(L + R + S) </P></Sect><Sect><H4>3-3. Exceptions </H4><P>When an exception condition occurs in IEEE arithmetic, the default is to deliver a result and continue, but exception flags will also be set. The IEEE standard divides exceptions into 5 classes and there is a separate status flag for each class of exception. </P><P>x Overflow : </P><P>The overflow exception is raised when the exponent is too large to be represented in the 
exponent field. 
When the | result | &gt; 2127 Ã®Â« (the largest normalized number), then set result 
to Â±Â’ 
</P><P>x Underflow : </P><P>The underflow exception is raised when the result is too small to be represented in the normalized form. In other words, when the nonzero fraction is so small that it cannot be represented (the negative exponent is too large to fit in the exponent field), the underflow exception is raised. When the | result | &lt; 2-126 Ã®Â« (the smallest denormalized number), then set result to Â±0. Addition/Subtraction operations do not produce underflow exceptions in IEEE-754. </P><P>o Gradual underflow (when the computed result is a denormalized number) : </P><P>Recall that to simplify the implementation, the ISI FPU does not support denormalized operands. When gradual underflow occurs, i.e., | result | is less than the minimum normalized number but greater than or equal to the minimum denormalized number, the ISI FPU design sets the output to the minimum normalized number (Â·2</P><Table><TR><TH>126 Ã® Â« = x00800000 Â³UQGHUIORZÂ´DQGÂ³IQH[DFWÂ´H[FHSWLRQs. </TH><TH>or </TH><TH>x80800000) </TH><TH>and </TH><TH>also </TH><TH>raises </TH><TH>both </TH><TH>the </TH></TR><TR><TH>x </TH><TD>Inexact : </TD></TR><TR><TH/><TD>The inexact exception is raised when the result of a floating-point operation is not exact. This is easy to detect by checking G, R and S bits. GRS = 000 : the result is exact GRS != 000 : the result involves rounding, therefore inexact </TD></TR><TR><TH>x </TH><TD>Divide by Zero : </TD></TR><TR><TH/><TD>The divide by zero exception is raised when the operation A/B, B=0 and A!=0 occurs. </TD></TR><TR><TH>x </TH><TD>Invalid : </TD></TR><TR><TH/><TD>Any operation on a signaling NaN (sNaN), Â’Â·Â’ Ã®(Â·Â’), 0/0, (Â·Â’)/(Â·Â’) and comparison that involves a NaN will cause an invalid exception. The default result of these operations is qNaN (specifically, 0x7FFF0000). </TD></TR></Table></Sect></Sect><Sect><H3>4. Instructions 
</H3><Sect><H4>4-1. Addition/Subtraction 
</H4><P>oprA[31:0] oprB[31:0] </P><P>Operand 
Selection 
</P><P>Fraction 
Alignment 
</P><P>Fraction 
Calculation 
</P><P>Exponent 
Adjustment 
</P><P>Fraction 
Normalization 
</P><P>Rounding </P><Figure><ImageData src="images/TA0_datasheet_revD_img_18.jpg"/>OperandFormatterAlignmentshifterFracAdderExpAExpBFracAFracBExpGExpLFracGFracLË…ExpG-ExpLFracGFracL|oprA|&gt;|oprB|ComparatorExpAdderLeadingZeroNomalizationshifterAdder(+1)FracZË…FracZË…Ë…Adder(+1)ResultFormatterFracZExpZË…ExpZResult[31:0]FracZË…Ë…Ë…ExpGExpAdderRoundingLogicStickyRSARSA</Figure><P>[ Basic datapath of OP_ADD and OP_SUB ] Internal format of operands </P><P>Input operands should be reformatted to be suitable for required operations. 
</P><P>373635 28272625 3 2 1 0 </P><Table><TR><TH>Â± </TH><TH>0 </TH><TH>EXP </TH><TH>0 </TH><TH>1 </TH><TH>FRAC </TH><TH>G </TH><TH>R </TH><TH>S </TH></TR></Table><P>x Added bits </P><P>Redundant bit for exponent computation: opr[36] = 0 </P><P>Redundant bit for fraction computation: opr[27] = 0 </P><P>Hidden bit: opr[26] = 1, if input operand is a normalized number, </P><P>otherwise 0                       </P><P>G,R,S bits are added for rounding purpose: opr[2:0] = 000 </P><P>*Z: Output format </P><P>x Sign bit calculation </P><P>Addition If (SignA == SignB), SignZ = SignA If (SignA != SignB), SignZ = (|oprA| &gt; |oprB|) ? SignA : SignB) </P><P>Subtraction If (SignA == SignB), SignZ = ((|oprA| &gt; |oprB|) ? SignA : SignB) If (SignA != SignB), SignZ = SignA </P><P>x Exponent and Fraction calculation </P><P>(1) Operand selection (operand comparison and swap) ExpG = (|oprA| &gt; |oprB|) ? ExpA : ExpB ExpL = (|oprA| &gt; |oprB|) ? ExpB : ExpA FracG = (|oprA| &gt; |oprB|) ? FracA : FracB </P><P>)UDF/Â¶ _RSU$_!_RSU%_&quot;)UDF%)UDF$ </P><P>Required datapath: comparator(31bit), muxes(9bit Ã— 2, 28bit Ã— 2) </P><L><LI><LI_Label>(2) </LI_Label><LI_Title>Fraction alignment right-shift amount calculation RSA = ExpG Â± ExpL </LI_Title></LI><LI><LI_Label>(3) </LI_Label><LI_Title>Fraction alignment (shift the fraction of smaller operand to right) </LI_Title></LI></L><P>Required datapath: subtractor(9bit) </P><P>)UDF/ )UDF/Â¶!!56$ </P><P>Required datapath: right-shifter(28bit), sticky-bit generator </P><P>(4) Fraction calculation </P><P>)UDF=Â¶ )UDF*Â“)UDF/ </P><P>Required datapath: adder/subtractor(28bit) </P><P>(5) Fraction normalization and Exponent adjustment </P><P>)UDF=Â¶Â¶ )UDF=Â¶OHDGLQJ=HUR)UDF=Â¶ </P><P>([S=Â¶ ([S*Â± OHDGLQJ=HUR)UDF=Â¶ </P><P>Required datapath: leading-zero detector, left-shifter(28bit), 
subtractor(9bit) 
</P><P>(6) Rounding )UDF=Â¶Â¶Â¶ URXQGXS &quot;)UDF=Â¶Â¶)UDF=Â¶Â¶ )UDF= 06%)UDF=Â¶Â¶Â¶ Â³Â´&quot;)UDF=Â¶Â¶Â¶!!)UDF=Â¶Â¶Â¶ ExpZ = (MSB)UDF=Â¶Â¶Â¶ Â³Â´&quot;([S=Â¶([S=Â¶ </P><P>Required datapath: rounding logic, incrementer(25bit, 9bit), mux </P><P>(7) Output formatting and Exception generation </P><P>Exceptions </P><P>These cases do not raise exceptions, but result should be set to special value. When either one of inputs is qNaN, set result to qNaN (specifically, 0x7FFF0000). :KHQHLWKHUÂ’Â“1RUPVHWUHVXOWWRÂ’ </P><L><L><LI><LI_Label>(1) </LI_Label><LI_Title>Invalid IV = 1 when Â’-Â’-Â’Â’Â’-Â’-Â’-(-Â’, </LI_Title></LI><LI> set result to qNaN (specifically, 0x7FFF0000). IV = 1 when either one of inputs is sNaN, set result to qNaN (specifically, 0x7FFF0000). IV = 0 when either one of inputs is qNaN, set result to qNaN (specifically, 0x7FFF0000). Otherwise IV = 0. </LI></L><LI><LI_Label>(2) </LI_Label><LI_Title>Overflow OV = 1 when ExpZ Â• 255, set result to Â’. Otherwise OV = 0. </LI_Title></LI><LI><LI_Label>(3) </LI_Label><LI_Title>Divide by Zero D0 = 0. </LI_Title></LI><L><LI><LI_Label>(4) </LI_Label><LI_Title>Underflow Â± underflow in Addition/Subtraction operation actually means that</LI_Title></LI><LI>       the result is a denormalized number UD = 1 when ExpG Â” Leading Zero, set result to the smallest normalized number Otherwise UD = 0. </LI></L><LI><LI_Label>(5) </LI_Label><LI_Title>Inexact </LI_Title></LI></L><P>IX = 1 when OV = 1, 
IX = 1 when  the result is a denormalized number. 
IX = 1 when GRS != 000. 
Otherwise IX = 0. 
</P></Sect><Sect><H4>4-2. Absolute Value/Negation </H4><P>oprA[31:0] No input </P><P>No swap </P><P>Fraction Alignment </P><P>FracA + 0 </P><P>Set leading-zero to 0 </P><P>No 
Normalization 
Shift 
</P><P>No Rounding </P><Figure><ImageData src="images/TA0_datasheet_revD_img_19.jpg"/>OperandFormatterAlignmentshifterFracAdderExpA0FracA0ExpA0FracA0ExpG-ExpLFracA0ComparatorExpAdderLeadingZeroNomalizationshifterAdder(+1)FracAFracAAdder(+1)ResultFormatterFracAExpAExpAResult[31:0]FracAExpAExpAdderRoundingLogicStickyRSARSA0</Figure><P>[ Basic datapath of OP_ABS and OP_NEG ] 
</P><P>Internal format of operands Â± input is oprA. 
</P><P>The same datapath is used as in two-operand operations, with the internal format of oprB initialized with an appropriate value even though there is no input. </P><P>oprA </P><P>373635 28272625 3 2 1 0 </P><Table><TR><TH>Â± </TH><TH>0 </TH><TH>EXP </TH><TH>0 </TH><TH>1 </TH><TH>FRAC </TH><TH>G </TH><TH>R </TH><TH>S </TH></TR></Table><P>oprB </P><P>3736 2827 3210 </P><Table><TR><TH>0 </TH><TH>Zero </TH><TH>Zero </TH><TH>0 </TH><TH>0 </TH><TH>0 </TH></TR></Table><P>x Added bits </P><P>Hidden bit: oprA[26] = 1, if input operand is a normalized number, otherwise 0                       G,R,S bits are initialized with = 000 </P><P>x Sign bit calculation </P><P>Absolute Value 
SignZ = 0 (set it to positive) 
</P><P>Negation 
SignZ = ~SignA 
</P><P>x Exponent and Fraction calculation </P><L><LI><LI_Label>(1) </LI_Label><LI_Title>Operand selection (operand comparison and swap) Â± No swap. ExpG = ExpA ExpL= 0 FracG = FracA )UDF/Â¶ 0 </LI_Title></LI><LI><LI_Label>(2) </LI_Label><LI_Title>Fraction alignment right-shift amount calculation RSA = ExpG Â± ExpL = ExpA Â± 0 = ExpA </LI_Title></LI><LI><LI_Label>(3) </LI_Label><LI_Title>Fraction alignment (shift the fraction of smaller operand to right) )UDF/ )UDF/Â¶!!56$ = (0 &gt;&gt; ExpA) = 0 </LI_Title></LI><LI><LI_Label>(4) </LI_Label><LI_Title>Fraction calculation )UDF=Â¶ FracG + 0 = FracA </LI_Title></LI><LI><LI_Label>(5) </LI_Label><LI_Title>Fraction normalization and Exponent adjustment </LI_Title></LI></L><P>)UDF=Â¶Â¶ )UDF=Â¶OHDGLQJ=HUR)UDF=Â¶ )UDF=Â¶ )UDF$ ([S=Â¶ ([S*Â± OHDGLQJ=HUR)UDF=Â¶ = ExpG Â± 0 = ExpA </P><L><LI><LI_Label>(6) </LI_Label><LI_Title>Rounding because GRS = 000, there is no rounding. FracZ = FracA ExpZ = ExpA </LI_Title></LI><L><LI><LI_Label>(7) </LI_Label><LI_Title>Output formatting and Exception generation </LI_Title></LI><LI>Exceptions Â± there are no exceptions for Absolute Value/Negation operations. </LI></L><LI><LI_Label>(1) </LI_Label><LI_Title>Invalid IV =0. </LI_Title></LI><LI><LI_Label>(2) </LI_Label><LI_Title>Overflow OV = 0. </LI_Title></LI><LI><LI_Label>(3) </LI_Label><LI_Title>Divide by Zero D0 = 0. </LI_Title></LI><LI><LI_Label>(4) </LI_Label><LI_Title>Underflow UD = 0. </LI_Title></LI><LI><LI_Label>(5) </LI_Label><LI_Title>Inexact IX =0. </LI_Title></LI></L></Sect><Sect><H4>4-3. Float-to-Integer </H4><P>oprA[31:0] No input </P><P>Operand Swap </P><P>Fraction Alignment </P><P>Fraction Calculation </P><P>Set leading-zero 
to 0 
</P><P>No 
Normalization 
Shift 
</P><P>No Rounding </P><Figure><ImageData src="images/TA0_datasheet_revD_img_20.jpg"/>OperandFormatterAlignmentshifterFracAdderExpA157FracA0157ExpA0FracA157-ExpA0FracLComparatorExpAdderLeadingZeroNomalizationshifterAdder(+1)FracZË…FracZË…Adder(+1)ResultFormatterFracZ157157Result[31:0]FracZË…157ExpAdderRoundingLogicStickyRSARSA00</Figure><P>[ Basic datapath of OP_F2I ] Internal format of operands Â± input is oprA. </P><P>Fraction field of the internal format is promoted to 32 bits wide in order to support Floatto-Integer operation because data format of integer is 32 bits. Exponent field of oprB is initialized with 157, because RSA = 157 Â± Exp is used to shift FRAC to convert floating-point input to an integer number. </P><P>oprA </P><P>4140	39 32313029 76543210 </P><Table><TR><TH>Â± </TH><TH>0 </TH><TH>EXP </TH><TH>0 </TH><TH>1 </TH><TH>FRAC </TH><TH>G </TH><TH>R </TH><TH>S </TH><TH>0 </TH><TH>0 </TH><TH>0 </TH><TH>0 </TH></TR></Table><P>oprB </P><P>4140 3231 	0 </P><Figure><ImageData src="images/TA0_datasheet_revD_img_21.jpg"/>0 157 Zero </Figure><P>x 	Added bits </P><P>Hidden bit: oprA[26] = 1, if input operand is a normalized number, </P><P>otherwise 0                       
G,R,S bits are initialized with = 000 
oprA[3:0] bits are also initialized to 0000. 
</P><P>x 	Sign bit calculation 
SignZ = SignA 
</P><P>x 	Exponent and Fraction calculation </P><L><LI><LI_Label>(1) </LI_Label><LI_Title>Selection (operand comparison and swap) Â± always swap. ExpG = 157 ExpL = ExpA FracG = 0 )UDF/Â¶ FracA </LI_Title></LI><LI><LI_Label>(2) </LI_Label><LI_Title>Alignment right shift amount calculation RSA = 157 Â± ExpA </LI_Title></LI><L><LI><LI_Label>(3) </LI_Label><LI_Title>Alignment (shift the fraction of smaller operand to right) FracL = (FracA &gt;&gt; RSA) </LI_Title></LI><LI>Changes in datapath: right-VKLIWHUELWÄºELW </LI></L><LI><LI_Label>(4) </LI_Label><LI_Title>Fraction calculation A Â¶VFRPSOHPHQWFDOFXODWLRQis performed when the input is a negative floating-point number. If (SignA == 0))UDF=Â¶ FracL + 0 If (SignA == 1))UDF=Â¶ (~FracL) + 1 </LI_Title></LI></L><P>&amp;KDQJHVLQGDWDSDWKDGGHUVXEWUDFWRUELWÄºELW </P><P>(5) Fraction normalization and Exponent adjustment Set leading-zero to 0 )UDF=Â¶Â¶ )UDF=Â¶OHDGLQJ=HUR)UDF=Â¶ )UDF=Â¶ ([S=Â¶ ([S*Â± OHDGLQJ=HUR)UDF=Â¶ 157 Â± 0 = 157 </P><L><LI><LI_Label>(6) </LI_Label><LI_Title>Rounding there is no rounding for OP_F2I.. FracZ = Frac=Â¶Â¶ ExpZ = 157 </LI_Title></LI><L><LI><LI_Label>(7) </LI_Label><LI_Title>Output formatting and Exception generation R [30:0] = FracZ[30:0] </LI_Title></LI><LI>Exceptions </LI></L><LI><LI_Label>(1) </LI_Label><LI_Title>Invalid IV = 1 when input is too large to be represented as an integer. Otherwise IV = 0 When IV = 1 and 6LJQ$ VHWUHVXOWWRÂ’LQWHJHU </LI_Title></LI><LI><LI_Label>(2) </LI_Label><LI_Title>Overflow OV = 0. </LI_Title></LI><LI><LI_Label>(3) </LI_Label><LI_Title>Divide by Zero D0 = 0. </LI_Title></LI><LI><LI_Label>(4) </LI_Label><LI_Title>Underflow UD = 0. </LI_Title></LI><LI><LI_Label>(5) </LI_Label><LI_Title>Inexact IX = 1 when there are any ones in the fraction field which are right-shifted out. </LI_Title></LI></L></Sect><Sect><H4>4-4. Integer-to-Float 
</H4><P>oprA[31:0] No input </P><P>Operand Swap </P><P>No 
Alignment 
Shift 
</P><P>Fraction 
Calculation 
</P><P>Exponent 
Caculation 
</P><P>Fraction 
Normalization 
</P><P>Rounding </P><Figure><ImageData src="images/TA0_datasheet_revD_img_22.jpg"/>OperandFormatterAlignmentshifterFracAdder0157Integer015700Integer1570IntegerComparatorExpAdderLeadingZeroNomalizationshifterAdder(+1)FracZË…FracZË…Ë…Adder(+1)ResultFormatterFracZExpZË…ExpZResult[31:0]FracZË…Ë…Ë…157ExpAdderRoundingLogicStickyRSA0</Figure><P>[ Basic datapath of OP_I2F ] 
</P><P>Internal format of operands Â± input is oprA. 
</P><P>Fraction field of the internal format is changed to 32bit wide in order to support Integer-
to-Float because data format of integer is 32bit. 
Exponent field of oprB should be initialized with 157 because, 
157 minus the exponent of the position of the leading-zero will be the exponent of the 
result. 
</P><P>oprA </P><P>4140 3231 	0 </P><Figure><ImageData src="images/TA0_datasheet_revD_img_23.jpg"/>S Zero Integer </Figure><P>oprB </P><P>4140 3231 	0 </P><Figure><ImageData src="images/TA0_datasheet_revD_img_24.jpg"/>0 157 Zero </Figure><P>x 	Added bits 
oprA[41] is initialized with the sign of integer. 
</P><P>x 	Sign bit calculation 
SignZ = SignA 
</P><P>x 	Exponent and Fraction calculation </P><L><LI><LI_Label>(1) </LI_Label><LI_Title>Selection (operand comparison and swap) Â± always swap. ExpG = 157 ExpL= 0 FracG = 0 )UDF/Â¶ integer input </LI_Title></LI><LI><LI_Label>(2) </LI_Label><LI_Title>Alignment right shift amount calculation RSA = 157 Â± 0 = 157 </LI_Title></LI><LI><LI_Label>(3) </LI_Label><LI_Title>Alignment (shift the fraction of smaller operand to right) Set RSA to 0 FracL = (Frac/Â¶ &gt;&gt; RSA) )UDF/Â¶ </LI_Title></LI><LI><LI_Label>(4) </LI_Label><LI_Title>Fraction calculation A Â¶VFRPSOHPHQWFDOFXODWLRQis performed when the input is a negative integer number. If (SignA == 0))UDF=Â¶ FracL + 0 If (SignA == 1))UDF=Â¶ (~FracL) + 1 </LI_Title></LI><LI><LI_Label>(5) </LI_Label><LI_Title>Fraction normalization and Exponent adjustment </LI_Title></LI></L><P>)UDF=Â¶Â¶ )UDF=Â¶OHDGLQJ=HUR)UDF=Â¶&#12; 
([S=Â¶ ([S*Â± OHDGLQJ=HUR)UDF=Â¶&#12; 
</P><P>(6) Rounding </P><P>)UDF=Â¶Â¶Â¶ URXQGXS &quot;)UDF=Â¶Â¶)UDF=Â¶Â¶ </P><P>)UDF= 06%)UDF=Â¶Â¶Â¶ Â³Â´&quot;)UDF=Â¶Â¶Â¶!!)UDF=Â¶Â¶Â¶ 
([S= 06%)UDF=Â¶Â¶Â¶ Â³Â´&quot;([S=Â¶([S=Â¶ 
</P><L><L><LI><LI_Label>(7) </LI_Label><LI_Title>Output formatting and Exception generation </LI_Title></LI><LI>Exceptions Â± because data format of integer(32bit) is larger than the fraction field of floating-point(24bit), there can be an inexact exception. </LI></L><LI><LI_Label>(1) </LI_Label><LI_Title>Invalid IV =0. </LI_Title></LI><LI><LI_Label>(2) </LI_Label><LI_Title>Overflow OV = 0. </LI_Title></LI><LI><LI_Label>(3) </LI_Label><LI_Title>Divide by Zero D0 = 0. </LI_Title></LI><LI><LI_Label>(4) </LI_Label><LI_Title>Underflow UD = 0. </LI_Title></LI><LI><LI_Label>(5) </LI_Label><LI_Title>Inexact IX = 1 when the computed result is not exact. Otherwise IX = 0. </LI_Title></LI></L></Sect><Sect><H4>4-5. Multiplication 
</H4><P>oprA[31:0] oprB[31:0] </P><P>No Swap </P><P>Fraction 
Multiplication 
</P><P>Exponent 
Computation 
</P><P>Rounding </P><Figure><ImageData src="images/TA0_datasheet_revD_img_25.jpg"/>OperandFormatterAdder(+)ExpAExpBFracAFracBExpAExpBFracAFracBComparatorAdder(+1)FracZË…Ë…Adder(+1)ResultFormatterFracZExpZFracMultiplierExpZË…Adder(-127)ExpZË…Ë…FracZË…FracZË…Ë…Ë…RoundingLogicResult[31:0]</Figure><P>[ Basic datapath of OP_MUL ] </P><P>x Internal format of operands </P><P>Required operations for floating-point multiplication are relatively simpler as compared to other instructions. opr </P><P>333231 242322 0 </P><Figure><ImageData src="images/TA0_datasheet_revD_img_26.jpg"/>Â±EXP 10 </Figure><P>FRAC </P><P>Added bits </P><P>Redundant bit for exponent computation: opr[32] = 0 
Hidden bit: opr[23] = 1, if input operand is a normalized number, 
</P><P>otherwise 0 There is no need to add redundant 0 bit to the fraction field. There is no need to add G,R,S bits for multiplication operations. </P><P>x Sign bit calculation </P><P>if (SignA == SignB), SignZ = 0 (positive) 
if (SignA != SignB), SignZ = 1 (negative) 
</P><P>x Exponent and Fraction calculation </P><L><LI><LI_Label>(1) </LI_Label><LI_Title>Operand selection (operand comparison and swap) Â± No swap ExpG = ExpA ExpL = ExpB FracG = FracA FracL = FracB </LI_Title></LI><L><LI><LI_Label>(2) </LI_Label><LI_Title>Exponent computation ExpZÂ¶ ([S$([S% ([S=Â¶Â¶ ([S=Â¶Â± 127 </LI_Title></LI><LI>Required datapath: adder(9bit), decrementer(9bit) </LI></L><LI><LI_Label>(3) </LI_Label><LI_Title>Fraction multiplication </LI_Title></LI></L><P>)UDF=Â¶ )UDF$Ã®)UDF% </P><P>Required datapath: multiplier(24bit Ã— 24bit) </P><L><L><LI><LI_Label>(4) </LI_Label><LI_Title>Sticky bit generation and Rounding decision )UDF=Â¶Â¶ )UDF=Â¶G, R, S </LI_Title></LI><LI>Required datapath: rounding logic, mux </LI></L><LI><LI_Label>(5) </LI_Label><LI_Title>Rounding </LI_Title></LI></L><P>)UDF=Â¶Â¶Â¶ URXQGXS &quot;)UDF=Â¶Â¶)UDF=Â¶Â¶ 
)UDF= 06%)UDF=Â¶Â¶Â¶ Â³Â´&quot;)UDF=Â¶Â¶Â¶!!)UDF=Â¶Â¶Â¶ 
([S= 06%)UDF=Â¶Â¶Â¶ Â³Â´&quot;([S=Â¶Â¶([S=Â¶Â¶ 
</P><P>(6) Output formatting and Exception generation </P><P>Exceptions </P><P>These cases do not raise exceptions, but result should be set to special value. When either one of inputs is qNaN, set result to qNaN (specifically, 0x7FFF0000). :KHQÂ’ Ã— NormVHWUHVXOWWRÂ’ When 0 Ã— Norm, set result to 0. </P><L><LI><LI_Label>(1) </LI_Label><LI_Title>Invalid IV ZKHQÂ’Ã— 0, set result to qNaN (specifically, 0x7FFF0000). IV = 1 when either one of inputs is sNaN, set result to qNaN (specifically, 0x7FFF0000). Otherwise IV = 0. </LI_Title></LI><LI><LI_Label>(2) </LI_Label><LI_Title>Overflow OV = 1 when ExpZ Â• 255VHWUHVXOWWRÂ’ Otherwise OV = 0. </LI_Title></LI><LI><LI_Label>(3) </LI_Label><LI_Title>Divide by Zero D0 = 0. </LI_Title></LI><LI><LI_Label>(4) </LI_Label><LI_Title>Underflow UD = 1 when ExpG Â”Â±24, set result to 0. Otherwise UD = 0. </LI_Title></LI><LI><LI_Label>(5) </LI_Label><LI_Title>Inexact IX = 1 when OV = 1, IX = 1 when GRS != 000. IX = 0 when either one of inputs is NaN. Otherwise IX = 0. </LI_Title></LI></L><P>(6) Denormalized output When Â±Â”([S=Â”VHWUHVXOWWRWKHVPDOOHVWQRUPDOL]HGQXPEHUDQGVHW8' ,; = 1. </P><P>4-6. Division </P></Sect><Sect><H4>4-6-1. Algorithm </H4><P>The most complex datapath component of the division operation is the fraction divider. To calculate a quotient, the core operation of fraction division is computing the reciprocal of the divisor; then the quotient can be obtained by multiplying the reciprocal by the dividend. In order to calculate the reciprocal of the divisor, the ISI FPU implementation uses a binomial expansion algorithm using Taylor series expansion. The equation is </P><P>1 23 </P><P>qa yba u| aX (1 (1 bX )  (1 bX )  (1 bX )) </P><P>b </P><P>where X is the initial approximation of divisor b and is determined by using a ROM as a lookup table. </P><Figure><ImageData src="images/TA0_datasheet_revD_img_27.jpg"/>LUT (X~1/b) (1-bX)2 (1-bX)3 1+sum a 1-bXaX 1+(1-bX)+(1-bX)2+(1-bX)3 1-bX b </Figure><P>a/b=aX(1+(1-bX)+(1-bX)2+(1-bX)3) </P><P>This division algorithm is suitable for a parallel hardware concept since the quotient can be obtained directly without iterations by using parallel powering units such as a squaring unit and a cubing unit, which compute the higher-order terms significantly faster than traditional multipliers with a relatively small hardware overhead. </P><P>oprA[31:0] oprB[31:0] </P><Figure><ImageData src="images/TA0_datasheet_revD_img_28.jpg"/>OperandFormatterAdder(-)ExpAExpBFracAFracBExpAExpBFracAFracBComparatorAdder(+1)Adder(+1)ResultFormatterFracZExpZMultiplierExpZË…Adder(+127)ExpZË…Ë…FracZË…RoundingLogicROMXFracAË…BXAdder(1-BX)1-BX(1-BX)2(1-BX)3AccunulatorXAXSQMultiplierAdder(+1)QtMultiplierFracBQtBQtMultiplier</Figure><P>Result[31:0] </P><P>[ Direct implementation of division algorithm with rounding ] Internal format of operands </P><P>opr </P><P>343332 25242322 0 </P><Table><TR><TH>Â± </TH><TH>0 </TH><TH>EXP </TH><TH>0 </TH><TH>1 </TH><TH>FRAC </TH></TR></Table><P>x Added bits </P><P>Redundant bit for exponent computation: opr[33] = 0 Redundant bit for fraction computation: opr[24] = 0 Hidden bit: opr[23] = 1, if input operand is a normalized number</P><P>  otherwise 0 There is no need to add G,R,S bits for division operations </P><P>x Sign bit calculation </P><P>if (SignA == SignB), SignZ = 0 (positive) 
if (SignA != SignB), SignZ = 1 (negative) 
</P><P>x Exponent calculation </P><P>(1) Exponent computation ExpZÂ¶ = ExpA Â± ExpB ExpZÂ¶Â¶ = ExpZÂ¶ + 127 </P><P>Required datapath: subtractor(9bit), incrementer(9bit) </P><P>(2) Rounding ExpZ = (MSB)UDF=Â¶ Â³Â´&quot;([pZÂ¶Â¶([S=Â¶Â¶ </P><P>Required datapath: incrementer(9bit) </P><P>x Fraction calculation </P><L><L><LI><LI_Label>(1) </LI_Label><LI_Title>ROM access and fraction alignment X = ROM output FracA = (FracA &gt; FracB) ? FracA : FracA &lt;&lt; 1 </LI_Title></LI><LI>Fraction A is adjusted so that quotient is always normalized Required datapath: ROM(128 Ã— 7), mux </LI></L><LI><LI_Label>(2) </LI_Label><LI_Title>Calculate BX BX = FracBÃ— X </LI_Title></LI><L><LI><LI_Label>(3) </LI_Label><LI_Title>Calculate AX and 1 Â± BX AX = FracA Ã— X SC = 1 Â± BX </LI_Title></LI><LI>Required datapath: multiplier(25bit Ã— 8bit), incrementer(32bit) </LI></L><LI><LI_Label>(4) </LI_Label><LI_Title>Square/Cubic terms generation and accumulation </LI_Title></LI></L><P>Required datapath: multiplier(24bit Ã— 8bit) </P><P>23</P><P>S = 1 + SC + SC+ SC
Required datapath: squaring unit, cubing unit, accumulator 
</P><L><L><LI><LI_Label>(5) </LI_Label><LI_Title>Calculate intermediate quotient Q = AX Ã— S </LI_Title></LI><LI>Required datapath: multiplier(33bit Ã— 33bit) </LI></L><L><LI><LI_Label>(6) </LI_Label><LI_Title>Truncate Q to Qt Qt = truncate(Q) + Â½ ulp </LI_Title></LI><LI>Required datapath: incrementer(25bit) </LI></L><L><LI><LI_Label>(7) </LI_Label><LI_Title>Calculate QtB : this value will be used for rounding decision QtB = Qt Ã— FracB </LI_Title></LI><LI>Required datapath: multiplier(25bit Ã— 24bit) </LI></L><L><LI><LI_Label>(8) </LI_Label><LI_Title>Rounding FracZÂ¶ = (roundup == 1) Qt + 1 : Qt )UDF= 06%)UDF=Â¶ Â³Â´&quot;)UDF=Â¶ &gt;&gt; 1 : FracZÂ¶ </LI_Title></LI><LI>Required datapath: incrementer(25bit), mux </LI></L><LI><LI_Label>(9) </LI_Label><LI_Title>Output formatting and Exception generation </LI_Title></LI></L><P>Exceptions </P><P>These cases do not raise exceptions, but result should be set to special value. </P><P>When either one of inputs is qNaN, set result to qNaN (specifically, 0x7FFF0000). </P><P>:KHQÂ’/ 0VHWUHVXOWWRÂ’ </P><P>:KHQÂ’1RUPVHWUHVXOWWRÂ’ </P><P>:KHQÂ’VHWUHVXOWWR </P><P>When Norm Â’, set result to 0. </P><L><L><LI><LI_Label>(1) </LI_Label><LI_Title>Invalid </LI_Title></LI><LI>IV = 1 when 0 / 0, set result to qNaN (specifically, 0x7FFF0000). 
,9 ZKHQÂ’Â’VHWUHVXOWWRT1D1 (specifically, 0x7FFF0000). 
IV = 1 when either one of inputs is sNaN, set result to qNaN (specifically, 0x7FFF0000). 
Otherwise IV = 0. 
</LI></L><LI><LI_Label>(2) </LI_Label><LI_Title>Overflow </LI_Title></LI></L><P>29 ZKHQ([S=Â•VHWUHVXOWWRÂ’ </P><P>Otherwise OV = 0. </P><P>(3) Divide by Zero D0 = ZKHQ1RUPVHWUHVXOWWRÂ’ </P><L><LI><LI_Label>(4) </LI_Label><LI_Title>Underflow 8' ZKHQ([S*Â”Â±24, set result to 0. Otherwise UD = 0. </LI_Title></LI><LI><LI_Label>(5) </LI_Label><LI_Title>Inexact IX = 1 when OV = 1, IX = 0 when either one of inputs is NaN. Otherwise IX = 0. </LI_Title></LI></L><P>Practically multiplicative algorithms such as the one implemented do not produce IEEE754 inexact exceptions correctly. In order to generate correct inexact exceptions, software support for IEEE-754 compatibility is required for division operations. </P><P>(6) Denormalized output When Â±Â”([S=Â”VHWUHVXOWWRWKHVPDOOHVWQRUPDOL]HGQXPEHU, and set UD = 1, IX = 1. </P></Sect><Sect><H4>4-6-2. Implementation of FP-MUL/DIV fused unit </H4><P>There are three major multiply operations in the Taylor-series expansion algorithm with powering units to produce a quotient with 0.5 ulp (unit in the last place) error. One additional multiply operation is required for exact rounding to generate IEEE-754 floating-point standard compliant results. Even though the Taylor-series expansion algorithm with powering units exhibits the highest performance among multiplicative algorithms, it consumes a larger area because the architecture consists of four multipliers, which is not suitable for area-critical applications. The ISI FPU uses a fused floating-point multiply-divide architecture based on Taylor-series expansion with powering units where all multiply operations are executed by one multiplier to maximize the area efficiency, while achieving high performance by using a pipelined architecture. By sharing the 2-stage pipelined multiplier among the multiply operations in the algorithm, the latency becomes longer (12 clock cycles) than the direct implementation of the original algorithm (8 clock cycles). However, through careful pipeline scheduling, a moderately high throughput (one completion every 5 clock cycles) for consecutive divide instructions is achieved with an area that is 1.6 times smaller than the direct implementation. </P><P>Dividend (A) Divisor (B) </P><Figure><ImageData src="images/TA0_datasheet_revD_img_29.jpg"/>+/-Rounding ctrl Multiplier (stage 1) Multiplier (stage 2) AX/Qt A X B %Â¶S ROM MD2 MD1 MD3 MD4 MD5 A 2A SC Unit 1+SC+SC2+SC3 MD5' M1 M2 SC Qt </Figure><P>Qutient (Q) </P><P>[ Hardware structure of proposed Multiplier/Divider fused unit ] </P><Figure><ImageData src="images/TA0_datasheet_revD_img_30.jpg"/>Cycle Operation Pipeline Stage </Figure><Table><TR><TH>1 2 3 4 5 6 7 8 9 10 11 12 </TH><TH>X = ROM(b) M1 = Bu X (stage1) M2 = Bu X (stage2), M1 = AuX (stage1) SC = 1Â±M2, M2 = AuX (stage2) S = 1+SC+SC2+SC3, AX = M2 M1 = AXuS (stage1) M2 = AXuS (stage2) Qt = truncate(M2)+1 M1 = Bu Qt (stage1) M2 = Bu Qt (stage2) R = round(Qt) Quotient = format(R) </TH><TH>MD1 MD2 MD3/MD2 MD4/MD3 0'Â¶0' MD2 MD3 MD4 MD2 MD3 MD4 MD5 </TH></TR></Table><P>[ Summary of operations in each cycle] 
</P></Sect></Sect><Sect><H3>5. Test Article Pinout </H3><P>The table below lists the pad-to-signal assignment for the test article die as well as the pin-tosignal assignment for test articles that are bonded in PGA181 packages. Pad numbering is consistent with the MOSIS convention for this package; namely, pad 1 is the rightmost pad on the top edge of the chip, and numbering proceeds counter-clockwise. For more detail on this PGA181 package and numbering conventions, refer to documentation found at http://www.mosis.com/Technical/Packaging/Ceramic/menu-pkg-ceramic.html. Not shown on the MOSIS bonding diagrams is locator pin E5, which is a no-connect. </P><Table><TR><TD>Pad Number / Bonding Finger </TD><TD>Pin </TD><TD>Signal </TD><TD>Signal Type </TD><TD>Pad Number / Bonding Finger </TD><TD>Pin </TD><TD>Signal </TD><TD>Signal Type </TD><TD>Pad Number / Bonding Finger </TD><TD>Pin </TD><TD>Signal </TD><TD>Signal Type </TD></TR><TR><TD>1 </TD><TD>B1 </TD><TD>NC </TD><TD>NC </TD><TD>61 </TD><TD>N5 </TD><TD>A27 </TD><TD>I </TD><TD>121 </TD><TD>D13 </TD><TD>padVSS </TD><TD>GND </TD></TR><TR><TD>2 </TD><TD>C1 </TD><TD>opcode0 </TD><TD>I </TD><TD>62 </TD><TD>N6 </TD><TD>A28 </TD><TD>I </TD><TD>122 </TD><TD>C13 </TD><TD>B30 </TD><TD>I </TD></TR><TR><TD>3 </TD><TD>D1 </TD><TD>opcode1 </TD><TD>I </TD><TD>63 </TD><TD>N7 </TD><TD>A29 </TD><TD>I </TD><TD>123 </TD><TD>G14 </TD><TD>B31 </TD><TD>I </TD></TR><TR><TD>4 </TD><TD>E1 </TD><TD>opcode2 </TD><TD>I </TD><TD>64 </TD><TD>M8 </TD><TD>padVDD </TD><TD>2.5V </TD><TD>124 </TD><TD>F14 </TD><TD>D0 </TD><TD>O </TD></TR><TR><TD>5 </TD><TD>F1 </TD><TD>clk </TD><TD>I </TD><TD>65 </TD><TD>M9 </TD><TD>padVSS </TD><TD>GND </TD><TD>125 </TD><TD>E14 </TD><TD>padVDD </TD><TD>2.5V </TD></TR><TR><TD>6 </TD><TD>G1 </TD><TD>padVDD </TD><TD>2.5V </TD><TD>66 </TD><TD>M10 </TD><TD>A30 </TD><TD>I </TD><TD>126 </TD><TD>D14 </TD><TD>padVSS </TD><TD>GND </TD></TR><TR><TD>7 </TD><TD>H1 </TD><TD>padVSS </TD><TD>GND </TD><TD>67 </TD><TD>M11 </TD><TD>A31 </TD><TD>I </TD><TD>127 </TD><TD>C14 </TD><TD>IV </TD><TD>O </TD></TR><TR><TD>8 </TD><TD>C2 </TD><TD>en </TD><TD>I </TD><TD>68 </TD><TD>L8 </TD><TD>B0 </TD><TD>I </TD><TD>128 </TD><TD>B14 </TD><TD>IX </TD><TD>O </TD></TR><TR><TD>9 </TD><TD>D2 </TD><TD>en_input </TD><TD>I </TD><TD>69 </TD><TD>M12 </TD><TD>B1 </TD><TD>I </TD><TD>129 </TD><TD>G15 </TD><TD>OV </TD><TD>O </TD></TR><TR><TD>10 </TD><TD>E2 </TD><TD>start_div </TD><TD>I </TD><TD>70 </TD><TD>N8 </TD><TD>padVDD </TD><TD>2.5V </TD><TD>130 </TD><TD>F15 </TD><TD>UD </TD><TD>O </TD></TR><TR><TD>11 </TD><TD>F2 </TD><TD>resetn </TD><TD>I </TD><TD>71 </TD><TD>N9 </TD><TD>padVSS </TD><TD>GND </TD><TD>131 </TD><TD>E15 </TD><TD>padVDD </TD><TD>2.5V </TD></TR><TR><TD>12 </TD><TD>G2 </TD><TD>padVDD </TD><TD>2.5V </TD><TD>72 </TD><TD>N10 </TD><TD>coreVDD </TD><TD>1.2V </TD><TD>132 </TD><TD>D15 </TD><TD>padVSS </TD><TD>GND </TD></TR><TR><TD>13 </TD><TD>H2 </TD><TD>padVSS </TD><TD>GND </TD><TD>73 </TD><TD>N11 </TD><TD>coreVSS </TD><TD>GND </TD><TD>133 </TD><TD>C15 </TD><TD>R0 </TD><TD>O </TD></TR><TR><TD>14 </TD><TD>D3 </TD><TD>sel0 </TD><TD>I </TD><TD>74 </TD><TD>N12 </TD><TD>B2 </TD><TD>I </TD><TD>134 </TD><TD>B15 </TD><TD>R1 </TD><TD>O </TD></TR><TR><TD>15 </TD><TD>E3 </TD><TD>sel1 </TD><TD>I </TD><TD>75 </TD><TD>N13 </TD><TD>B3 </TD><TD>I </TD><TD>135 </TD><TD>A15 </TD><TD>R2 </TD><TD>O </TD></TR><TR><TD>16 </TD><TD>F3 </TD><TD>A0 </TD><TD>I </TD><TD>76 </TD><TD>P8 </TD><TD>B4 </TD><TD>I </TD><TD>136 </TD><TD>D11 </TD><TD>padVDD </TD><TD>2.5V </TD></TR><TR><TD>17 </TD><TD>G3 </TD><TD>A1 </TD><TD>I </TD><TD>77 </TD><TD>P9 </TD><TD>B5 </TD><TD>I </TD><TD>137 </TD><TD>D10 </TD><TD>padVSS </TD><TD>GND </TD></TR><TR><TD>18 </TD><TD>H3 </TD><TD>padVDD </TD><TD>2.5V </TD><TD>78 </TD><TD>P10 </TD><TD>padVDD </TD><TD>2.5V </TD><TD>138 </TD><TD>D9 </TD><TD>R3 </TD><TD>O </TD></TR><TR><TD>19 </TD><TD>E4 </TD><TD>padVSS </TD><TD>GND </TD><TD>79 </TD><TD>P11 </TD><TD>padVSS </TD><TD>GND </TD><TD>139 </TD><TD>A14 </TD><TD>R4 </TD><TD>O </TD></TR><TR><TD>20 </TD><TD>F4 </TD><TD>coreVDD </TD><TD>1.2V </TD><TD>80 </TD><TD>P12 </TD><TD>B6 </TD><TD>I </TD><TD>140 </TD><TD>A13 </TD><TD>R5 </TD><TD>O </TD></TR><TR><TD>21 </TD><TD>G4 </TD><TD>coreVSS </TD><TD>GND </TD><TD>81 </TD><TD>P13 </TD><TD>B7 </TD><TD>I </TD><TD>141 </TD><TD>A12 </TD><TD>R6 </TD><TD>O </TD></TR><TR><TD>22 </TD><TD>H4 </TD><TD>A2 </TD><TD>I </TD><TD>82 </TD><TD>P14 </TD><TD>B8 </TD><TD>I </TD><TD>142 </TD><TD>A11 </TD><TD>R7 </TD><TD>O </TD></TR><TR><TD>23 </TD><TD>H5 </TD><TD>A3 </TD><TD>I </TD><TD>83 </TD><TD>R8 </TD><TD>B9 </TD><TD>I </TD><TD>143 </TD><TD>A10 </TD><TD>padVDD </TD><TD>2.5V </TD></TR><TR><TD>24 </TD><TD>J4 </TD><TD>A4 </TD><TD>I </TD><TD>84 </TD><TD>R9 </TD><TD>padVDD </TD><TD>2.5V </TD><TD>144 </TD><TD>A9 </TD><TD>padVSS </TD><TD>GND </TD></TR><TR><TD>25 </TD><TD>K4 </TD><TD>coreVDD </TD><TD>1.2V </TD><TD>85 </TD><TD>R10 </TD><TD>padVSS </TD><TD>GND </TD><TD>145 </TD><TD>B13 </TD><TD>R8 </TD><TD>O </TD></TR><TR><TD>26 </TD><TD>L4 </TD><TD>coreVSS </TD><TD>GND </TD><TD>86 </TD><TD>R11 </TD><TD>B10 </TD><TD>I </TD><TD>146 </TD><TD>B12 </TD><TD>R9 </TD><TD>O </TD></TR><TR><TD>27 </TD><TD>M4 </TD><TD>padVDD </TD><TD>2.5V </TD><TD>87 </TD><TD>R12 </TD><TD>B11 </TD><TD>I </TD><TD>147 </TD><TD>B11 </TD><TD>R10 </TD><TD>O </TD></TR><TR><TD>28 </TD><TD>J3 </TD><TD>padVSS </TD><TD>GND </TD><TD>88 </TD><TD>R13 </TD><TD>B12 </TD><TD>I </TD><TD>148 </TD><TD>B10 </TD><TD>R11 </TD><TD>O </TD></TR><TR><TD>29 </TD><TD>K3 </TD><TD>A5 </TD><TD>I </TD><TD>89 </TD><TD>R14 </TD><TD>padVDD </TD><TD>2.5V </TD><TD>149 </TD><TD>B9 </TD><TD>padVDD </TD><TD>2.5V </TD></TR><TR><TD>30 </TD><TD>L3 </TD><TD>A6 </TD><TD>I </TD><TD>90 </TD><TD>R15 </TD><TD>padVSS </TD><TD>GND </TD><TD>150 </TD><TD>C12 </TD><TD>padVSS </TD><TD>GND </TD></TR><TR><TD>31 </TD><TD>M3 </TD><TD>A7 </TD><TD>I </TD><TD>91 </TD><TD>P15 </TD><TD>padVDD </TD><TD>2.5V </TD><TD>151 </TD><TD>C11 </TD><TD>R12 </TD><TD>O </TD></TR><TR><TD>32 </TD><TD>N3 </TD><TD>A8 </TD><TD>I </TD><TD>92 </TD><TD>N15 </TD><TD>padVSS </TD><TD>GND </TD><TD>152 </TD><TD>C10 </TD><TD>R13 </TD><TD>O </TD></TR><TR><TD>33 </TD><TD>J2 </TD><TD>A9 </TD><TD>I </TD><TD>93 </TD><TD>M15 </TD><TD>B13 </TD><TD>I </TD><TD>153 </TD><TD>C9 </TD><TD>R14 </TD><TD>O </TD></TR><TR><TD>34 </TD><TD>K2 </TD><TD>padVDD </TD><TD>2.5V </TD><TD>94 </TD><TD>L15 </TD><TD>B14 </TD><TD>I </TD><TD>154 </TD><TD>D8 </TD><TD>R15 </TD><TD>O </TD></TR><TR><TD>35 </TD><TD>L2 </TD><TD>padVSS </TD><TD>GND </TD><TD>95 </TD><TD>K15 </TD><TD>B15 </TD><TD>I </TD><TD>155 </TD><TD>D7 </TD><TD>padVDD </TD><TD>2.5V </TD></TR><TR><TD>36 </TD><TD>M2 </TD><TD>A10 </TD><TD>I </TD><TD>96 </TD><TD>J15 </TD><TD>B16 </TD><TD>I </TD><TD>156 </TD><TD>D6 </TD><TD>padVSS </TD><TD>GND </TD></TR><TR><TD>37 </TD><TD>N2 </TD><TD>A11 </TD><TD>I </TD><TD>97 </TD><TD>H15 </TD><TD>padVDD </TD><TD>2.5V </TD><TD>157 </TD><TD>D5 </TD><TD>R16 </TD><TD>O </TD></TR><TR><TD>38 </TD><TD>P2 </TD><TD>A12 </TD><TD>I </TD><TD>98 </TD><TD>N14 </TD><TD>padVSS </TD><TD>GND </TD><TD>158 </TD><TD>E8 </TD><TD>R17 </TD><TD>O </TD></TR><TR><TD>39 </TD><TD>J1 </TD><TD>A13 </TD><TD>I </TD><TD>99 </TD><TD>M14 </TD><TD>B17 </TD><TD>I </TD><TD>159 </TD><TD>D4 </TD><TD>R18 </TD><TD>O </TD></TR><TR><TD>40 </TD><TD>K1 </TD><TD>padVDD </TD><TD>2.5V </TD><TD>100 </TD><TD>L14 </TD><TD>B18 </TD><TD>I </TD><TD>160 </TD><TD>C8 </TD><TD>R19 </TD><TD>O </TD></TR><TR><TD>41 </TD><TD>L1 </TD><TD>padVSS </TD><TD>GND </TD><TD>101 </TD><TD>K14 </TD><TD>B19 </TD><TD>I </TD><TD>161 </TD><TD>C7 </TD><TD>coreVDD </TD><TD>1.2V </TD></TR><TR><TD>42 </TD><TD>M1 </TD><TD>A14 </TD><TD>I </TD><TD>102 </TD><TD>J14 </TD><TD>B20 </TD><TD>I </TD><TD>162 </TD><TD>C6 </TD><TD>coreVSS </TD><TD>GND </TD></TR><TR><TD>43 </TD><TD>N1 </TD><TD>A15 </TD><TD>I </TD><TD>103 </TD><TD>H14 </TD><TD>padVDD </TD><TD>2.5V </TD><TD>163 </TD><TD>C5 </TD><TD>padVDD </TD><TD>2.5V </TD></TR><TR><TD>44 </TD><TD>P1 </TD><TD>A16 </TD><TD>I </TD><TD>104 </TD><TD>M13 </TD><TD>padVSS </TD><TD>GND </TD><TD>164 </TD><TD>C4 </TD><TD>padVSS </TD><TD>GND </TD></TR><TR><TD>45 </TD><TD>R1 </TD><TD>A17 </TD><TD>I </TD><TD>105 </TD><TD>L13 </TD><TD>B21 </TD><TD>I </TD><TD>165 </TD><TD>C3 </TD><TD>R20 </TD><TD>O </TD></TR><TR><TD>46 </TD><TD>M5 </TD><TD>padVDD </TD><TD>2.5V </TD><TD>106 </TD><TD>K13 </TD><TD>B22 </TD><TD>I </TD><TD>166 </TD><TD>B8 </TD><TD>R21 </TD><TD>O </TD></TR><TR><TD>47 </TD><TD>M6 </TD><TD>padVSS </TD><TD>GND </TD><TD>107 </TD><TD>J13 </TD><TD>B23 </TD><TD>I </TD><TD>167 </TD><TD>B7 </TD><TD>R22 </TD><TD>O </TD></TR><TR><TD>48 </TD><TD>M7 </TD><TD>A18 </TD><TD>I </TD><TD>108 </TD><TD>H13 </TD><TD>B24 </TD><TD>I </TD><TD>168 </TD><TD>B6 </TD><TD>R23 </TD><TD>O </TD></TR><TR><TD>49 </TD><TD>R2 </TD><TD>A19 </TD><TD>I </TD><TD>109 </TD><TD>L12 </TD><TD>B25 </TD><TD>I </TD><TD>169 </TD><TD>B5 </TD><TD>padVDD </TD><TD>2.5V </TD></TR><TR><TD>50 </TD><TD>R3 </TD><TD>A20 </TD><TD>I </TD><TD>110 </TD><TD>K12 </TD><TD>coreVDD </TD><TD>1.2V </TD><TD>170 </TD><TD>B4 </TD><TD>padVSS </TD><TD>GND </TD></TR><TR><TD>51 </TD><TD>R4 </TD><TD>A21 </TD><TD>I </TD><TD>111 </TD><TD>J12 </TD><TD>coreVSS </TD><TD>GND </TD><TD>171 </TD><TD>B3 </TD><TD>R24 </TD><TD>O </TD></TR><TR><TD>52 </TD><TD>R5 </TD><TD>padVDD </TD><TD>2.5V </TD><TD>112 </TD><TD>H12 </TD><TD>padVDD </TD><TD>2.5V </TD><TD>172 </TD><TD>B2 </TD><TD>R25 </TD><TD>O </TD></TR><TR><TD>53 </TD><TD>R6 </TD><TD>padVSS </TD><TD>GND </TD><TD>113 </TD><TD>H11 </TD><TD>padVSS </TD><TD>GND </TD><TD>173 </TD><TD>A8 </TD><TD>R26 </TD><TD>O </TD></TR><TR><TD>54 </TD><TD>R7 </TD><TD>A22 </TD><TD>I </TD><TD>114 </TD><TD>G12 </TD><TD>B26 </TD><TD>I </TD><TD>174 </TD><TD>A7 </TD><TD>R27 </TD><TD>O </TD></TR><TR><TD>55 </TD><TD>P3 </TD><TD>A23 </TD><TD>I </TD><TD>115 </TD><TD>F12 </TD><TD>B27 </TD><TD>I </TD><TD>175 </TD><TD>A6 </TD><TD>padVDD </TD><TD>2.5V </TD></TR><TR><TD>56 </TD><TD>P4 </TD><TD>A24 </TD><TD>I </TD><TD>116 </TD><TD>E12 </TD><TD>B28 </TD><TD>I </TD><TD>176 </TD><TD>A5 </TD><TD>padVSS </TD><TD>GND </TD></TR><TR><TD>57 </TD><TD>P5 </TD><TD>A25 </TD><TD>I </TD><TD>117 </TD><TD>D12 </TD><TD>B29 </TD><TD>I </TD><TD>177 </TD><TD>A4 </TD><TD>R28 </TD><TD>O </TD></TR><TR><TD>58 </TD><TD>P6 </TD><TD>padVDD </TD><TD>2.5V </TD><TD>118 </TD><TD>G13 </TD><TD>coreVDD </TD><TD>1.2V </TD><TD>178 </TD><TD>A3 </TD><TD>R29 </TD><TD>O </TD></TR><TR><TD>59 </TD><TD>P7 </TD><TD>padVSS </TD><TD>GND </TD><TD>119 </TD><TD>F13 </TD><TD>coreVSS </TD><TD>GND </TD><TD>179 </TD><TD>A2 </TD><TD>R30 </TD><TD>O </TD></TR><TR><TD>60 </TD><TD>N4 </TD><TD>A26 </TD><TD>I </TD><TD>120 </TD><TD>E13 </TD><TD>padVDD </TD><TD>2.5V </TD><TD>180 </TD><TD>A1 </TD><TD>R31 </TD><TD>O </TD></TR></Table><P>37 
</P></Sect><Sect><H3>6. Timing Information </H3><P>All timing information below is based on simulation at worst-case conditions (T = 125Â°C, Vdd = 1.08V).  For simplicity, all inputs have been grouped together.  While set-up times and hold times vary among inputs, the values listed below represent the worst-case values needed for correct operation. </P><Figure><ImageData src="images/TA0_datasheet_revD_img_31.jpg"/>stable tsu th tpdseq <Caption><P>out0 </P></Caption></Figure><P>CLK </P><P>resetn, opcode[2:0], A[31:0], B[31:0], en, en_input, start_div </P><P>R[31:0], D0, IV, IX, OV, UD </P><Figure><ImageData src="images/TA0_datasheet_revD_img_32.jpg"/></Figure><Figure><ImageData src="images/TA0_datasheet_revD_img_33.jpg"/></Figure><Table><TR><TH>Parameter </TH><TH>Value </TH></TR><TR><TD>tsu </TD><TD>2ns </TD></TR><TR><TD>th </TD><TD>1ns </TD></TR><TR><TD>tpdseq </TD><TD>6ns </TD></TR></Table><P>In addition to this sequential timing information, there is one combinational path between inputs and outputs involving the output multiplexer select bits, sel[1:0]. </P><Figure><ImageData src="images/TA0_datasheet_revD_img_34.jpg"/>stable sel[1:0] R[31:0], D0, IV, IX, OV, UD out0 tpdcomb Parameter Value tpdcomb 4ns </Figure><P>Functional Testing Strategy </P><P>An approach for applying input stimuli and sampling outputs to perform functional testing is to apply input stimuli changes at the falling edge of the clk signal and sample outputs at the rising edge of clk. This approach was used in simulation to verify the design. As can be ascertained from the above timing data, such an approach should work up to a frequency of 167MHz, as limited by the tpdseq value, assuming that outputs sampled during any cycle in which sel[1:0] VLJQDOVFKDQJHDUHGRQÂ¶W-cares. </P></Sect><Sect><H3>7. Physical Chip Dimensions and Core Locations </H3><P>The design submitted for fabrication was prepared with version V1.2.0.2CP of the IBM 9LP PDK and measured 3.52mm x 3.52mm. With the inclusion of scribe lanes and other margins (refer to http://www.mosis.com/products/assembly/#die-size for examples), the anticipated die size for TA0 is 3.7mm x 3.7mm. The fiducial provided by IBM contains marking identifiers in the lower left and upper right corners of the die and was included in the design file. Refer to the figure below, which shows relative locations of fiducial markings and the four FPU cores. Each FPU core is approximately 400Pm on a side (some layers extend to the left of or below the 0,0 origin by 260nm causing the total size to be slightly larger than 400Pm). Additionally, metal test structures were located in the chip design. The gdsii for these metal test structures (filename mtest2.gds) can be found in the design repository at the same directory level as the golden core gdsii. The table below provides x-y coordinate information for the points denoted in the figure. Note that each character in the fiducial lettering is comprised of multiple polygons. </P><Figure><ImageData src="images/TA0_datasheet_revD_img_35.jpg"/>FPUA FPUB FPUC FPUD 1234A 1234A IBM Upper pattern in metal1 Lower pattern in poly IBM logo in metal1 Metal test structures </Figure><P>[ Depiction of TA0 Physical Organization (not to scale)] 
</P><Table><TR><TH>Point of Interest </TH><TH>Coordinates (Pm) </TH></TR><TR><TH>x </TH><TH>y </TH></TR><TR><TH>Lower left corner of lower left polygon of the Â³Â´LQthe SRO\VLOLFRQÂ³$Â´ fiducial </TH><TD>3378.675 </TD><TD>3378.675 </TD></TR><TR><TH>Upper right corner of upper right polygon of the Â³0Â´LQthe Â³,%0Â´ILGXFLDO </TH><TD>141.325 </TD><TD>141.325 </TD></TR><TR><TH>Origin (0,0) of FPUA </TH><TD>1823.48 </TD><TD>1295.34 </TD></TR><TR><TH>Origin (0,0) of FPUB </TH><TD>1823.48 </TD><TD>1853.10 </TD></TR><TR><TH>Origin (0,0) of FPUC </TH><TD>1296.24 </TD><TD>1295.34 </TD></TR><TR><TH>Origin (0,0) of FPUD </TH><TD>1296.24 </TD><TD>1853.10 </TD></TR><TR><TH>Lower left corner of metal test structures </TH><TD>320.92 </TD><TD>3081.38 </TD></TR><TR><TH>Upper right corner of metal test structures </TH><TD>329.95 </TD><TD>3193.02 </TD></TR></Table></Sect></Part></TaggedPDF-doc>