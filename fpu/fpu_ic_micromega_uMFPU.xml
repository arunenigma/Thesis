<?xml version="1.0" encoding="UTF-8" ?><!-- Created from PDF via Acrobat SaveAsXML --><!-- Mapping Table version: 28-February-2003 --><TaggedPDF-doc><?xpacket begin='﻿' id='W5M0MpCehiHzreSzNTczkc9d'?><?xpacket begin="﻿" id="W5M0MpCehiHzreSzNTczkc9d"?>
<x:xmpmeta xmlns:x="adobe:ns:meta/" x:xmptk="Adobe XMP Core 5.2-c001 63.139439, 2010/09/27-13:37:26        ">
   <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
      <rdf:Description rdf:about=""
            xmlns:dc="http://purl.org/dc/elements/1.1/">
         <dc:format>xml</dc:format>
         <dc:creator>
            <rdf:Seq>
               <rdf:li>Cam Thompson</rdf:li>
            </rdf:Seq>
         </dc:creator>
         <dc:title>
            <rdf:Alt>
               <rdf:li xml:lang="x-default">uMFPU-V3_1 Datasheet</rdf:li>
            </rdf:Alt>
         </dc:title>
      </rdf:Description>
      <rdf:Description rdf:about=""
            xmlns:xmp="http://ns.adobe.com/xap/1.0/">
         <xmp:CreateDate>2011-07-18T15:20:17Z</xmp:CreateDate>
         <xmp:CreatorTool>Nisus Writer Pro</xmp:CreatorTool>
         <xmp:ModifyDate>2011-07-18T15:20:17Z</xmp:ModifyDate>
      </rdf:Description>
      <rdf:Description rdf:about=""
            xmlns:pdf="http://ns.adobe.com/pdf/1.3/">
         <pdf:Producer>Mac OS X 10.6.8 Quartz PDFContext</pdf:Producer>
      </rdf:Description>
   </rdf:RDF>
</x:xmpmeta>
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                           
<?xpacket end="w"?><?xpacket end='r'?><bookmark-tree><bookmark title="Introduction"><destination structID="LinkTarget_696"/></bookmark><bookmark title="Features"><destination structID="LinkTarget_697"/><bookmark title=""><destination structID="None"/><bookmark title=""><destination structID="None"/><bookmark title="32-bit Floating Point and 32-bit Integer"><destination structID="LinkTarget_698"/></bookmark><bookmark title="User-defined Functions"><destination structID="LinkTarget_699"/></bookmark><bookmark title="Matrix Operations"><destination structID="LinkTarget_700"/></bookmark><bookmark title="FFT Instruction"><destination structID="LinkTarget_701"/></bookmark><bookmark title="Serial Input / Output"><destination structID="LinkTarget_702"/></bookmark><bookmark title="NMEA Sentence Parsing"><destination structID="LinkTarget_703"/></bookmark><bookmark title="String Handling"><destination structID="LinkTarget_704"/></bookmark><bookmark title="Table Lookup Instructions"><destination structID="LinkTarget_705"/></bookmark><bookmark title="MAC Instructions"><destination structID="LinkTarget_706"/></bookmark><bookmark title="A/D Conversion"><destination structID="LinkTarget_707"/></bookmark><bookmark title="Timers"><destination structID="LinkTarget_708"/></bookmark><bookmark title="External Input"><destination structID="LinkTarget_709"/></bookmark><bookmark title="Low Power Modes"><destination structID="LinkTarget_710"/></bookmark><bookmark title="Internal Oscillator"><destination structID="LinkTarget_711"/></bookmark><bookmark title="Core Features"><destination structID="LinkTarget_712"/><bookmark title="Single Byte Opcode"><destination structID="LinkTarget_713"/></bookmark><bookmark title="Multiple Byte Opcode"><destination structID="LinkTarget_714"/></bookmark><bookmark title="Opcode followed by return value"><destination structID="LinkTarget_715"/><bookmark title="Break – stop execution after next instruction"><destination structID="LinkTarget_716"/></bookmark><bookmark title="EEPROM – display EEPROM memory"><destination structID="LinkTarget_717"/></bookmark><bookmark title="Flash – display Flash stored function memory"><destination structID="LinkTarget_718"/></bookmark><bookmark title="Go – continue execution"><destination structID="LinkTarget_719"/></bookmark><bookmark title="Registers – display registers"><destination structID="LinkTarget_720"/></bookmark><bookmark title="String – display string, length and selection point"><destination structID="LinkTarget_721"/></bookmark><bookmark title="Trace – toggle trace mode on/off"><destination structID="LinkTarget_722"/></bookmark><bookmark title="Version – display version information"><destination structID="LinkTarget_723"/></bookmark><bookmark title="Change – display changed registers"><destination structID="LinkTarget_724"/></bookmark><bookmark title="Comment – add comment to debug trace"><destination structID="LinkTarget_725"/></bookmark><bookmark title="Clock – select clock source"><destination structID="LinkTarget_726"/></bookmark><bookmark title="Checksum – display checksum value"><destination structID="LinkTarget_727"/></bookmark><bookmark title="Mode – set mode parameters"><destination structID="LinkTarget_728"/></bookmark><bookmark title="Program – program user function memory"><destination structID="LinkTarget_729"/></bookmark><bookmark title="BREAK"><destination structID="LinkTarget_730"/></bookmark><bookmark title="TRACEOFF"><destination structID="LinkTarget_731"/></bookmark><bookmark title="TRACEON"><destination structID="LinkTarget_732"/></bookmark><bookmark title="TRACESTR"><destination structID="LinkTarget_733"/></bookmark><bookmark title="TRACEREG"><destination structID="LinkTarget_734"/></bookmark><bookmark title="Parameter"><destination structID="LinkTarget_735"/></bookmark></bookmark><bookmark title="Minimum"><destination structID="LinkTarget_736"/></bookmark><bookmark title="Typical"><destination structID="LinkTarget_737"/></bookmark><bookmark title="Maximum"><destination structID="LinkTarget_738"/></bookmark><bookmark title="Units"><destination structID="LinkTarget_739"/><bookmark title="Parameter"><destination structID="LinkTarget_740"/></bookmark></bookmark><bookmark title="Minimum"><destination structID="LinkTarget_741"/></bookmark><bookmark title="Typical"><destination structID="LinkTarget_742"/></bookmark><bookmark title="Maximum"><destination structID="LinkTarget_743"/></bookmark><bookmark title="Units"><destination structID="LinkTarget_744"/></bookmark></bookmark></bookmark><bookmark title="Block Diagram"><destination structID="LinkTarget_745"/></bookmark></bookmark><bookmark title="[__a9be414e.pdf]"><destination structID="LinkTarget_746"/><bookmark title="Pin Diagram"><destination structID="LinkTarget_745"/></bookmark><bookmark title="Pin Descriptions"><destination structID="LinkTarget_747"/></bookmark></bookmark></bookmark><bookmark title="Connecting to the uM-FPU V3.1 chip"><destination structID="LinkTarget_748"/></bookmark><bookmark title="2-wire SPI interface"><destination structID="LinkTarget_749"/></bookmark><bookmark title="3-wire SPI interface"><destination structID="LinkTarget_750"/></bookmark><bookmark title="SPI Bus Interface"><destination structID="LinkTarget_751"/><bookmark title="SPI Reset Operation"><destination structID="LinkTarget_752"/><bookmark title="Reset Timing Diagram"><destination structID="LinkTarget_753"/></bookmark></bookmark><bookmark title="SPI Reading and Writing Data"><destination structID="LinkTarget_754"/></bookmark><bookmark title="Read Delay"><destination structID="LinkTarget_755"/></bookmark><bookmark title="SPI Busy/Ready Status"><destination structID="LinkTarget_756"/></bookmark><bookmark title="SPI Instruction Timing Diagrams"><destination structID="LinkTarget_713"/><bookmark title="Unit"><destination structID="LinkTarget_757"/></bookmark></bookmark></bookmark><bookmark title="I2C interface"><destination structID="LinkTarget_758"/><bookmark title="I2C Slave Address"><destination structID="LinkTarget_759"/></bookmark><bookmark title="I2C Bus Speed"><destination structID="LinkTarget_760"/></bookmark><bookmark title="I2C Data Transfers"><destination structID="LinkTarget_761"/></bookmark><bookmark title="I2C Reset Operation"><destination structID="LinkTarget_762"/></bookmark><bookmark title="I2C Reading and Writing Data"><destination structID="LinkTarget_763"/></bookmark><bookmark title="I2C Busy/Ready Status"><destination structID="LinkTarget_764"/></bookmark><bookmark title="I2C Buffer Space"><destination structID="LinkTarget_765"/></bookmark><bookmark title="Read Delay"><destination structID="LinkTarget_766"/></bookmark></bookmark><bookmark title="Using OUT1 as a Ready/Busy Status"><destination structID="LinkTarget_767"/></bookmark><bookmark title="Using the SERIN and SEROUT Pins"><destination structID="LinkTarget_768"/></bookmark><bookmark title="Debug Monitor"><destination structID="LinkTarget_769"/></bookmark><bookmark title="Debug Instructions"><destination structID="LinkTarget_770"/></bookmark><bookmark title="Flash Memory"><destination structID="LinkTarget_771"/></bookmark><bookmark title="EEPROM Memory"><destination structID="LinkTarget_772"/></bookmark><bookmark title="PDIP-18 Through-Hole Package"><destination structID="LinkTarget_773"/></bookmark><bookmark title="SOIC-18 Surface Mount Package"><destination structID="LinkTarget_774"/></bookmark><bookmark title="QFN-44 Surface Mount Package"><destination structID="LinkTarget_775"/></bookmark><bookmark title="Absolute Maximum Ratings"><destination structID="LinkTarget_776"/></bookmark><bookmark title="DC Characteristics"><destination structID="LinkTarget_777"/></bookmark><bookmark title="Further Information"><destination structID="LinkTarget_778"/></bookmark><bookmark title="Appendix A"><destination structID="LinkTarget_779"/></bookmark><bookmark title="uM-FPU V3.1 Instruction Summary"><destination structID="LinkTarget_779"/></bookmark><bookmark title="Appendix B "><destination structID="LinkTarget_780"/></bookmark><bookmark title="uM-FPU V3.1 Instruction Timing"><destination structID="LinkTarget_780"/></bookmark></bookmark-tree><Figure><ImageData src="images/fpu_ic_micromega_uMFPU_img_0.jpg"/></Figure><Part><H1>uM-FPU V3.1 Datasheet </H1><Sect><H3>32-bit Floating Point Coprocessor </H3><P id="LinkTarget_696">Introduction </P><P>The uM-FPU V3.1 chip easily interfaces to virtually any microcontroller using a SPI™ or I2C™ interface. Many microcontrollers used in embedded systems lack floating point support, but a wide range of sensors available today require additional computations or data transformation to provide accurate results. </P><P>Advanced operations and fast execution allows the uM-FPU V3.1 chip to outperform comparable software math libraries. It also provides Flash memory and EEPROM for storing user-defined functions and data, and 128 32-bit registers for floating point and integer data.  </P><P>Software math libraries often use large amounts of memory on microcontrollers, particularly as more complex library functions are used. The uM-FPU V3.1 chip offloads this overhead, and provides a comprehensive set of floating point operations, including advanced functions such as FFT, matrix operations and NMEA sentence parsing. </P><P>Development support is provided by the uM-FPU V3 IDE which takes traditional math expressions and automatically produces uM-FPU code targeted for one of the many microcontrollers and compilers supported. The IDE also interacts with the built-in debugger on the uM-FPU V3.1 chip to assist in debugging and testing the uM-FPU code. </P><Figure><ImageData src="images/fpu_ic_micromega_uMFPU_img_1.jpg"/>Applications • sensor data processing • GPS data input and processing • robotic control • data transformations • embedded systems Features • 32-bit IEEE 754 ﬂoating point • 32-bit integer operations • GPS serial input • NMEA sentence parsing • FFT operations • 12-bit A/D Converters • Serial input/output • String handling • Matrix operations • SPI™ or I2C™ interface • 2.7V, 3.3V, 5V supply • low power modes • 18-pin DIP, SOIC-18, QFN-44 • RoHS compliant </Figure></Sect><Sect><H3 id="LinkTarget_697">Features </H3><Sect><H4 id="LinkTarget_698">32-bit Floating Point and 32-bit Integer</H4><P id="LinkTarget_699">A comprehensive set of 32-bit floating point and 32-bit integer operations are provided. See the uM-FPU V3.1 Instruction Set document for details. </P></Sect><Sect><H4>User-deﬁned Functions </H4><P id="LinkTarget_700">User-defined functions can be stored in Flash and EEPROM. Flash functions are programmed through the SERIN/SEROUT pins using the uM-FPU V3 IDE. The EEPROM functions can be programmed at run-time. Conditional execution is supported using conditional branch and jump instructions. </P></Sect><Sect><H4>Matrix Operations</H4><P id="LinkTarget_701">A matrix can be defined as any set of sequential registers. The MOP instruction provides scalar operations, element-wise operations, matrix multiply, inverse, determinant, count, sum, average, min, max, copy and set operations. </P></Sect><Sect><H4>FFT Instruction </H4><P id="LinkTarget_702">Provides support for Fast Fourier Transforms. Used as a single instruction for data sets that fit in the available registers, or as a multi-pass instruction for working with larger data sets. </P></Sect><Sect><H4>Serial Input / Output</H4><P id="LinkTarget_703">When not used for debugging, the SERIN and SEROUT pins can be used for serial I/O. For example, SERIN can be used to read data from a GPS, and SEROUT can be used to drive an LCD. </P></Sect><Sect><H4>NMEA Sentence Parsing</H4><P id="LinkTarget_704">The serial input can be set to scan for valid NMEA sentences with optional checksum.  Multiple sentences can be buffered for further processing. </P></Sect><Sect><H4>String Handling</H4><P id="LinkTarget_705">String instructions are provided to insert and append substrings,  search for fields and substrings, convert from floating point or long integer to a substring,  or convert from a substring to floating point or long integer. For example, the string instructions could be used to parse a GPS NMEA sentence, or format multiple numbers in an output string. </P></Sect><Sect><H4>Table Lookup Instructions</H4><P>Instructions are provided to load 32-bit values from a table or find the index of a floating point or long integer table entry that matches a specified condition. </P></Sect><Sect><H4 id="LinkTarget_706">MAC Instructions </H4><P id="LinkTarget_707">Instructions are provided to support multiply and accumulate and multiply and subtract operations. </P></Sect><Sect><H4>A/D Conversion</H4><P id="LinkTarget_708">Two 12-bit A/D channels are provided. The A/D conversion can be triggered manually, through an external input, or from a built-in timer. The A/D values can be read as raw values or automatically scaled to a floating point value. Data rates of up to 10,000 samples per second are supported. </P></Sect><Sect><H4>Timers </H4><P id="LinkTarget_709">Timers can be used to trigger the A/D conversion, or to track elapsed time. A microsecond and second timer are provided. </P></Sect><Sect><H4>External Input</H4><P id="LinkTarget_710">An external input can be used to trigger an A/D conversion, or to count external events. </P></Sect><Sect><H4>Low Power Modes </H4><P id="LinkTarget_711">When the uM-FPU V3.1 chip is not busy it automatically enters a power saving mode. It can also be configured to enter a sleep mode which turns the device off while preserving register contents. In sleep mode the uM-FPU V3.1 chip consumes negligible power. </P></Sect><Sect><H4>Internal Oscillator </H4><P id="LinkTarget_712">Operates at full speed from internal oscillator. No external components required. </P></Sect><Sect><H4>Core Features </H4><L><LI><LI_Label>• 	</LI_Label><LI_Title>Packages: 18-pin DIP, SOIC-18, QFN-44 </LI_Title></LI><LI><LI_Label>• 	</LI_Label><LI_Title>Supply voltages: 5V, 3.3V, 2.7V </LI_Title></LI><LI><LI_Label>• 	</LI_Label><LI_Title>Operating temperature: -40°C to +85°C </LI_Title></LI><LI><LI_Label>• 	</LI_Label><LI_Title>RoHS compliant </LI_Title></LI><LI><LI_Label>• 	</LI_Label><LI_Title>I2C compatible interface up to 400 kHz </LI_Title></LI><LI><LI_Label>• 	</LI_Label><LI_Title>SPI compatible interface up to 15 MHz </LI_Title></LI><LI><LI_Label>• 	</LI_Label><LI_Title>internal oscillator </LI_Title></LI><LI><LI_Label>• 	</LI_Label><LI_Title>no external components required </LI_Title></LI><LI><LI_Label>• 	</LI_Label><LI_Title>supports optional external oscillator </LI_Title></LI><LI><LI_Label>• 	</LI_Label><LI_Title>256 byte instruction buffer </LI_Title></LI><LI><LI_Label>• 	</LI_Label><LI_Title>128 general purpose 32-bit registers </LI_Title></LI><LI><LI_Label>• 	</LI_Label><LI_Title>8 temporary 32-bit registers </LI_Title></LI><LI><LI_Label>• 	</LI_Label><LI_Title>2304 bytes Flash memory for user-defined functions </LI_Title></LI><LI><LI_Label>• 	</LI_Label><LI_Title>1024 bytes EEPROM for data storage or user-defined functions </LI_Title></LI></L></Sect><Sect><H4 id="LinkTarget_745">Block Diagram Pin Diagram </H4><P id="LinkTarget_746">AVDD AVSS MCLR VDD VSS </P><P>PDIP-18, SOIC-18 </P><P><Figure><ImageData src="images/fpu_ic_micromega_uMFPU_img_2.jpg"/>I2C™ Interface SPI™ Interface Serial I/O 12-bit Analog to Digital Converter 32-bit Counter 32-bit Timers Digital Output Flash Memory 2304 bytes EEPROM Memory 256 x 32-bit String Processing Matrix Operations 32-bit Long Integers 32-bit Floating Point NMEA Sentence Input FFT Operations Debug Monitor Floating Point Coprocessor Instruction Buffer 256 bytes Registers 128 x 32-bit Power Control uM-FPU V3.1 </Figure>1 </P><P><Figure><ImageData src="images/fpu_ic_micromega_uMFPU_img_3.jpg"/></Figure><Figure><ImageData src="images/fpu_ic_micromega_uMFPU_img_4.jpg"/></Figure>18MCLR </P><P><Figure><ImageData src="images/fpu_ic_micromega_uMFPU_img_5.jpg"/></Figure>AVDD 2 17AN0 AVSS </P><P>AN0 </P><P>3 16AN1 SCLK </P><P>AN1 </P><P>4 15CS OUT0</P><P>uM-FPU </P><P>5 14EXTIN VDD </P><P>V3.1</P><P>6 13 VSS</P><P>OUT0 OSC1 </P><P>EXTIN </P><P>7 12OSC2 SIN/SDA</P><P>OUT1 </P><P>8 11 SEROUT SOUT/SCL </P><P>9 10SERIN OUT1 </P><P>OSC1 </P><P>OSC2 </P><P>CS 
SCLK 
</P><P>SERIN 
SIN/SDA 
</P><P>SEROUT SOUT/SCL </P><Figure><ImageData src="images/fpu_ic_micromega_uMFPU_img_6.jpg"/></Figure></Sect><Sect><H4 id="LinkTarget_747">Pin Descriptions </H4><P>PDIP-18, SOIC-18 </P><Table><TR><TH>Pin </TH><TH>Name </TH><TH>Type </TH><TH>Description </TH></TR><TR><TD>1 </TD><TD>/MCLR</TD><TD>Input</TD><TD>Master Clear (Reset)</TD></TR><TR><TD>2 </TD><TD>AN0 </TD><TD>Input</TD><TD>Analog Input 0 </TD></TR><TR><TD>3 </TD><TD>AN1 </TD><TD>Input</TD><TD>Analog Input 1</TD></TR><TR><TD>4 </TD><TD>CS </TD><TD>Input</TD><TD>Chip Select / Interface Select</TD></TR><TR><TD>5 </TD><TD>EXTIN </TD><TD>Input</TD><TD>External Input</TD></TR><TR><TD>6 </TD><TD>OSC1 </TD><TD>Input</TD><TD>Oscillator Crystal (optional)</TD></TR><TR><TD>7 </TD><TD>OSC2 </TD><TD>Output</TD><TD>Oscillator Crystal (optional)</TD></TR><TR><TD>8 </TD><TD>SEROUT </TD><TD>Output</TD><TD>Serial Output, Debug Monitor - Tx </TD></TR><TR><TD>9 </TD><TD>SERIN </TD><TD>Input</TD><TD>Serial Input, Debug Monitor - Rx </TD></TR><TR><TD>10 </TD><TD>OUT1 </TD><TD>Output</TD><TD>Digital Output 1, Ready/Busy Status</TD></TR><TR><TD>11 </TD><TD>SOUT SCL </TD><TD>OutputInput</TD><TD>SPI Output, Busy/Ready StatusI2C Clock </TD></TR><TR><TD>12 </TD><TD>SIN SDA </TD><TD>InputIn/Out</TD><TD>SPI InputI2C Data </TD></TR><TR><TD>13 </TD><TD>VSS </TD><TD>Power </TD><TD>Digital Ground</TD></TR><TR><TD>14 </TD><TD>VDD </TD><TD>Power </TD><TD>Digital Supply Voltage</TD></TR><TR><TD>15 </TD><TD>OUT0 </TD><TD>Output</TD><TD>Digital Output 0</TD></TR><TR><TD>16 </TD><TD>SCLK </TD><TD>Input</TD><TD>SPI Clock </TD></TR><TR><TD>17 </TD><TD>AVSS </TD><TD>Power </TD><TD>Analog Ground </TD></TR><TR><TD>18 </TD><TD>AVDD </TD><TD>Power </TD><TD>Analog Supply Voltage </TD></TR></Table></Sect></Sect><Sect><H3 id="LinkTarget_748">Connecting to the uM-FPU V3.1 chip </H3><P>The uM-FPU V3.1 chip can be interfaced using one of several different types of SPI interface, or an I2C interface. The different types are as follows: </P><L><LI><LI_Label>• </LI_Label><LI_Title>2-wire SPI interface, single device </LI_Title></LI><LI><LI_Label>• </LI_Label><LI_Title>3-wire SPI interface, single device </LI_Title></LI><LI><LI_Label>• </LI_Label><LI_Title>SPI bus interface, multiple devices </LI_Title></LI><LI><LI_Label>• </LI_Label><LI_Title>I2C interface, multiple devices </LI_Title></LI></L><P id="LinkTarget_749">By default, the CS pin is used to select between SPI or I2C interfaces. To use the CS pin as a chip select, as required by the SPI bus interface, a parameter byte stored in Flash must be set. This is described below, in the section called SPI Bus Interface. </P></Sect><Sect><H3>2-wire SPI interface </H3><P>When the uM-FPU V3.1 chip is connected directly to the microcontroller as a single device, no chip select is required, and either a 2-wire or 3-wire SPI interface can be used depending on the capabilities of the microcontroller. The 2-wire SPI connection uses a single bidirectional pin for both data input and data output. When a 2-wire SPI interface is used, the SOUT and SIN pins should not be connected directly together, they must be </P><P>connected through a 1K resistor. The microcontroller data pin is connected to the SIN pin. The CS pin is tied low to select SPI mode at Reset, and must remain low during operation. The connection diagrams are shown below. </P><Sect><H5>2-wire SPI Connection </H5><P>Microcontroller Pins 
DATA 
CLK 
</P><Figure><ImageData src="images/fpu_ic_micromega_uMFPU_img_7.jpg"/>/MCLR AN0 AN1 CS EXTIN OSC1 OSC2 SEROUT SERIN AVDD AVSS SCLK OUT0 VDD VSS SIN/SDA SOUT/SCL OUT1 uM-FPU V3 1 2 3 4 5 6 7 8 9 18 17 16 15 14 13 12 11 10 VDDVDD 1K </Figure></Sect></Sect><Sect><H3 id="LinkTarget_750">3-wire SPI interface </H3><P>The 3-wire SPI connection uses separate data input and data output pins on the microcontroller. The CS pin is tied low to select SPI mode at Reset, and must remain low during operation. </P><Sect><H5>3-wire SPI Connection </H5><P>Microcontroller Pins </P><P>DATA IN DATA OUT CLK </P><Figure><ImageData src="images/fpu_ic_micromega_uMFPU_img_8.jpg"/>/MCLR AN0 AN1 CS EXTIN OSC1 OSC2 SEROUT SERIN AVDD AVSS SCLK OUT0 VDD VSS SIN/SDA SOUT/SCL OUT1 uM-FPU V3 1 2 3 4 5 6 7 8 9 18 17 16 15 14 13 12 11 10 VDDVDD </Figure></Sect></Sect><Sect><H3 id="LinkTarget_751">SPI Bus Interface </H3><P>In order for the uM-FPU V3.1 chip to be used on a SPI bus with multiple devices, the CS pin must be enabled as a chip select. This is accomplished by programming mode parameter bits stored in Flash memory on the uM-FPU V3.1 chip. Bits 1:0 of mode parameter byte 0 must be set to 11 to select SPI bus mode. When this mode is set, the SPI interface is automatically selected at Reset, and the CS pin is enabled as a standard active low slave select. The SOUT pin is a tri-state output and is high impedance when the uM-FPU V3.1 chip is not selected.  The connection diagram is shown below: </P><Figure><ImageData src="images/fpu_ic_micromega_uMFPU_img_9.jpg"/>/MCLR AN0 AN1 CS EXTIN OSC1 OSC2 SEROUT SERIN AVDD AVSS SCLK OUT0 VDD VSS SIN/SDA SOUT/SCL OUT1 uM-FPU V3 1 2 3 4 5 6 7 8 9 18 17 16 15 14 13 12 11 10 VDDVDD MOSI Microcontroller Pins SCK MISO /SS </Figure><Figure><ImageData src="images/fpu_ic_micromega_uMFPU_img_10.jpg"/></Figure><Figure><ImageData src="images/fpu_ic_micromega_uMFPU_img_11.jpg"/></Figure><Figure><ImageData src="images/fpu_ic_micromega_uMFPU_img_12.jpg"/></Figure><Figure><ImageData src="images/fpu_ic_micromega_uMFPU_img_13.jpg"/></Figure><Figure><ImageData src="images/fpu_ic_micromega_uMFPU_img_14.jpg"/></Figure><Figure><ImageData src="images/fpu_ic_micromega_uMFPU_img_15.jpg"/></Figure><Figure><ImageData src="images/fpu_ic_micromega_uMFPU_img_16.jpg"/></Figure><Figure><ImageData src="images/fpu_ic_micromega_uMFPU_img_17.jpg"/></Figure><Figure><ImageData src="images/fpu_ic_micromega_uMFPU_img_18.jpg"/></Figure><Figure><ImageData src="images/fpu_ic_micromega_uMFPU_img_19.jpg"/></Figure><Figure><ImageData src="images/fpu_ic_micromega_uMFPU_img_20.jpg"/></Figure><Figure><ImageData src="images/fpu_ic_micromega_uMFPU_img_21.jpg"/></Figure><P>The clock signal is idle low and data is read on the rising edge of the clock (often referred to as SPI Mode 0). </P><Sect><H4 id="LinkTarget_752">SPI Reset Operation </H4><P id="LinkTarget_753">The uM-FPU should be reset at the beginning of every program to ensure that the microcontroller and the uM-FPU are synchronized. The uM-FPU will prepare for a reset after nine consecutive 0xFF bytes are read, but it is recommended that ten 0xFF bytes be sent by the microcontroller to ensure that at least nine 0xFF bytes are recognized even if the microcontroller and uM-FPU are out of sync. The reset does not occur until the SIN signal goes Low. If SIN remains High after sending the ten 0xFF bytes, a 0x00 byte must be sent (or SIN set Low) to trigger the reset. Note: If SIN does not go Low within 100 milliseconds of receiving nine 0xFF bytes, a reset will be triggered by default. A delay of 10 milliseconds is recommended after the reset is triggered to ensure that the reset sequence is complete and the uM-FPU is ready to receive commands. All uM-FPU registers are reset to the special value NaN (Not a Number), which is equal to hexadecimal 7FFFFFFF. </P></Sect><Sect><H4>Reset Timing Diagram </H4><Figure><ImageData src="images/fpu_ic_micromega_uMFPU_img_22.jpg"/>SCLK SIN 9 - 0xFF bytes Reset Delay SIN Low </Figure><Table><TR><TH>Item </TH><TH>Min </TH><TH>Typical </TH><TH>Max </TH><TH>Unit </TH></TR><TR><TD>Reset - 0xFF bytes </TD><TD>9 </TD><TD>10 </TD><TD/><TD>bytes </TD></TR><TR><TD>Reset - SIN Low </TD><TD/><TD/><TD>100 </TD><TD>msec </TD></TR><TR><TD>Reset Delay </TD><TD>10 </TD><TD/><TD/><TD>msec </TD></TR></Table></Sect><Sect><H4 id="LinkTarget_754">SPI Reading and Writing Data </H4><P>The uM-FPU is configured as a Serial Peripheral Interconnect (SPI) slave device. Data is transmitted and received with the most significant bit (MSB) first using SPI mode 0, summarized as follows: </P><P>SCLK is active High (idle state is Low) 
Data latched on leading edge of SCLK 
Data changes on trailing edge of SCLK 
Data is transmitted most significant bit first 
</P><P id="LinkTarget_755">The maximum SCLK frequency is 15 MHz, but there must be minimum data period between bytes. The minimum data period is measured from the rising edge of the first bit of one date byte to the rising edge of the first bit of the next data byte.  The minimum data period must elapse before the Busy/Ready status is checked. </P></Sect><Sect><H4>Read Delay </H4><P id="LinkTarget_756">There is a minimum delay (Read Setup Delay) required from the end of a read instruction opcode until the first data byte is ready to be read. With many microcontrollers the call overhead for the interface routines is long enough that no additional delay is required. On faster microcontrollers a suitable delay must be inserted after a read instruction to ensure that data is valid before the first byte is read. </P></Sect><Sect><H4>SPI Busy/Ready Status </H4><P>The busy/ready status must always be checked to confirm the Ready status prior to any read operation. The Busy status is asserted as soon as an instruction byte is received. The Ready status is asserted when both the instruction buffer and trace buffer are empty. If the uM-FPU is Ready the SOUT pin is held Low. If the uM-FPU is Busy, either executing instructions, or because the debug monitor is active, the SOUT pin is held High. The minimum data period must have elapsed since the last byte was transmitted before the SOUT status is checked. If more than 256 bytes of data are sent between read operations, the Ready status must also be checked at least once every 256 bytes to ensure that the instruction buffer does not overflow. The OUT1 pin can also be used to check the Busy/Ready Status, see the section entitled Using OUT1 as a Ready/Busy Status. </P></Sect><Sect><H4 id="LinkTarget_713">SPI Instruction Timing Diagrams Single Byte Opcode </H4><P>Minimum </P><Figure><ImageData src="images/fpu_ic_micromega_uMFPU_img_23.jpg"/>Ready SCLK SIN SOUT Busy Ready Data Period </Figure><P id="LinkTarget_714">Multiple Byte Opcode </P><Figure><ImageData src="images/fpu_ic_micromega_uMFPU_img_24.jpg"/>Ready SCLK SIN SOUT Busy Ready Minimum Data Period Minimum Data Period </Figure><Sect><H5 id="LinkTarget_715">Opcode followed by return value </H5><P>Read Read Minimum </P><Figure><ImageData src="images/fpu_ic_micromega_uMFPU_img_25.jpg"/>Ready SCLK SIN SOUT Busy Ready Data PeriodSetup Delay Byte Delay </Figure><Table><TR><TD>Item </TD><TD>Min </TD><TD>Max </TD><TD id="LinkTarget_757">Unit </TD></TR><TR><TD>SCLK Output Low </TD><TD>30 </TD><TD/><TD>nsec </TD></TR><TR><TD>SCLK Output High </TD><TD>30 </TD><TD/><TD>nsec </TD></TR><TR><TD>SCLK Frequency - single byte </TD><TD/><TD>15 </TD><TD>MHz </TD></TR><TR><TD>SCLK Frequency - continuous </TD><TD/><TD>5 </TD><TD>MHz </TD></TR><TR><TD>Minimum Data Period </TD><TD>1.6 </TD><TD/><TD>usec </TD></TR><TR><TD>Read Setup Delay </TD><TD>15 </TD><TD/><TD>usec </TD></TR><TR><TD>Read Byte Delay </TD><TD>1 </TD><TD/><TD>usec </TD></TR><TR><TD>Falling Edge of CS to Rising Edge of SCLK </TD><TD>120 </TD><TD/><TD>nsec </TD></TR><TR><TD>Falling Edge of CS to Busy/Ready Check </TD><TD>1 </TD><TD/><TD>usec </TD></TR><TR><TD>Rising Edge of CS to Bus Released </TD><TD/><TD>500 </TD><TD>nsec </TD></TR></Table></Sect></Sect></Sect><Sect><H3 id="LinkTarget_758">I2C interface </H3><P>If the CS pin is a logic high at reset (e.g. tied to VDD), the uM-FPU will be configured as an I2C slave device. Using an I2C interface allows the uM-FPU to share the I2C bus with other peripheral chips.  The connection diagram is shown below. </P><Sect><H5>I2C Connection </H5><P>VDD </P><P><Figure><ImageData src="images/fpu_ic_micromega_uMFPU_img_26.jpg"/></Figure>4.7K 4.7KMicrocontroller Pins </P><P>P0 (default) SCL </P><P>P1 (default) SDA </P><P>VDD VDD </P><P>uM-FPU V3</P><P>Note: SCL and SDA </P><P>must have pull-up </P><P>181 /MCLR AVDD </P><P>resistors as required 2 </P><P>17 </P><P>AN0 AVSS 16</P><P>by the I2C bus. 3 </P><P>AN1 SCLK 4 </P><P>15 </P><P>CS OUT0 5 </P><P>14 </P><P>EXTIN VDD 6 </P><P>13 </P><P>OSC1 VSS 7 </P><P>12 </P><P>OSC2 SIN/SDA 8 </P><P>11 </P><P>SEROUT SOUT/SCL 9 </P><P>10 </P><P>SERIN OUT1 </P><Figure><ImageData src="images/fpu_ic_micromega_uMFPU_img_27.jpg"/></Figure><Figure><ImageData src="images/fpu_ic_micromega_uMFPU_img_28.jpg"/></Figure></Sect><Sect><H4 id="LinkTarget_759">I2C Slave Address </H4><P>The slave address is 7 bits long, followed by an 8th bit which specifies whether the master wishes to write to the slave (0), or read from the slave(1).  The default slave address for the uM-FPU is 1100100x (binary). </P><P>• expressed as a 7-bit value, the default slave address is 100 (decimal), or 0x64 (hex). </P><P id="LinkTarget_760">• expressed as a left justified 8-bit value the default slave address is 200 (decimal) or 0xC8 (hex). The slave address can be changed using the built-in serial debug monitor and stored in nonvolatile flash memory. </P></Sect><Sect><H4>I2C Bus Speed </H4><P id="LinkTarget_761">The uM-FPU can handle I2C data speeds up to 400 kHz. </P></Sect><Sect><H4>I2C Data Transfers </H4><P>The following diagrams show the write and read data transfers. A write transfer consists of a slave address, followed by a register address, followed by 0 to n data bytes. A read transfer is normally preceded by a write transfer to select the register to read from. </P></Sect><Sect><H5>I2C Write Data Transfer </H5><P>Slave Register Address Address Data Data </P><Table><TR><TH>S </TH><TH>1100100 </TH><TH>0 </TH><TH>A </TH><TH>aaaaaaaa </TH><TH>A </TH><TH>dddddddd </TH><TH>A </TH><TH>dddddddd </TH><TH>A </TH><TH>P </TH></TR></Table><P><Figure><ImageData src="images/fpu_ic_micromega_uMFPU_img_29.jpg"/></Figure>0 to n data bytes A - ACK/NAK P - Stop Condition S - Start Condition </P><Figure><ImageData src="images/fpu_ic_micromega_uMFPU_img_30.jpg"/></Figure><Table><TR><TH/><TH>Connecting to the uM-FPU V3.1 </TH></TR><TR><TD>Slave Address </TD><TD>I2C Read Data Transfer Data Data </TD><TD/></TR></Table><Table><TR><TH>S </TH><TH>1100100 </TH><TH>1 </TH><TH>A </TH><TH>dddddddd </TH><TH>A </TH><TH>dddddddd </TH><TH>N </TH><TH>P </TH></TR></Table><P><Figure><ImageData src="images/fpu_ic_micromega_uMFPU_img_31.jpg"/></Figure>1 to n data bytes A - ACK N - NAK P - Stop Condition S - Start Condition </P><P>I2C Registers </P><Figure><ImageData src="images/fpu_ic_micromega_uMFPU_img_32.jpg"/></Figure><Table><TR><TH>I2C Register Address</TH><TH>Write </TH><TH>Read </TH></TR><TR><TD>0 </TD><TD>Data </TD><TD>Data / Status </TD></TR><TR><TD>1 </TD><TD>Reset </TD><TD>Buffer Space </TD></TR></Table><Table><TR><TD>Item </TD><TD>Min </TD><TD>Max </TD><TD>Unit </TD></TR><TR><TD>I2C transfer speed </TD><TD/><TD>400 </TD><TD>kHz </TD></TR><TR><TD>Read Delay – normal operation </TD><TD>0 </TD><TD/><TD>usec </TD></TR><TR><TD>Read Delay – debug enabled </TD><TD>0 </TD><TD/><TD>usec </TD></TR></Table></Sect><Sect><H4 id="LinkTarget_762">I2C Reset Operation </H4><P id="LinkTarget_763">The uM-FPU should be reset at the beginning of every program to ensure that the microcontroller and the uM-FPU are synchronized. The uM-FPU is reset by writing a zero byte to I2C register address 1.  A delay of 8 milliseconds is recommended after the reset operation to ensure that the Reset is complete and the uM-FPU is ready to receive commands. All uM-FPU registers are reset to the special value NaN (Not a Number), which is equal to hexadecimal value 0x7FC00000. </P></Sect><Sect><H4>I2C Reading and Writing Data </H4><P id="LinkTarget_764">uM-FPU instructions and data are written to I2C register 0. Reading I2C register 0 will return the next data byte, if data is waiting to be transferred. If no data is waiting to be transferred the Busy/Ready status is returned. A read operation is normally preceded by a write operation to select the I2C register to read from. </P></Sect><Sect><H4>I2C Busy/Ready Status </H4><P id="LinkTarget_765">The Busy/Ready status must always be checked to confirm that the uM-FPU is Ready prior to any read operation. The Busy status is asserted as soon as an instruction byte is received. The Ready status is asserted when both the instruction buffer and trace buffer are empty. If the uM-FPU is Ready, a zero byte is returned. If the uM-FPU is Busy, either executing instructions, or because the debug monitor is active, a 0x80 byte is returned. If more than 256 bytes of data are sent between read operations, the Ready status must also be checked at least once every 256 bytes to ensure that the instruction buffer does not overflow. </P></Sect><Sect><H4>I2C Buffer Space </H4><P id="LinkTarget_766">Reading I2C register 1 will return the number of bytes of free space in the instruction buffer.  This can be used by more advanced interface routines to ensure that the instruction buffer remains fully utilized.  It is only used to determine if there is space to write data to the uM-FPU. The Busy/Ready status must still be used to confirm the Ready status prior to any read operation. </P></Sect><Sect><H4>Read Delay </H4><P>There is a minimum delay (Read Setup Delay) required from the end of a read instruction opcode until the first data byte is ready to be read. The I2C protocol has enough overhead that no additional delay is required. </P></Sect></Sect><Sect><H3 id="LinkTarget_767">Using OUT1 as a Ready/Busy Status </H3><P>By default, the uM-FPU V3.1 chip outputs the Busy/Ready status on the SOUT pin, when the SOUT pin is not being used for data input. Some microcontroller applications are not able to access this pin when the Busy/Ready status is valid. As an alternative, the OUT1 pin can be configured as a Ready/Busy status (note: OUT1 is High for Ready and Low for Busy). This is accomplished by programming bit 6 of mode parameter byte 0. See the section entitled Mode </P><P id="LinkTarget_768">- set mode parameters. When OUT1 is set to output the Ready/Busy status, the SOUT pin will no longer output the Busy/Ready status. The OUT1 pin can also be used as an activity indicator by connected it to an LED with a pull-up resistor. </P></Sect><Sect><H3>Using the SERIN and SEROUT Pins </H3><P>The SERIN and SEROUT pins provide a serial interface for the built-in Debug Monitor, and can also be used for general purpose serial I/O when the Debug Monitor is not being used. The Debug Monitor communicates at 57,600 baud, using 8 data bits, no parity, one stop bit, and no flow control. The Debug Monitor is enabled if the SERIN pin is high when the uM-FPU is Reset. Note: The idle state of an RS-232 connection will assert a high level on the SERIN pin, so provided the uM-FPU is connected to an active idle RS-232 port when the uM-FPU is reset, the Debug Monitor will be enabled. The SEROUT,0 instruction can also be used to enable/disable the Debug Monitor. </P><P>When the Debug Monitor is not being used, the serial I/O pins can be used for other purposes. The SEROUT,0 instruction is used to set the baud rate for the SERIN and SEROUT pins from 300 to 115,200 baud, using 8 data bits, no parity, one stop bit, and no flow control. The SERIN instruction supports reading serial data from the SERIN pin, and the SEROUT instruction supports sending serial data to the SEROUT pin. The uM-FPU V3.1 chip includes support for NMEA sentence parsing, making it easy to connect to a GPS or other NMEA compliant device. The serial output can be used to drive an LCD display or other serial device. </P><P>uM-FPU V3 </P><Figure><ImageData src="images/fpu_ic_micromega_uMFPU_img_33.jpg"/>MAX232 /MCLR AN0 AN1 CS EXTIN OSC1 OSC2 SEROUT SERIN AVDD AVSS SCLK OUT0 VDD VSS SIN/SDA SOUT/SCL OUT1 1 2 3 4 5 6 7 8 9 18 17 16 15 14 13 12 11 10 543219876DB-9 Female </Figure></Sect><Sect><H3 id="LinkTarget_769">Debug Monitor </H3><P>The built-in Debug Monitor provides support for displaying the contents of uM-FPU  registers, tracing the execution of uM-FPU instructions, setting breakpoints for debugging, and programming user functions. Whenever the uM-FPU V3.1 chip is reset and debug mode is enabled, the following message is sent to the serial output (SEROUT pin): </P><P>{RESET} </P><P>Commands are specified by typing an uppercase or lowercase character followed by a return key. The command is not processed (or echoed) until the return key is pressed. Once the return key is pressed, the command prompt and command are displayed, and the command is executed. If the command is not recognized, a question mark is displayed. Special commands are prefixed with a dollar sign. These commands are used to program the user functions and to check the contents of the uM-FPU. They are not generally used when debugging a running application. The $M and $P will reset the uM-FPU on completion. The commands are listed below: </P><Table><TR><TH>B </TH><TD>Break </TD><TD>stop execution after next instruction </TD></TR><TR><TH>E </TH><TD>EEPROM </TD><TD>display EEPROM memory </TD></TR><TR><TH>F </TH><TD>Flash </TD><TD>display Flash stored function memory </TD></TR><TR><TH>G </TH><TD>Go </TD><TD>continue execution </TD></TR><TR><TH>R S </TH><TD>Register String </TD><TD>display registers display string, length and selection point </TD></TR><TR><TH>T </TH><TD>Trace </TD><TD>toggle trace mode on/off </TD></TR><TR><TH>V </TH><TD>Version </TD><TD>display version information </TD></TR><TR><TH>X </TH><TD>Change </TD><TD>displays all register that have changed </TD></TR><TR><TH>/$C </TH><TD>Comment Clock </TD><TD>add comment to debug trace select clock source </TD></TR><TR><TH>$M </TH><TD>Mode </TD><TD>set mode parameters </TD></TR><TR><TH>$P </TH><TD>Program </TD><TD>program user function memory </TD></TR><TR><TH id="LinkTarget_716">$S </TH><TD>Checksum </TD><TD>display checksum value </TD></TR></Table><Sect><H5>Break – stop execution after next instruction</H5><P>The Break command is used to interrupt operation of the uM-FPU. The break will not occur until after the next instruction is executed by the uM-FPU. The debug monitor displays the hex value of the last instruction executed and any additional data. Entering another Break command, or simply pressing the return key, will single step to the next instruction. Entering the Go command will continue execution. Note: the uM-FPU V3 IDE includes a disassembler that translates the trace bytes into a readable instruction sequence. </P><P>{BREAK} &gt;</P><P> 0103 (i.e. SELECTA,3){BREAK} &gt;</P><P> 2001 (i.e. FSET,1){BREAK} &gt;</P><P> 3702 (i.e. FDIVI,2){BREAK} &gt;</P><P> 2403 (i.e. FMUL,3){BREAK} &gt; </P></Sect><Sect><H5 id="LinkTarget_717">EEPROM – display EEPROM memory</H5><P>The EEPROM command displays the contents of the EEPROM memory in Intel Hex format. </P><P id="LinkTarget_718">&gt;E 
:1000000000000000000000000000000000000000F0 
:1000100000000000000000000000000000000000E0 
:100020000000000099000000000000000000000037 
:1000300000000000000000000000000000000000C0 
:100040000102030405060708090A0B0C0000000062 
:1000500007360A33057F1680033301800000000055 
:100060000000000000000000000000000000000090 
:100070000000000000000000000000000000000080 
:10008000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF80 
:10009000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF70 
. 
. 
. 
:1003D000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF2D 
:1003E000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF1D 
:1003F000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0D 
</P></Sect><Sect><H5>Flash – display Flash stored function memory</H5><P>The Flash command displays the contents of the Flash stored function memory in Intel Hex format. </P><P id="LinkTarget_719">&gt;$F 
:10000000000000000100000E010E000801160006AD 
:10001000011C0002011E0006012400050129001731 
:10002000014000120152000D015F0016017500171A 
:10003000018C001701A3000E00000000000000006A 
:1000400000000000000000000000000000000000B0 
:1000500000000000000000000000000000000000A0 
:100060000000000000000000000000000000000090 
:100070000000000000000000000000000000000080 
:100080000000000000000000000000000000000070 
:100090000000000000000000000000000000000060 
:1000A0000000000000000000000000000000000050 
:1000B0000000000000000000000000000000000040 
:1000C0000000000000000000000000000000000030 
:1000D0000000000000000000000000000000000020 
:1000E0000000000000000000000000000000000010 
:1000F0000000000000000000000000000000000000 
:1001000014200124011420022402152A4115142070 
:100110000124022103157E047E05330332017E068D 
. 
. 
. 
:1008D0000000000000000000000000000000000018 
:1008E0000000000000000000000000000000000008 
:1008F00000000000000000000000000010C8000020 
</P><P>Go – continue execution </P><P>The Go command is used to continue normal execution after a Break command. </P><P>&gt;G </P></Sect><Sect><H5 id="LinkTarget_720">Registers – display registers</H5><P>The Register command displays a header line showing the currently selected register A, register X, the internal status value, and if selected, matrix A, B and C. The current contents of all uM-FPU registers are then displayed. </P><P id="LinkTarget_721">&gt;R 
{A=R0, X=R57, S=80, MA=R16:3:3, MB=R32:3:3, MC=R48:3:3
R0:41900000 R1:7FFFFFFF R2:7FFFFFFF R3:7FFFFFFF 
R4:40E00000 R5:BF800000 R6:40800000 R7:00000000 
R8:C0400000 R9:40800000 R10:00000000 R11:41000000 
R12:7FFFFFFF R13:7FFFFFFF R14:7FFFFFFF R15:7FFFFFFF 
R16:40000000 R17:40800000 R18:40C00000 R19:41000000 
R20:41200000 R21:41400000 R22:41600000 R23:41800000 
R24:41900000 R25:7FFFFFFF R26:7FFFFFFF R27:7FFFFFFF 
R28:7FFFFFFF R29:7FFFFFFF R30:7FFFFFFF R31:7FFFFFFF 
R32:40000000 R33:40800000 R34:40C00000 R35:41000000 
R36:41200000 R37:41400000 R38:41600000 R39:41800000 
R40:41900000 R41:7FFFFFFF R42:7FFFFFFF R43:7FFFFFFF 
R44:7FFFFFFF R45:7FFFFFFF R46:7FFFFFFF R47:7FFFFFFF 
R48:40000000 R49:40800000 R50:40C00000 R51:41000000 
R52:41200000 R53:41400000 R54:41600000 R55:41800000 
R56:41900000 R57:7FFFFFFF R58:7FFFFFFF R59:7FFFFFFF 
R60:7FFFFFFF R61:7FFFFFFF R62:7FFFFFFF R63:7FFFFFFF 
R64:7FFFFFFF R65:7FFFFFFF R66:7FFFFFFF R67:7FFFFFFF 
R68:7FFFFFFF R69:7FFFFFFF R70:7FFFFFFF R71:7FFFFFFF 
R72:7FFFFFFF R73:7FFFFFFF R74:7FFFFFFF R75:7FFFFFFF 
R76:7FFFFFFF R77:7FFFFFFF R78:7FFFFFFF R79:7FFFFFFF 
R80:7FFFFFFF R81:7FFFFFFF R82:7FFFFFFF R83:7FFFFFFF 
R84:7FFFFFFF R85:7FFFFFFF R86:7FFFFFFF R87:7FFFFFFF 
R88:7FFFFFFF R89:7FFFFFFF R90:7FFFFFFF R91:7FFFFFFF 
R92:7FFFFFFF R93:7FFFFFFF R94:7FFFFFFF R95:7FFFFFFF 
R96:7FFFFFFF R97:7FFFFFFF R98:7FFFFFFF R99:7FFFFFFF 
R100:7FFFFFFF R101:7FFFFFFF R102:7FFFFFFF R103:7FFFFFFF 
R104:7FFFFFFF R105:7FFFFFFF R106:7FFFFFFF R107:7FFFFFFF 
R108:7FFFFFFF R109:7FFFFFFF R110:7FFFFFFF R111:7FFFFFFF 
R112:7FFFFFFF R113:7FFFFFFF R114:7FFFFFFF R115:7FFFFFFF 
R116:7FFFFFFF R117:7FFFFFFF R118:7FFFFFFF R119:7FFFFFFF 
R120:7FFFFFFF R121:7FFFFFFF R122:7FFFFFFF R123:7FFFFFFF 
R124:7FFFFFFF R125:7FFFFFFF R126:7FFFFFFF R127:7FFFFFFF 
T1:7FFFFFFF T2:7FFFFFFF T3:7FFFFFFF T4:7FFFFFFF 
T5:7FFFFFFF T6:7FFFFFFF T7:7FFFFFFF T8:7FFFFFFF} 
</P></Sect><Sect><H5>String – display string, length and selection point</H5><P>The String command displays the current string buffer and selection point. The string length, selection start point and selection length are displayed, followed by the string. The following example shows an empty string. </P><P>&gt;S 
0,0,0 
</P><P>The following example shows the string buffer after the VERSION instruction has been executed. </P><P>&gt;S 
13,0,13 
uM-FPU V3.1.3 
</P></Sect><Sect><H5 id="LinkTarget_722">Trace – toggle trace mode on/off</H5><P>The Trace command toggles the trace mode. The current state of the trace mode is displayed. When trace mode is on, each instruction that is executed by the uM-FPU is displayed. Note: the uM-FPU V3 IDE includes a disassembler that translates the trace bytes into a readable instruction sequence. </P><P>&gt;T 
{TRACE ON}
</P><P> 0101 5E 29 3600 3714 47 0102 2001 360A 53 61 97:00 0101 1F55 F2&quot; 0.00 000&quot; 0101 5E 29 3602 3714 47 0102 2001 360A 53 61 97:03 0101 1F55 F2&quot; 0.30902&quot; 0101 5E 29 3604 3714 47 0102 2001 360A 53 61 97:06 0101 1F55 F2&quot; 0.58779&quot; 0101 5E 29 3606 3714 47 0102 2001 360A 53 61 97:08 0101 1 F55 F2&quot; 0.80902&quot; 0101 5E 29 3608 3714 47 0102 2001 360A 53 61 97:0A 01 01 1F55 F2&quot; 0.95106&quot; 0101 5E 29 360A 3714 47 0102 2001 360A 53 61 97:0 A 0101 1F55 F2&quot; 1.00000&quot; 0101 5E 29 360C 3714 47 0102 2001 360A 53 61 97:0A 0101 1F55 F2&quot; 0.95106&quot; 0101 5E 29 360E 3714 47 0102 2001 360A 53</P><P id="LinkTarget_723"> 61 97:08 0101 1F55 F2&quot; 0.80902&quot; 0101 5E 29 3610 3714 47 0102 2001 360 A 53 61 97:06 0101 1F55 F2&quot; 0.58779&quot; &gt;T {TRACE OFF} </P></Sect><Sect><H5>Version – display version information</H5><P>The Version command displays the version string for the uM-FPU chip, the currently selected interface, and the current clock speed.  If the selected interface is I2C the device address is also shown. </P><P>&gt;V 
uM-FPU V3.1.3, SPI 29.48 MHz 
</P><P id="LinkTarget_724">&gt;V 
uM-FPU V3.1.3, I2C C8 29.48 MHz 
</P></Sect><Sect><H5>Change – display changed registers</H5><P>The Change command displays a header line showing the currently selected register A, register X, the internal status value, and if selected, matrix A, B and C. The current contents of all uM-FPU registers that have changed since the last Change command (or Reset) are then displayed. </P><P>&gt;X 
{A=R0, X=R57, S=80, MA=R16:3:3, MB=R32:3:3, MC=R48:3:3
R0:41900000 R4:40E00000 R5:BF800000 R6:40800000 
R7:00000000 R8:C0400000 R9:40800000 R10:00000000 
R11:41000000 R16:40000000 R17:40800000 R18:40C00000 
R19:41000000 R20:41200000 R21:41400000 R22:41600000 
R23:41800000 R24:41900000 R32:40000000 R33:40800000 
R34:40C00000 R35:41000000 R36:41200000 R37:41400000 
R38:41600000 R39:41800000 R40:41900000 R48:40000000 
R49:40800000 R50:40C00000 R51:41000000 R52:41200000 
R53:41400000 R54:41600000 R55:41800000 R56:41900000} 
</P><P id="LinkTarget_725">&gt;X 
{A=R0, X=R57, S=80, MA=R16:3:3, MB=R32:3:3, MC=R48:3:3} 
</P></Sect><Sect><H5>Comment – add comment to debug trace</H5><P>The comment command is used to insert short comment strings (up to six characters) in the debug session. This can be useful to provide some notations to refer to when analyzing debug results. </P><P>&gt;/test1 </P></Sect><Sect><H5 id="LinkTarget_726">Clock – select clock source </H5><P>The Clock command allows you to change the clock source. The default clock speed is 29.48 MHz using an internal oscillator which provides the maximum execution speed. The clock speed would only need to be changed for special circumstances such as low-power applications (e.g. 14.74 MHz for 3.3V operating voltage - see Absolute Ratings). The clock source is stored in Flash memory as part of the device configuration bits. The clock selection indicates the clock source to use at power-up. If the selected clock source can’t be validated at power-up, the uM-FPU V3.1 chip will fall back to an internal clock speed of 1.8425 MHz. The available clock speeds and clock sources are selected by entering one of the following values: </P><Table><TR><TH>Value </TH><TH>Clock Speed </TH><TH>Clock Source </TH></TR><TR><TD>20 </TD><TD>1.8425 MHz </TD><TD>internal oscillator </TD></TR><TR><TD>E1 </TD><TD>7.37 MHz </TD><TD>internal oscillator </TD></TR><TR><TD>EA </TD><TD>14.74 MHz </TD><TD>internal oscillator </TD></TR><TR><TD>E3 </TD><TD>29.48 MHz </TD><TD>internal oscillator (default clock speed) </TD></TR><TR><TD>E5 </TD><TD>10.0 MHz </TD><TD>external 10.0 MHz crystal </TD></TR><TR><TD>E6 </TD><TD>20.0 MHz </TD><TD>external 10.0 MHz crystal </TD></TR><TR><TD>E7 </TD><TD>29.4912 MHz </TD><TD>external 7.3728 MHz crystal </TD></TR></Table><P>The following example changes the clock selection from 29.48 MHz to 14.74 MHz. </P><P>&gt;$C E3 :EA </P><P>Note: It may be necessary to power the chip off and back on before the new clock source will take effect since some clock sources use an internal PLL that only resets at power up. You can check the clock speed that the chip is currently running at by using the Version command. </P></Sect><Sect><H5 id="LinkTarget_727">Checksum – display checksum value</H5><P>The Checksum command displays a checksum for the uM-FPU V3.1 program code and user-defined functions stored in Flash. This can be used to check that the chip is valid, or that a particular set of user-defined functions is installed. </P><P>&gt;$S:001AB76A </P></Sect><Sect><H5 id="LinkTarget_728">Mode – set mode parameters</H5><P>The Mode command is used to set the four interface mode parameter bytes that are stored in Flash memory. The factory setting of the parameter bytes is all zeros.  The parameter bytes are read at reset to determine the mode of operation. The mode command displays the current parameter values and the user is prompted to enter new values. (The values are entered as hexadecimal values.) The new values are programmed into Flash memory and the uM-FPU is Reset. </P><P>&gt;$M</P><P> 00000000 </P><P>:00CA0000 </P><P>Two hexadecimal digits represent each parameter byte. The mode parameter bytes are interpreted as follows: </P><P>Byte 0: </P><P>Bit7 6 5 4 3 2 1 0 </P><Table><TR><TH>B </TH><TH>R </TH><TH>T </TH><TH>I </TH><TH>S </TH><TH>P </TH><TH>Mode </TH></TR></Table><P>Bit 7 Break on Reset (if debug mode is enabled) 
Bit 6 use OUT1 pin for Ready/Busy status 
Bit 5 Trace on Reset (if debug mode is enabled) 
Bit 4 Idle Mode power saving enabled 
Bit 3 Sleep Mode power saving enabled 
Bit 2 PIC mode enabled (see PICMODE instruction) 
Bits 1:0 Mode 
</P><P>00 – CS pin determines interface mode (default) 
if CS pin = Low, SPI mode selected 
if CS pin = High, I2C mode selected 
</P><P>01 – I2C mode selected 
1x – SPI mode selected (CS pin used as chip select) 
</P><P>Byte 1: 	I2C Address (if zero, the default address (0xC8) is used. The 7-bit address is entered as a left justified 8-bit value. The last bit is ignored. </P><P>Byte 2: 	Auto-Start Function Mode parameter byte 2 specifies a user-defined function that can optionally be called when the chip is Reset. Mode parameter byte 2 is only checked at Reset if the CS pin is Low. If both the CS pin and SERIN pin are High at Reset, Debug Mode will always be entered. To use auto-start with the I2C interface, the CS pin must be Low at Reset, and the I2C mode must be selected using mode 01 in mode parameter byte 0. </P><P>Bit7 6 5 4 3 2 1 0 </P><Table><TR><TH>D </TH><TH>F </TH><TH>Function </TH></TR></Table><P>Bit 7 	Debug mode </P><P>0 - use SERIN to select debug mode </P><P>SERIN = Low, Disable debug mode </P><P>SERIN = High, Enable debug mode </P><P>1 - Disable debug mode </P><P>Bit 6 	Auto-start function call </P><P>0 - No function called </P><P>1 - Call the function specified by bits 5:0 </P><P>Bit 5:0 	Function number </P><P>Byte 3: 	reserved </P></Sect><Sect><H5 id="LinkTarget_729">Program – program user function memory</H5><P>The Program command is used to program the user function memory. Once in program mode, the uM-FPU looks for valid Intel Hex format records. The records must have an address between 0x0000 and 0x08F0, start on a 64-byte boundary, and have a length of 1 to 64 bytes. The data is not echoed, but an acknowledge character is sent after each record. The acknowledge characters are as follows: </P><P>+ The record was programmed successfully. 
F A format error occurred. 
A An address error occurred. 
C A checksum error occurred. 
P A programming error occurred. 
</P><P>The uM-FPU IDE program (or another PC based application program) would normally be used to send the required data for the program command. (See documentation for the uM-FPU IDE application program.) To exit the program mode, an escape character is sent. The program command will reset the uM-FPU on exit. </P><P>&gt;$P 
{*** PROGRAM MODE ***} 
+++ 
</P><P>{RESET} </P></Sect></Sect><Sect><H3 id="LinkTarget_770">Debug Instructions </H3><P id="LinkTarget_730">There are several instructions that are designed to work in conjunction with the debug monitor. If the debug monitor is not enabled, these commands are NOPs. The instructions are as follows: </P><Sect><H5>BREAK </H5><P id="LinkTarget_731">When the BREAK instruction is encountered, execution stops, and the debug monitor is entered. Execution will only resume when a Go command is issued entered with the debug monitor. </P></Sect><Sect><H5>TRACEOFF </H5><P id="LinkTarget_732">Turns the debug trace mode off. </P></Sect><Sect><H5>TRACEON </H5><P id="LinkTarget_733">Turns the debug trace mode on. All instructions will be traced on the debug terminal until the trace mode is turned off by a TRACEOFF instruction or is turned off using the debug monitor. </P></Sect><Sect><H5>TRACESTR </H5><P id="LinkTarget_734">Displays a trace string to the debug monitor output. This can be useful for keeping track of a debug session. Trace strings are always output; they are not affected by the trace mode. </P></Sect><Sect><H5>TRACEREG </H5><P>Displays a trace string with the value of the register to the debug monitor output. Trace registers are always output; they are not affected by the trace mode. </P></Sect></Sect><Sect><H3 id="LinkTarget_771">Flash Memory </H3><P>There are 2304 bytes of Flash memory reserved on the uM-FPU for storing user-defined functions and the mode parameters. Up to 64 user-defined functions can be stored in Flash memory. User-defined functions have the advantage of conserving space on the microcontroller and greatly reducing the communications overhead between the microcontroller and the uM-FPU. In addition, certain instructions (e.g. BRA, JMP, TABLE, POLY) are only valid in user-defined functions. The FCALL instruction is used to call the user-defined functions stored in Flash memory. The Busy condition remains set while all of the instructions in the called function execute. </P><P>Flash memory for user-defined functions is divided into two sections: the header section and the data section. The header section is located at program address 0x0000 and consists of 64 pairs of 16-bit words (256 bytes) that specify the offset to the data section and the length of the stored function. The data section consists of 2048 bytes and contains the user-defined function code. User-defined functions stored in Flash memory are programmed using the serial debug monitor.  The uM-FPU V3 IDE (Integrated Development Environment) provides support for defining and programming user-defined functions. (Refer to uM-FPU V3 IDE documentation.) </P><P>Flash Memory Layout </P><P>... </P><P>... </P><P>0000 Header </P><Table><TR><TD>Offset 0 </TD><TD>Size 0 </TD><TD>Offset 1 </TD><TD>Size 1 </TD><TD/><TD/><TD>Offset 2 </TD><TD>Size 2 </TD><TD>Offset 3 </TD><TD>Size 3 </TD></TR><TR><TD>Offset 4 </TD><TD>Size 4 </TD><TD/><TD/><TD/><TD/><TD/><TD/><TD/></TR></Table><Table><TR><TH/><TH/><TH/><TH/><TH/><TH>Offset </TH><TH>Size </TH></TR><TR><TH/><TD/><TD/><TD/><TD/><TD>59 </TD><TD>59 </TD></TR><TR><TH>Offset </TH><TD>Size </TD><TD>Offset </TD><TD>Size </TD><TD>Offset </TD><TD>Size </TD><TD>Offset </TD><TD>Size </TD></TR><TR><TH>60 </TH><TD>60 </TD><TD>61 </TD><TD>61 </TD><TD>62 </TD><TD>62 </TD><TD>63 </TD><TD>63 </TD></TR><TR><TH>Data </TH><TD>Data </TD><TD>Data </TD><TD>Data </TD><TD>Data </TD><TD>Data </TD><TD>Data </TD><TD>Data </TD><TD>Data </TD><TD>Data </TD><TD>Data </TD><TD>Data </TD><TD>Data </TD><TD>Data </TD><TD>Data </TD><TD>Data </TD></TR><TR><TH>0 </TH><TD>1 </TD><TD>2 </TD><TD>3 </TD><TD>4 </TD><TD>5 </TD><TD>6 </TD><TD>7 </TD><TD>8 </TD><TD>9 </TD><TD>10 </TD><TD>11 </TD><TD>12 </TD><TD>13 </TD><TD>14 </TD><TD>15 </TD></TR><TR><TH>Data 16 </TH><TD>Data 17 </TD><TD>Data 18 </TD><TD/><TD/><TD/><TD/><TD/><TD/></TR></Table><Figure><ImageData src="images/fpu_ic_micromega_uMFPU_img_34.jpg"/></Figure><P>00FF 0100 </P><P>Data 08FF </P><Figure><ImageData src="images/fpu_ic_micromega_uMFPU_img_35.jpg"/></Figure><Table><TR><TH/><TH/><TH/><TH/><TH/><TH/><TH/><TH/><TH/><TH/><TH/><TH/><TH>Data </TH><TH>Data </TH><TH>Data </TH></TR><TR><TD/><TD/><TD/><TD/><TD/><TD/><TD/><TD/><TD/><TD/><TD/><TD/><TD>2029 </TD><TD>2030 </TD><TD>2031 </TD></TR><TR><TD>Data </TD><TD>Data </TD><TD>Data </TD><TD>Data </TD><TD>Data </TD><TD>Data </TD><TD>Data </TD><TD>Data </TD><TD>Data </TD><TD>Data </TD><TD>Data </TD><TD>Data </TD><TD>Mode </TD><TD>Mode </TD><TD>Mode </TD><TD>Mode </TD></TR><TR><TD>2032 </TD><TD>2033 </TD><TD>2034 </TD><TD>2035 </TD><TD>2036 </TD><TD>2037 </TD><TD>2038 </TD><TD>2039 </TD><TD>2040 </TD><TD>2041 </TD><TD>2042 </TD><TD>2043 </TD><TD>0 </TD><TD>1 </TD><TD>2 </TD><TD>3 </TD></TR></Table></Sect><Sect><H3 id="LinkTarget_772">EEPROM Memory </H3><P>There are 1024 bytes of EEPROM memory reserved on the uM-FPU for storing user-defined functions and data.  The EESAVE, EESAVEA, EELOAD, EELOADA instructions are used to store and retrieve data. The EEWRITE instruction is used to store user-defined functions at run-time. The ECALL instruction is used to call the user-defined functions stored in EEPROM memory. The Busy condition remains set while all of the instructions in the called function execute. When storing a user-defined function in EEPROM, the first byte of an EEPROM slot must contain the length of the user-defined function, and the last byte must be a RET instruction. This is used as a validity check for user-defined functions before the code stored in EEPROM is executed. User-defined functions in EEPROM are restricted to a total length of 256 bytes. Care should be taken to keep track of how much space is used by a user-defined functions so that it doesn’t overlap any slots used for data storage. </P><P>EEPROM Memory Layout </P><Table><TR><TH>0100 </TH><TD>EEPROM slot 0 </TD><TD>EEPROM slot 1 </TD><TD/><TD>EEPROM slot 2 </TD><TD>EEPROM slot 3 </TD></TR><TR><TH/><TD>EEPROM slot 4 </TD><TD/><TD>. </TD><TD/><TD/></TR><TR><TH/><TD/><TD/><TD>. . </TD><TD/><TD>EEPROM slot 251 </TD></TR><TR><TH>03FF </TH><TD>EEPROM slot 252 </TD><TD>EEPROM slot 253 </TD><TD/><TD>EEPROM slot 254 </TD><TD>EEPROM slot 255 </TD></TR></Table></Sect><Sect><H3 id="LinkTarget_773">PDIP-18 Through-Hole Package 
</H3><Figure><ImageData src="images/fpu_ic_micromega_uMFPU_img_36.jpg"/></Figure></Sect><Sect><H3 id="LinkTarget_774">SOIC-18 Surface Mount Package 
</H3><Figure><ImageData src="images/fpu_ic_micromega_uMFPU_img_37.jpg"/></Figure></Sect><Sect><H3 id="LinkTarget_775">QFN-44 Surface Mount Package 
</H3><Figure><ImageData src="images/fpu_ic_micromega_uMFPU_img_38.jpg"/></Figure></Sect><Sect><H3 id="LinkTarget_776">Absolute Maximum Ratings </H3><Table><TR><TH id="LinkTarget_735">Parameter </TH><TH id="LinkTarget_736">Minimum </TH><TH id="LinkTarget_737">Typical </TH><TH id="LinkTarget_738">Maximum </TH><TH id="LinkTarget_739">Units </TH></TR><TR><TD>Storage Temperature </TD><TD>-65 </TD><TD>-</TD><TD>+150 </TD><TD>° Celsius </TD></TR><TR><TD>Ambient Temperature with Power Applied</TD><TD>-40 </TD><TD>-</TD><TD>+85 </TD><TD>° Celsius </TD></TR><TR><TD>Supply Voltage on VDD relative to VSS </TD><TD>-0.3 </TD><TD>-</TD><TD>+5.5 </TD><TD>V </TD></TR><TR><TD>Input Voltage relative to VSS</TD><TD>-0.3 </TD><TD>-</TD><TD>VDD+0.3 </TD><TD>V </TD></TR><TR><TD>Maximum Current out of VSS pin </TD><TD/><TD/><TD>300 </TD><TD>mA </TD></TR><TR><TD>Maximum Current into VDD pin</TD><TD/><TD/><TD>250 </TD><TD>mA </TD></TR><TR><TD>Maximum Current sourced by any I/O pin </TD><TD/><TD/><TD>25 </TD><TD>mA </TD></TR><TR><TD>Maximum Current sinked by any I/O pin</TD><TD/><TD/><TD>25 </TD><TD>mA </TD></TR><TR><TD>Maximum Current sourced by all I/O pins </TD><TD/><TD/><TD>200 </TD><TD>mA </TD></TR><TR><TD>Maximum Current sinked by all I/O pins</TD><TD/><TD/><TD>200 </TD><TD>mA </TD></TR><TR><TD>Recommended Impedance of AnalogVoltage Source </TD><TD/><TD/><TD>2.5 </TD><TD>Ω </TD></TR></Table></Sect><Sect><H3 id="LinkTarget_777">DC Characteristics 
</H3><Table><TR><TH id="LinkTarget_740">Parameter </TH><TH id="LinkTarget_741">Minimum </TH><TH id="LinkTarget_742">Typical </TH><TH id="LinkTarget_743">Maximum </TH><TH id="LinkTarget_744">Units </TH></TR><TR><TD>I/O Pin Input Low Voltage </TD><TD>VSS </TD><TD>-</TD><TD>0.2 VDD </TD><TD>V </TD></TR><TR><TD>I/O Pin Input High Voltage</TD><TD>0.8 VDD </TD><TD>-</TD><TD>VDD </TD><TD>V </TD></TR><TR><TD>AVDD </TD><TD>greater ofVDD - 0.3 or 2.7 </TD><TD/><TD>lesser of VDD + 0.3 or 5.5 </TD><TD>V </TD></TR><TR><TD>AVSS </TD><TD>VSS - 0.3 </TD><TD/><TD>VSS + 0.3 </TD><TD/></TR><TR><TD>Operating MIPS at 4.5 to 5.5 VDD</TD><TD/><TD/><TD>30 </TD><TD>MIPS </TD></TR><TR><TD>Operating MIPS at 3.0 to 3.6 VDD </TD><TD/><TD/><TD>15 </TD><TD>MIPS </TD></TR><TR><TD>Operating MIPS at 2.5 to 3 VDD</TD><TD/><TD/><TD>7.5 </TD><TD>MIPS </TD></TR><TR><TD>Recommended 5V Operating Range(VDD)</TD><TD>4.75 </TD><TD>-</TD><TD>5.25 </TD><TD>V </TD></TR><TR><TD>Supply Current </TD><TD>-</TD><TD>Note 1 </TD><TD>-</TD><TD>mA </TD></TR></Table><P id="LinkTarget_778">Note 1: See Application Note 43 - Speed and Power Considerations for uM-FPU V3 </P></Sect><Sect><H3>Further Information </H3><P>Check the Micromega website at <Link><Link>www</Link>.micromegacorp.com </Link></P><Table><TR><TH>Appendix A - Instruction Summary </TH></TR><TR><TH id="LinkTarget_779">Appendix AuM-FPU V3.1 Instruction Summary </TH></TR><TR><TH>Instruction </TH><TD>Opcode </TD><TD>Arguments </TD><TD>Returns </TD><TD>Description </TD></TR></Table><Table><TR><TD>NOP </TD><TD>00 </TD><TD/><TD/><TD>No Operation</TD></TR><TR><TD>SELECTA </TD><TD>01 </TD><TD>nn </TD><TD/><TD>Select register A</TD></TR><TR><TD>SELECTX </TD><TD>02 </TD><TD>nn </TD><TD/><TD>Select register X</TD></TR><TR><TD>CLR </TD><TD>03 </TD><TD>nn </TD><TD/><TD>reg[nn] = 0</TD></TR><TR><TD>CLRA </TD><TD>04 </TD><TD/><TD/><TD>reg[A] = 0</TD></TR><TR><TD>CLRX </TD><TD>05 </TD><TD/><TD/><TD>reg[X] = 0, X = X + 1</TD></TR><TR><TD>CLR0 </TD><TD>06 </TD><TD/><TD/><TD>reg[0] = 0</TD></TR><TR><TD>COPY </TD><TD>07 </TD><TD>mm,nn </TD><TD/><TD>reg[nn] = reg[mm]</TD></TR><TR><TD>COPYA </TD><TD>08 </TD><TD>nn </TD><TD/><TD>reg[nn] = reg[A]</TD></TR><TR><TD>COPYX </TD><TD>09 </TD><TD>nn </TD><TD/><TD>reg[nn] = reg[X], X = X + 1</TD></TR><TR><TD>LOAD </TD><TD>0A </TD><TD>nn </TD><TD/><TD>reg[0] = reg[nn]</TD></TR><TR><TD>LOADA </TD><TD>0B </TD><TD/><TD/><TD>reg[0] = reg[A]</TD></TR><TR><TD>LOADX </TD><TD>0C </TD><TD/><TD/><TD>reg[0] = reg[X], X = X + 1</TD></TR><TR><TD>ALOADX </TD><TD>0D </TD><TD/><TD/><TD>reg[A] = reg[X], X = X + 1</TD></TR><TR><TD>XSAVE </TD><TD>0E </TD><TD>nn </TD><TD/><TD>reg[X] = reg[nn], X = X + 1</TD></TR><TR><TD>XSAVEA </TD><TD>0F </TD><TD/><TD/><TD>reg[X] = reg[A], X = X + 1</TD></TR><TR><TD>COPY0 </TD><TD>10 </TD><TD>nn </TD><TD/><TD>reg[nn] = reg[0]</TD></TR><TR><TD>COPYI </TD><TD>11 </TD><TD>bb,nn </TD><TD/><TD>reg[nn] = long(unsigned byte bb)</TD></TR><TR><TD>SWAP </TD><TD>12 </TD><TD>nn,mm </TD><TD/><TD>Swap reg[nn] and reg[mm]</TD></TR><TR><TD>SWAPA </TD><TD>13 </TD><TD>nn </TD><TD/><TD>Swap reg[nn] and reg[A] </TD></TR><TR><TD>LEFT </TD><TD>14 </TD><TD/><TD/><TD>Left parenthesis </TD></TR><TR><TD>RIGHT </TD><TD>15 </TD><TD/><TD/><TD>Right parenthesis</TD></TR><TR><TD>FWRITE </TD><TD>16 </TD><TD>nn,b1,b2,b3,b4 </TD><TD/><TD>Write 32-bit ﬂoating point to reg[nn]</TD></TR><TR><TD>FWRITEA </TD><TD>17 </TD><TD>b1,b2,b3,b4 </TD><TD/><TD>Write 32-bit ﬂoating point to reg[A]</TD></TR><TR><TD>FWRITEX </TD><TD>18 </TD><TD>b1,b2,b3,b4 </TD><TD/><TD>Write 32-bit ﬂoating point to reg[X]</TD></TR><TR><TD>FWRITE0 </TD><TD>19 </TD><TD>b1,b2,b3,b4 </TD><TD/><TD>Write 32-bit ﬂoating point to reg[0]</TD></TR><TR><TD>FREAD </TD><TD>1A </TD><TD>nn </TD><TD>b1,b2,b3,b4 </TD><TD>Read 32-bit ﬂoating point from reg[nn]</TD></TR><TR><TD>FREADA </TD><TD>1B </TD><TD/><TD>b1,b2,b3,b4 </TD><TD>Read 32-bit ﬂoating point from reg[A]</TD></TR><TR><TD>FREADX </TD><TD>1C </TD><TD/><TD>b1,b2,b3,b4 </TD><TD>Read 32-bit ﬂoating point from reg[X]</TD></TR><TR><TD>FREAD0 </TD><TD>1D </TD><TD/><TD>b1,b2,b3,b4 </TD><TD>Read 32-bit ﬂoating point from reg[0]</TD></TR><TR><TD>ATOF </TD><TD>1E </TD><TD>aa…00 </TD><TD/><TD>Convert ASCII to ﬂoating point</TD></TR><TR><TD>FTOA </TD><TD>1F </TD><TD>bb </TD><TD/><TD>Convert ﬂoating point to ASCII</TD></TR><TR><TD>FSET </TD><TD>20 </TD><TD>nn </TD><TD/><TD>reg[A] = reg[nn]</TD></TR><TR><TD>FADD </TD><TD>21 </TD><TD>nn </TD><TD/><TD>reg[A] = reg[A] + reg[nn]</TD></TR><TR><TD>FSUB </TD><TD>22 </TD><TD>nn </TD><TD/><TD>reg[A] = reg[A] - reg[nn]</TD></TR><TR><TD>FSUBR </TD><TD>23 </TD><TD>nn </TD><TD/><TD>reg[A] = reg[nn] - reg[A]</TD></TR><TR><TD>FMUL </TD><TD>24 </TD><TD>nn </TD><TD/><TD>reg[A] = reg[A] * reg[nn]</TD></TR><TR><TD>FDIV </TD><TD>25 </TD><TD>nn </TD><TD/><TD>reg[A] = reg[A] / reg[nn]</TD></TR><TR><TD>FDIVR </TD><TD>26 </TD><TD>nn </TD><TD/><TD>reg[A] = reg[nn] / reg[A]</TD></TR><TR><TD>FPOW </TD><TD>27 </TD><TD>nn </TD><TD/><TD>reg[A] = reg[A] ** reg[nn] </TD></TR><TR><TD>FCMP </TD><TD>28 </TD><TD>nn </TD><TD/><TD>Compare reg[A], reg[nn],Set ﬂoating point status </TD></TR><TR><TD>FSET0 </TD><TD>29 </TD><TD/><TD/><TD>reg[A] = reg[0]</TD></TR><TR><TD>FADD0 </TD><TD>2A </TD><TD/><TD/><TD>reg[A] = reg[A] + reg[0] </TD></TR></Table><Table><TR><TD>FSUB0 </TD><TD>2B </TD><TD/><TD/><TD>reg[A] = reg[A] - reg[0]</TD></TR><TR><TD>FSUBR0 </TD><TD>2C </TD><TD/><TD/><TD>reg[A] = reg[0] - reg[A]</TD></TR><TR><TD>FMUL0 </TD><TD>2D </TD><TD/><TD/><TD>reg[A] = reg[A] * reg[0]</TD></TR><TR><TD>FDIV0 </TD><TD>2E </TD><TD/><TD/><TD>reg[A] = reg[A] / reg[0]</TD></TR><TR><TD>FDIVR0 </TD><TD>2F </TD><TD/><TD/><TD>reg[A] = reg[0] / reg[A]</TD></TR><TR><TD>FPOW0 </TD><TD>30 </TD><TD/><TD/><TD>reg[A] = reg[A] ** reg[0]</TD></TR><TR><TD>FCMP0 </TD><TD>31 </TD><TD/><TD/><TD>Compare reg[A], reg[0],Set ﬂoating point status</TD></TR><TR><TD>FSETI </TD><TD>32 </TD><TD>bb </TD><TD/><TD>reg[A] = ﬂoat(bb)</TD></TR><TR><TD>FADDI </TD><TD>33 </TD><TD>bb </TD><TD/><TD>reg[A] = reg[A] - ﬂoat(bb) </TD></TR><TR><TD>FSUBI </TD><TD>34 </TD><TD>bb </TD><TD/><TD>reg[A] = reg[A] - ﬂoat(bb)</TD></TR><TR><TD>FSUBRI </TD><TD>35 </TD><TD>bb </TD><TD/><TD>reg[A] = ﬂoat(bb) - reg[A]</TD></TR><TR><TD>FMULI </TD><TD>36 </TD><TD>bb </TD><TD/><TD>reg[A] = reg[A] * ﬂoat(bb)</TD></TR><TR><TD>FDIVI </TD><TD>37 </TD><TD>bb </TD><TD/><TD>reg[A] = reg[A] / ﬂoat(bb)</TD></TR><TR><TD>FDIVRI </TD><TD>38 </TD><TD>bb </TD><TD/><TD>reg[A] = ﬂoat(bb) / reg[A]</TD></TR><TR><TD>FPOWI </TD><TD>39 </TD><TD>bb </TD><TD/><TD>reg[A] = reg[A] ** bb</TD></TR><TR><TD>FCMPI </TD><TD>3A </TD><TD>bb </TD><TD/><TD>Compare reg[A], ﬂoat(bb),Set ﬂoating point status</TD></TR><TR><TD>FSTATUS </TD><TD>3B </TD><TD>nn </TD><TD/><TD>Set ﬂoating point status for reg[nn] </TD></TR><TR><TD>FSTATUSA </TD><TD>3C </TD><TD/><TD/><TD>Set ﬂoating point status for reg[A] </TD></TR><TR><TD>FCMP2 </TD><TD>3D </TD><TD>nn,mm </TD><TD/><TD>Compare reg[nn], reg[mm]Set ﬂoating point status</TD></TR><TR><TD>FNEG </TD><TD>3E </TD><TD/><TD/><TD>reg[A] = -reg[A]</TD></TR><TR><TD>FABS </TD><TD>3F </TD><TD/><TD/><TD>reg[A] = | reg[A] |</TD></TR><TR><TD>FINV </TD><TD>40 </TD><TD/><TD/><TD>reg[A] = 1 / reg[A]</TD></TR><TR><TD>SQRT </TD><TD>41 </TD><TD/><TD/><TD>reg[A] = sqrt(reg[A])</TD></TR><TR><TD>ROOT </TD><TD>42 </TD><TD>nn </TD><TD/><TD>reg[A] = root(reg[A], reg[nn])</TD></TR><TR><TD>LOG </TD><TD>43 </TD><TD/><TD/><TD>reg[A] = log(reg[A])</TD></TR><TR><TD>LOG10 </TD><TD>44 </TD><TD/><TD/><TD>reg[A] = log10(reg[A])</TD></TR><TR><TD>EXP </TD><TD>45 </TD><TD/><TD/><TD>reg[A] = exp(reg[A])</TD></TR><TR><TD>EXP10 </TD><TD>46 </TD><TD/><TD/><TD>reg[A] = exp10(reg[A])</TD></TR><TR><TD>SIN </TD><TD>47 </TD><TD/><TD/><TD>reg[A] = sin(reg[A])</TD></TR><TR><TD>COS </TD><TD>48 </TD><TD/><TD/><TD>reg[A] = cos(reg[A])</TD></TR><TR><TD>TAN </TD><TD>49 </TD><TD/><TD/><TD>reg[A] = tan(reg[A])</TD></TR><TR><TD>ASIN </TD><TD>4A </TD><TD/><TD/><TD>reg[A] = asin(reg[A])</TD></TR><TR><TD>ACOS </TD><TD>4B </TD><TD/><TD/><TD>reg[A] = acos(reg[A])</TD></TR><TR><TD>ATAN </TD><TD>4C </TD><TD/><TD/><TD>reg[A] = atan(reg[A])</TD></TR><TR><TD>ATAN2 </TD><TD>4D </TD><TD>nn </TD><TD/><TD>reg[A] = atan2(reg[A], reg[nn])</TD></TR><TR><TD>DEGREES </TD><TD>4E </TD><TD/><TD/><TD>reg[A] = degrees(reg[A])</TD></TR><TR><TD>RADIANS </TD><TD>4F </TD><TD/><TD/><TD>reg[A] = radians(reg[A])</TD></TR><TR><TD>FMOD </TD><TD>50 </TD><TD>nn </TD><TD/><TD>reg[A] = reg[A] MOD reg[nn] </TD></TR><TR><TD>FLOOR </TD><TD>51 </TD><TD/><TD/><TD>reg[A] = ﬂoor(reg[A]) </TD></TR><TR><TD>CEIL </TD><TD>52 </TD><TD/><TD/><TD>reg[A] = ceil(reg[A])</TD></TR><TR><TD>ROUND </TD><TD>53 </TD><TD/><TD/><TD>reg[A] = round(reg[A])</TD></TR><TR><TD>FMIN </TD><TD>54 </TD><TD>nn </TD><TD/><TD>reg[A] = min(reg[A], reg[nn]) </TD></TR><TR><TD>FMAX </TD><TD>55 </TD><TD>nn </TD><TD/><TD>reg[A] = max(reg[A], reg[nn]) </TD></TR><TR><TD>FCNV </TD><TD>56 </TD><TD>bb </TD><TD/><TD>reg[A] = conversion(bb, reg[A])</TD></TR><TR><TD>FMAC </TD><TD>57 </TD><TD>nn,mm </TD><TD/><TD>reg[A] = reg[A] + (reg[nn] * reg[mm])</TD></TR><TR><TD>FMSC </TD><TD>58 </TD><TD>nn,mm </TD><TD/><TD>reg[A] = reg[A] - (reg[nn] * reg[mm]) </TD></TR></Table><Table><TR><TD>LOADBYTE </TD><TD>59 </TD><TD>bb </TD><TD/><TD>reg[0] = ﬂoat(signed bb)</TD></TR><TR><TD>LOADUBYTE </TD><TD>5A </TD><TD>bb </TD><TD/><TD>reg[0] = ﬂoat(unsigned byte)</TD></TR><TR><TD>LOADWORD </TD><TD>5B </TD><TD>b1,b2 </TD><TD/><TD>reg[0] = ﬂoat(signed b1*256 + b2)</TD></TR><TR><TD>LOADUWORD </TD><TD>5C </TD><TD>b1,b2 </TD><TD/><TD>reg[0] = ﬂoat(unsigned b1*256 + b2)</TD></TR><TR><TD>LOADE </TD><TD>5D </TD><TD/><TD/><TD>reg[0] = 2.7182818</TD></TR><TR><TD>LOADPI </TD><TD>5E </TD><TD/><TD/><TD>reg[0] = 3.1415927</TD></TR><TR><TD>LOADCON </TD><TD>5F </TD><TD>bb </TD><TD/><TD>reg[0] = ﬂoat constant(bb)</TD></TR><TR><TD>FLOAT </TD><TD>60 </TD><TD/><TD/><TD>reg[A] = ﬂoat(reg[A])</TD></TR><TR><TD>FIX </TD><TD>61 </TD><TD/><TD/><TD>reg[A] = ﬁx(reg[A])</TD></TR><TR><TD>FIXR </TD><TD>62 </TD><TD/><TD/><TD>reg[A] = ﬁx(round(reg[A]))</TD></TR><TR><TD>FRAC </TD><TD>63 </TD><TD/><TD/><TD>reg[A] = fraction(reg[A]) </TD></TR><TR><TD>FSPLIT </TD><TD>64 </TD><TD/><TD/><TD>reg[A] = integer(reg[A]),reg[0] = fraction(reg[A]) </TD></TR><TR><TD>SELECTMA </TD><TD>65 </TD><TD>nn,bb,bb </TD><TD/><TD>Select matrix A </TD></TR><TR><TD>SELECTMB </TD><TD>66 </TD><TD>nn,bb,bb </TD><TD/><TD>Select matrix B </TD></TR><TR><TD>SELECTMC </TD><TD>67 </TD><TD>nn,bb,bb </TD><TD/><TD>Select matrix C </TD></TR><TR><TD>LOADMA </TD><TD>68 </TD><TD>bb,bb </TD><TD/><TD>reg[0] = Matrix A[bb, bb] </TD></TR><TR><TD>LOADMB </TD><TD>69 </TD><TD>bb,bb </TD><TD/><TD>reg[0] = Matrix B[bb, bb]</TD></TR><TR><TD>LOADMC </TD><TD>6A </TD><TD>bb,bb </TD><TD/><TD>reg[0] = Matrix C[bb, bb]</TD></TR><TR><TD>SAVEMA </TD><TD>6B </TD><TD>bb,bb </TD><TD/><TD>Matrix A[bb, bb] = reg[0]</TD></TR><TR><TD>SAVEMB </TD><TD>6C </TD><TD>bb,bb </TD><TD/><TD>Matrix B[bb, bb] = reg[0]</TD></TR><TR><TD>SAVEMC </TD><TD>6D </TD><TD>bb,bb </TD><TD/><TD>Matrix C[bb, bb] = reg[0]</TD></TR><TR><TD>MOP </TD><TD>6E </TD><TD>bb </TD><TD/><TD>Matrix/Vector operation</TD></TR><TR><TD>FFT </TD><TD>6F </TD><TD>bb </TD><TD/><TD>Fast Fourier Transform </TD></TR><TR><TD>WRBLK </TD><TD>70 </TD><TD>tc,t1…tn </TD><TD/><TD>Write multiple 32-bit values</TD></TR><TR><TD>RDBLK </TD><TD>71 </TD><TD>tc </TD><TD>t1…tn </TD><TD>Read multiple 32-bit values</TD></TR><TR><TD>LOADIND </TD><TD>7A </TD><TD>nn </TD><TD/><TD>reg[0] = reg[reg[nn]]</TD></TR><TR><TD>SAVEIND </TD><TD>7B </TD><TD>nn </TD><TD/><TD>reg[reg[nn]] = reg[A]</TD></TR><TR><TD>INDA </TD><TD>7C </TD><TD>nn </TD><TD/><TD>Select register A using value in reg[nn]</TD></TR><TR><TD>INDX </TD><TD>7D </TD><TD>nn </TD><TD/><TD>Select register X using value in reg[nn]</TD></TR><TR><TD>FCALL </TD><TD>7E </TD><TD>fn </TD><TD/><TD>Call user-deﬁned function in Flash </TD></TR><TR><TD>EECALL </TD><TD>7F </TD><TD>fn </TD><TD/><TD>Call user-deﬁned function in EEPROM </TD></TR><TR><TD>RET </TD><TD>80 </TD><TD/><TD/><TD>Return from user-deﬁned function </TD></TR><TR><TD>BRA </TD><TD>81 </TD><TD>bb </TD><TD/><TD>Unconditional branch </TD></TR><TR><TD>BRA,cc </TD><TD>82 </TD><TD>cc,bb </TD><TD/><TD>Conditional branch </TD></TR><TR><TD>JMP </TD><TD>83 </TD><TD>b1,b2 </TD><TD/><TD>Unconditional jump</TD></TR><TR><TD>JMP,cc </TD><TD>84 </TD><TD>cc,b1,b2 </TD><TD/><TD>Conditional jump</TD></TR><TR><TD>TABLE </TD><TD>85 </TD><TD>tc,t1…tn </TD><TD/><TD>Table lookup</TD></TR><TR><TD>FTABLE </TD><TD>86 </TD><TD>cc,tc,t1…tn </TD><TD/><TD>Floating point reverse table lookup</TD></TR><TR><TD>LTABLE </TD><TD>87 </TD><TD>cc,tc,t1…tn </TD><TD/><TD>Long integer reverse table lookup</TD></TR><TR><TD>POLY </TD><TD>88 </TD><TD>tc,t1…tn </TD><TD/><TD>reg[A] = nth order polynomial</TD></TR><TR><TD>GOTO </TD><TD>89 </TD><TD>nn </TD><TD/><TD>Computed GOTO</TD></TR><TR><TD>RET,cc </TD><TD>8A </TD><TD>cc </TD><TD/><TD>Conditional return from user-deﬁned function </TD></TR><TR><TD>LWRITE </TD><TD>90 </TD><TD>nn,b1,b2,b3,b4 </TD><TD/><TD>Write 32-bit long integer to reg[nn]</TD></TR><TR><TD>LWRITEA </TD><TD>91 </TD><TD>b1,b2,b3,b4 </TD><TD/><TD>Write 32-bit long integer to reg[A]</TD></TR><TR><TD>LWRITEX </TD><TD>92 </TD><TD>b1,b2,b3,b4 </TD><TD/><TD>Write 32-bit long integer to reg[X],X = X + 1 </TD></TR><TR><TD>LWRITE0 </TD><TD>93 </TD><TD>b1,b2,b3,b4 </TD><TD/><TD>Write 32-bit long integer to reg[0] </TD></TR></Table><Table><TR><TD>LREAD </TD><TD>94 </TD><TD>nn </TD><TD>b1,b2,b3,b4 </TD><TD>Read 32-bit long integer from reg[nn]</TD></TR><TR><TD>LREADA </TD><TD>95 </TD><TD/><TD>b1,b2,b3,b4 </TD><TD>Read 32-bit long value from reg[A] </TD></TR><TR><TD>LREADX </TD><TD>96 </TD><TD/><TD>b1,b2,b3,b4 </TD><TD>Read 32-bit long integer from reg[X],X = X + 1 </TD></TR><TR><TD>LREAD0 </TD><TD>97 </TD><TD/><TD>b1,b2,b3,b4 </TD><TD>Read 32-bit long integer from reg[0]</TD></TR><TR><TD>LREADBYTE </TD><TD>98 </TD><TD/><TD>bb </TD><TD>Read lower 8 bits of reg[A]</TD></TR><TR><TD>LREADWORD </TD><TD>99 </TD><TD/><TD>b1,b2 </TD><TD>Read lower 16 bits reg[A] </TD></TR><TR><TD>ATOL </TD><TD>9A </TD><TD>aa…00 </TD><TD/><TD>Convert ASCII to long integer</TD></TR><TR><TD>LTOA </TD><TD>9B </TD><TD>bb </TD><TD/><TD>Convert long integer to ASCII</TD></TR><TR><TD>LSET </TD><TD>9C </TD><TD>nn </TD><TD/><TD>reg[A] = reg[nn]</TD></TR><TR><TD>LADD </TD><TD>9D </TD><TD>nn </TD><TD/><TD>reg[A] = reg[A] + reg[nn]</TD></TR><TR><TD>LSUB </TD><TD>9E </TD><TD>nn </TD><TD/><TD>reg[A] = reg[A] - reg[nn]</TD></TR><TR><TD>LMUL </TD><TD>9F </TD><TD>nn </TD><TD/><TD>reg[A] = reg[A] * reg[nn]</TD></TR><TR><TD>LDIV </TD><TD>A0 </TD><TD>nn </TD><TD/><TD>reg[A] = reg[A] / reg[nn]reg[0] = remainder</TD></TR><TR><TD>LCMP </TD><TD>A1 </TD><TD>nn </TD><TD/><TD>Signed compare reg[A] and reg[nn],Set long integer status</TD></TR><TR><TD>LUDIV </TD><TD>A2 </TD><TD>nn </TD><TD/><TD>reg[A] = reg[A] / reg[nn]reg[0] = remainder</TD></TR><TR><TD>LUCMP </TD><TD>A3 </TD><TD>nn </TD><TD/><TD>Unsigned compare reg[A] and reg[nn],Set long integer status</TD></TR><TR><TD>LTST </TD><TD>A4 </TD><TD>nn </TD><TD/><TD>Test reg[A] AND reg[nn],Set long integer status</TD></TR><TR><TD>LSET0 </TD><TD>A5 </TD><TD/><TD/><TD>reg[A] = reg[0] </TD></TR><TR><TD>LADD0 </TD><TD>A6 </TD><TD/><TD/><TD>reg[A] = reg[A] + reg[0] </TD></TR><TR><TD>LSUB0 </TD><TD>A7 </TD><TD/><TD/><TD>reg[A] = reg[A] - reg[0]</TD></TR><TR><TD>LMUL0 </TD><TD>A8 </TD><TD/><TD/><TD>reg[A] = reg[A] * reg[0]</TD></TR><TR><TD>LDIV0 </TD><TD>A9 </TD><TD/><TD/><TD>reg[A] = reg[A] / reg[0]reg[0] = remainder</TD></TR><TR><TD>LCMP0 </TD><TD>AA </TD><TD/><TD/><TD>Signed compare reg[A] and reg[0],set long integer status</TD></TR><TR><TD>LUDIV0 </TD><TD>AB </TD><TD/><TD/><TD>reg[A] = reg[A] / reg[0]reg[0] = remainder</TD></TR><TR><TD>LUCMP0 </TD><TD>AC </TD><TD/><TD/><TD>Unsigned compare reg[A] and reg[0],Set long integer status</TD></TR><TR><TD>LTST0 </TD><TD>AD </TD><TD/><TD/><TD>Test reg[A] AND reg[0],Set long integer status </TD></TR><TR><TD>LSETI </TD><TD>AE </TD><TD>bb </TD><TD/><TD>reg[A] = long(bb)</TD></TR><TR><TD>LADDI </TD><TD>AF </TD><TD>bb </TD><TD/><TD>reg[A] = reg[A] + long(bb)</TD></TR><TR><TD>LSUBI </TD><TD>B0 </TD><TD>bb </TD><TD/><TD>reg[A] = reg[A] - long(bb)</TD></TR><TR><TD>LMULI </TD><TD>B1 </TD><TD>bb </TD><TD/><TD>reg[A] = reg[A] * long(bb) </TD></TR><TR><TD>LDIVI </TD><TD>B2 </TD><TD>bb </TD><TD/><TD>reg[A] = reg[A] / long(bb)reg[0] = remainder</TD></TR><TR><TD>LCMPI </TD><TD>B3 </TD><TD>bb </TD><TD/><TD>Signed compare reg[A] - long(bb),Set long integer status </TD></TR><TR><TD>LUDIVI </TD><TD>B4 </TD><TD>bb </TD><TD/><TD>reg[A] = reg[A] / unsigned long(bb)reg[0] = remainder </TD></TR><TR><TD>LUCMPI </TD><TD>B5 </TD><TD>bb </TD><TD/><TD>Unsigned compare reg[A] and long(bb),Set long integer status </TD></TR></Table><Table><TR><TD>LTSTI </TD><TD>B6 </TD><TD>bb </TD><TD/><TD>Test reg[A] AND long(bb),Set long integer status</TD></TR><TR><TD>LSTATUS </TD><TD>B7 </TD><TD>nn </TD><TD/><TD>Set long integer status for reg[nn]</TD></TR><TR><TD>LSTATUSA </TD><TD>B8 </TD><TD/><TD/><TD>Set long integer status for reg[A]</TD></TR><TR><TD>LCMP2 </TD><TD>B9 </TD><TD>nn,mm </TD><TD/><TD>Signed long compare reg[nn], reg[mm]Set long integer status </TD></TR><TR><TD>LUCMP2 </TD><TD>BA </TD><TD>nn,mm </TD><TD/><TD>Unsigned long compare reg[nn], reg[mm]Set long integer status </TD></TR><TR><TD>LNEG </TD><TD>BB </TD><TD/><TD/><TD>reg[A] = -reg[A]</TD></TR><TR><TD>LABS </TD><TD>BC </TD><TD/><TD/><TD>reg[A] = | reg[A] | </TD></TR><TR><TD>LINC </TD><TD>BD </TD><TD>nn </TD><TD/><TD>reg[nn] = reg[nn] + 1, set status</TD></TR><TR><TD>LDEC </TD><TD>BE </TD><TD>nn </TD><TD/><TD>reg[nn] = reg[nn] - 1, set status</TD></TR><TR><TD>LNOT </TD><TD>BF </TD><TD/><TD/><TD>reg[A] = NOT reg[A]</TD></TR><TR><TD>LAND </TD><TD>C0 </TD><TD>nn </TD><TD/><TD>reg[A] = reg[A] AND reg[nn]</TD></TR><TR><TD>LOR </TD><TD>C1 </TD><TD>nn </TD><TD/><TD>reg[A] = reg[A] OR reg[nn]</TD></TR><TR><TD>LXOR </TD><TD>C2 </TD><TD>nn </TD><TD/><TD>reg[A] = reg[A] XOR reg[nn] </TD></TR><TR><TD>LSHIFT </TD><TD>C3 </TD><TD>nn </TD><TD/><TD>reg[A] = reg[A] shift reg[nn] </TD></TR><TR><TD>LMIN </TD><TD>C4 </TD><TD>nn </TD><TD/><TD>reg[A] = min(reg[A], reg[nn])</TD></TR><TR><TD>LMAX </TD><TD>C5 </TD><TD>nn </TD><TD/><TD>reg[A] = max(reg[A], reg[nn])</TD></TR><TR><TD>LONGBYTE </TD><TD>C6 </TD><TD>bb </TD><TD/><TD>reg[0] = long(signed byte bb)</TD></TR><TR><TD>LONGUBYTE </TD><TD>C7 </TD><TD>bb </TD><TD/><TD>reg[0] = long(unsigned byte bb)</TD></TR><TR><TD>LONGWORD </TD><TD>C8 </TD><TD>b1,b2 </TD><TD/><TD>reg[0] = long(signed b1*256 + b2)</TD></TR><TR><TD>LONGUWORD </TD><TD>C9 </TD><TD>b1,b2 </TD><TD/><TD>reg[0] = long(unsigned b1*256 + b2)</TD></TR><TR><TD>SETSTATUS </TD><TD>CD </TD><TD>ss </TD><TD/><TD>Set status byte</TD></TR><TR><TD>SEROUT </TD><TD>CE </TD><TD>bb bb,bd bb,aa…00 </TD><TD/><TD>Serial output </TD></TR><TR><TD>SERIN </TD><TD>CF </TD><TD>bb </TD><TD/><TD>Serial input</TD></TR><TR><TD>SETOUT </TD><TD>D0 </TD><TD>bb </TD><TD/><TD>Set OUT1 and OUT2 output pins</TD></TR><TR><TD>ADCMODE </TD><TD>D1 </TD><TD>bb </TD><TD/><TD>Set A/D trigger mode</TD></TR><TR><TD>ADCTRIG </TD><TD>D2 </TD><TD/><TD/><TD>A/D manual trigger</TD></TR><TR><TD>ADCSCALE </TD><TD>D3 </TD><TD>ch </TD><TD/><TD>ADCscale[ch] = reg[0]</TD></TR><TR><TD>ADCLONG </TD><TD>D4 </TD><TD>ch </TD><TD/><TD>reg[0] = ADCvalue[ch]</TD></TR><TR><TD>ADCLOAD </TD><TD>D5 </TD><TD>ch </TD><TD/><TD>reg[0] =ﬂoat(ADCvalue[ch]) * ADCscale[ch]</TD></TR><TR><TD>ADCWAIT </TD><TD>D6 </TD><TD/><TD/><TD>wait for next A/D sample </TD></TR><TR><TD>TIMESET </TD><TD>D7 </TD><TD/><TD/><TD>time = reg[0] </TD></TR><TR><TD>TIMELONG </TD><TD>D8 </TD><TD/><TD/><TD>reg[0] = time (long integer)</TD></TR><TR><TD>TICKLONG </TD><TD>D9 </TD><TD/><TD/><TD>reg[0] = ticks (long integer)</TD></TR><TR><TD>EESAVE </TD><TD>DA </TD><TD>nn,ee </TD><TD/><TD>EEPROM[ee] = reg[nn]</TD></TR><TR><TD>EESAVEA </TD><TD>DB </TD><TD>ee </TD><TD/><TD>EEPROM[ee] = reg[A]</TD></TR><TR><TD>EELOAD </TD><TD>DC </TD><TD>nn,ee </TD><TD/><TD>reg[nn] = EEPROM[ee]</TD></TR><TR><TD>EELOADA </TD><TD>DD </TD><TD>ee </TD><TD/><TD>reg[A] = EEPROM[ee]</TD></TR><TR><TD>EEWRITE </TD><TD>DE </TD><TD>ee,bc,b1…bn </TD><TD/><TD>Store bytes starting at EEPROM[ee]</TD></TR><TR><TD>EXTSET </TD><TD>E0 </TD><TD/><TD/><TD>external input count = reg[0]</TD></TR><TR><TD>EXTLONG </TD><TD>E1 </TD><TD/><TD/><TD>reg[0] = external input counter</TD></TR><TR><TD>EXTWAIT </TD><TD>E2 </TD><TD/><TD/><TD>wait for next external input</TD></TR><TR><TD>STRSET </TD><TD>E3 </TD><TD>aa…00 </TD><TD/><TD>Copy string to string buffer</TD></TR><TR><TD>STRSEL </TD><TD>E4 </TD><TD>bb,bb </TD><TD/><TD>Set selection point </TD></TR></Table><Table><TR><TD>STRINS </TD><TD>E5 </TD><TD>aa…00 </TD><TD/><TD>Insert string at selection point</TD></TR><TR><TD>STRCMP </TD><TD>E6 </TD><TD>aa…00 </TD><TD/><TD>Compare string with string selection</TD></TR><TR><TD>STRFIND </TD><TD>E7 </TD><TD>aa…00 </TD><TD/><TD>Find string</TD></TR><TR><TD>STRFCHR </TD><TD>E8 </TD><TD>aa…00 </TD><TD/><TD>Set ﬁeld separators</TD></TR><TR><TD>STRFIELD </TD><TD>E9 </TD><TD>bb </TD><TD/><TD>Find ﬁeld </TD></TR><TR><TD>STRTOF </TD><TD>EA </TD><TD/><TD/><TD>Convert string selection to ﬂoating point </TD></TR><TR><TD>STRTOL </TD><TD>EB </TD><TD/><TD/><TD>Convert string selection to long integer </TD></TR><TR><TD>READSEL </TD><TD>EC </TD><TD/><TD>aa…00 </TD><TD>Read string selection</TD></TR><TR><TD>STRBYTE </TD><TD>ED </TD><TD>bb </TD><TD/><TD>Insert byte at selection point</TD></TR><TR><TD>STRINC </TD><TD>EE </TD><TD/><TD/><TD>Increment string selection point</TD></TR><TR><TD>STRDEC </TD><TD>EF </TD><TD/><TD/><TD>Decrement string selection point</TD></TR><TR><TD>SYNC </TD><TD>F0 </TD><TD/><TD>5C </TD><TD>Get synchronization byte</TD></TR><TR><TD>READSTATUS </TD><TD>F1 </TD><TD/><TD>ss </TD><TD>Read status byte</TD></TR><TR><TD>READSTR </TD><TD>F2 </TD><TD/><TD>aa…00 </TD><TD>Read string from string buffer</TD></TR><TR><TD>VERSION </TD><TD>F3 </TD><TD/><TD/><TD>Copy version string to string buffer</TD></TR><TR><TD>IEEEMODE </TD><TD>F4 </TD><TD/><TD/><TD>Set IEEE mode (default)</TD></TR><TR><TD>PICMODE </TD><TD>F5 </TD><TD/><TD/><TD>Set PIC mode </TD></TR><TR><TD>CHECKSUM </TD><TD>F6 </TD><TD/><TD/><TD>Calculate checksum for uM-FPU code </TD></TR><TR><TD>BREAK </TD><TD>F7 </TD><TD/><TD/><TD>Debug breakpoint </TD></TR><TR><TD>TRACEOFF </TD><TD>F8 </TD><TD/><TD/><TD>Turn debug trace off</TD></TR><TR><TD>TRACEON </TD><TD>F9 </TD><TD/><TD/><TD>Turn debug trace on</TD></TR><TR><TD>TRACESTR </TD><TD>FA </TD><TD>aa…00 </TD><TD/><TD>Send string to debug trace buffer</TD></TR><TR><TD>TRACEREG </TD><TD>FB </TD><TD>nn </TD><TD/><TD>Send register value to trace buffer </TD></TR><TR><TD>READVAR </TD><TD>FC </TD><TD>bb </TD><TD/><TD>Read internal register value </TD></TR><TR><TD>RESET </TD><TD>FF </TD><TD/><TD/><TD>Reset (9 consecutive FF bytes cause areset, otherwise it is a NOP) </TD></TR></Table><P>Notes: Opcode Instruction opcode in hexadecimal </P><P>Arguments Additional data required by instruction </P><P>Returns Data returned by instruction </P><P>nn register number (0-127) </P><P>mm register number (0-127) </P><P>fn function number (0-63) </P><P>bb 8-bit value </P><P>b1,b2 16-bit value (b1 is MSB) </P><P>b1,b2,b3,b4 32-bit value (b1 is MSB) </P><P>b1…bn string of 8-bit bytes </P><P>ss Status byte </P><P>bd baud rate and debug mode </P><P>cc Condition code </P><P>ee EEPROM address slot (0-255) </P><P>ch A/D channel number </P><P>bc Byte count </P><P>tc 32-bit value count </P><P>t1…tn String of 32-bit values </P><P>aa…00 Zero terminated ASCII string </P></Sect><Sect><H3 id="LinkTarget_780">Appendix BuM-FPU V3.1 Instruction Timing </H3><P>The instruction times shown in the following table are calculated with a clock speed of 29.48 MHz and are measured 
from the rising edge of the last bit of the last byte of the instruction (SIN pin) to the Ready state being asserted 
(falling edge on SOUT). The instruction times do not include the transfer time for sending the instructions to the 
uM-FPU, which depends on the type of interface (e.g. SPI or I2C), and the speed of the interface. 
</P><P>The uM-FPU V3.1 chip contains a 256 byte instruction buffer that can be used to minimize the transfer time. 
Instructions can be queued up in the instruction buffer while previous instructions are executing, 
allowing the transfer time to overlap the instruction execution time. 
</P><P>User-defined functions can also be stored in Flash memory on the uM-FPU V3.1 chip, which is another option for 
eliminating the transfer time. 
</P><P>If debug tracing is enabled, the Ready state is delayed once the trace buffer is full. Trace data is output through the 
SEROUT pin at 57,600 baud. On average, each byte of data in an instruction generates approximately three trace 
characters, which requires about 521 microseconds to transmit. Once the trace buffer is full, instruction execution is 
delayed until space is available. When using a fast interface, trace delays can be a dominant part of the overall 
instruction execution time. 
</P><P>Execution Time Instruction Opcode Arguments Returns (usec) Notes </P><Table><TR><TD>NOP </TD><TD>00 </TD><TD/><TD/><TD>6 </TD><TD/></TR><TR><TD>SELECTA </TD><TD>01 </TD><TD>nn </TD><TD/><TD>4 </TD><TD/></TR><TR><TD>SELECTX </TD><TD>02 </TD><TD>nn </TD><TD/><TD>4 </TD><TD/></TR><TR><TD>CLR </TD><TD>03 </TD><TD>nn </TD><TD/><TD>5 </TD><TD/></TR><TR><TD>CLRA </TD><TD>04 </TD><TD/><TD/><TD>7 </TD><TD/></TR><TR><TD>CLRX </TD><TD>05 </TD><TD/><TD/><TD>7 </TD><TD/></TR><TR><TD>CLR0 </TD><TD>06 </TD><TD/><TD/><TD>7 </TD><TD/></TR><TR><TD>COPY </TD><TD>07 </TD><TD>mm,nn </TD><TD/><TD>5 </TD><TD/></TR><TR><TD>COPYA </TD><TD>08 </TD><TD>nn </TD><TD/><TD>5 </TD><TD/></TR><TR><TD>COPYX </TD><TD>09 </TD><TD>nn </TD><TD/><TD>5 </TD><TD/></TR><TR><TD>LOAD </TD><TD>0A </TD><TD>nn </TD><TD/><TD>5 </TD><TD/></TR><TR><TD>LOADA </TD><TD>0B </TD><TD/><TD/><TD>7 </TD><TD/></TR><TR><TD>LOADX </TD><TD>0C </TD><TD/><TD/><TD>7 </TD><TD/></TR><TR><TD>ALOADX </TD><TD>0D </TD><TD/><TD/><TD>7 </TD><TD/></TR><TR><TD>XSAVE </TD><TD>0E </TD><TD>nn </TD><TD/><TD>5 </TD><TD/></TR><TR><TD>XSAVEA </TD><TD>0F </TD><TD/><TD/><TD>7 </TD><TD/></TR><TR><TD>COPY0 </TD><TD>10 </TD><TD>nn </TD><TD/><TD>5 </TD><TD/></TR><TR><TD>COPYI </TD><TD>11 </TD><TD>bb,nn </TD><TD/><TD>5 </TD><TD/></TR><TR><TD>SWAP </TD><TD>12 </TD><TD>nn,mm </TD><TD/><TD>6 </TD><TD/></TR><TR><TD>SWAPA </TD><TD>13 </TD><TD>nn </TD><TD/><TD>6 </TD><TD/></TR><TR><TD>LEFT </TD><TD>14 </TD><TD/><TD/><TD>7 </TD><TD/></TR><TR><TD>RIGHT </TD><TD>15 </TD><TD/><TD/><TD>7 </TD><TD/></TR><TR><TD>FWRITE </TD><TD>16 </TD><TD>nn,b1,b2,b3,b4 </TD><TD/><TD>5 </TD><TD/></TR><TR><TD>FWRITEA </TD><TD>17 </TD><TD>b1,b2,b3,b4 </TD><TD/><TD>5 </TD><TD/></TR><TR><TD>FWRITEX </TD><TD>18 </TD><TD>b1,b2,b3,b4 </TD><TD/><TD>5 </TD><TD/></TR><TR><TD>FWRITE0 </TD><TD>19 </TD><TD>b1,b2,b3,b4 </TD><TD/><TD>5 </TD><TD/></TR><TR><TD>FREAD </TD><TD>1A </TD><TD>nn </TD><TD>b1,b2,b3,b4 </TD><TD/><TD>(note 1) </TD></TR><TR><TD>FREADA </TD><TD>1B </TD><TD/><TD>b1,b2,b3,b4 </TD><TD/><TD>(note 1) </TD></TR></Table><Table><TR><TD>FREADX </TD><TD>1C </TD><TD/><TD>b1,b2,b3,b4 </TD><TD/><TD>(note 1) </TD></TR><TR><TD>FREAD0 </TD><TD>1D </TD><TD/><TD>b1,b2,b3,b4 </TD><TD/><TD>(note 1) </TD></TR><TR><TD>ATOF </TD><TD>1E </TD><TD>aa…00 </TD><TD/><TD>26-90 </TD><TD>(note 5) </TD></TR><TR><TD>FTOA </TD><TD>1F </TD><TD>bb </TD><TD/><TD>8-250 </TD><TD>(note 6) </TD></TR><TR><TD>FSET </TD><TD>20 </TD><TD>nn </TD><TD/><TD>5 </TD><TD/></TR><TR><TD>FADD </TD><TD>21 </TD><TD>nn </TD><TD/><TD>9-14 </TD><TD>(note 2) </TD></TR><TR><TD>FSUB </TD><TD>22 </TD><TD>nn </TD><TD/><TD>10-15 </TD><TD>(note 2) </TD></TR><TR><TD>FSUBR </TD><TD>23 </TD><TD>nn </TD><TD/><TD>10-15 </TD><TD>(note 2) </TD></TR><TR><TD>FMUL </TD><TD>24 </TD><TD>nn </TD><TD/><TD>9 </TD><TD/></TR><TR><TD>FDIV </TD><TD>25 </TD><TD>nn </TD><TD/><TD>17-18 </TD><TD>(note 2) </TD></TR><TR><TD>FDIVR </TD><TD>26 </TD><TD>nn </TD><TD/><TD>17-18 </TD><TD>(note 2) </TD></TR><TR><TD>FPOW </TD><TD>27 </TD><TD>nn </TD><TD/><TD>5-272 </TD><TD>(note 2) </TD></TR><TR><TD>FCMP </TD><TD>28 </TD><TD>nn </TD><TD/><TD>7 </TD><TD/></TR><TR><TD>FSET0 </TD><TD>29 </TD><TD/><TD/><TD>5 </TD><TD/></TR><TR><TD>FADD0 </TD><TD>2A </TD><TD/><TD/><TD>11-16 </TD><TD>(note 2) </TD></TR><TR><TD>FSUB0 </TD><TD>2B </TD><TD/><TD/><TD>12-17 </TD><TD>(note 2) </TD></TR><TR><TD>FSUBR0 </TD><TD>2C </TD><TD/><TD/><TD>12-17 </TD><TD>(note 2) </TD></TR><TR><TD>FMUL0 </TD><TD>2D </TD><TD/><TD/><TD>11 </TD><TD/></TR><TR><TD>FDIV0 </TD><TD>2E </TD><TD/><TD/><TD>19-20 </TD><TD>(note 2) </TD></TR><TR><TD>FDIVR0 </TD><TD>2F </TD><TD/><TD/><TD>19-20 </TD><TD>(note 2) </TD></TR><TR><TD>FPOW0 </TD><TD>30 </TD><TD/><TD/><TD>8-274 </TD><TD>(note 2) </TD></TR><TR><TD>FCMP0 </TD><TD>31 </TD><TD/><TD/><TD>8 </TD><TD/></TR><TR><TD>FSETI </TD><TD>32 </TD><TD>bb </TD><TD/><TD>10-12 </TD><TD/></TR><TR><TD>FADDI </TD><TD>33 </TD><TD>bb </TD><TD/><TD>15-18 </TD><TD>(note 2) </TD></TR><TR><TD>FSUBI </TD><TD>34 </TD><TD>bb </TD><TD/><TD>15-19 </TD><TD>(note 2) </TD></TR><TR><TD>FSUBRI </TD><TD>35 </TD><TD>bb </TD><TD/><TD>15-19 </TD><TD>(note 2) </TD></TR><TR><TD>FMULI </TD><TD>36 </TD><TD>bb </TD><TD/><TD>14-15 </TD><TD>(note 2) </TD></TR><TR><TD>FDIVI </TD><TD>37 </TD><TD>bb </TD><TD/><TD>23-25 </TD><TD>(note 2) </TD></TR><TR><TD>FDIVRI </TD><TD>38 </TD><TD>bb </TD><TD/><TD>23-25 </TD><TD>(note 2) </TD></TR><TR><TD>FPOWI </TD><TD>39 </TD><TD>bb </TD><TD/><TD>5-47 </TD><TD>(note 2) </TD></TR><TR><TD>FCMPI </TD><TD>3A </TD><TD>bb </TD><TD/><TD>13 </TD><TD/></TR><TR><TD>FSTATUS </TD><TD>3B </TD><TD>nn </TD><TD/><TD>5 </TD><TD/></TR><TR><TD>FSTATUSA </TD><TD>3C </TD><TD/><TD/><TD>6 </TD><TD/></TR><TR><TD>FCMP2 </TD><TD>3D </TD><TD>nn,mm </TD><TD/><TD>7 </TD><TD/></TR><TR><TD>FNEG </TD><TD>3E </TD><TD/><TD/><TD>7 </TD><TD/></TR><TR><TD>FABS </TD><TD>3F </TD><TD/><TD/><TD>7 </TD><TD/></TR><TR><TD>FINV </TD><TD>40 </TD><TD/><TD/><TD>20-21 </TD><TD>(note 2) </TD></TR><TR><TD>SQRT </TD><TD>41 </TD><TD/><TD/><TD>23-24 </TD><TD>(note 2) </TD></TR><TR><TD>ROOT </TD><TD>42 </TD><TD>nn </TD><TD/><TD>25-286 </TD><TD/></TR><TR><TD>LOG </TD><TD>43 </TD><TD/><TD/><TD>108-110 </TD><TD>(note 2) </TD></TR><TR><TD>LOG10 </TD><TD>44 </TD><TD/><TD/><TD>112-144 </TD><TD>(note 2) </TD></TR><TR><TD>EXP </TD><TD>45 </TD><TD/><TD/><TD>98-110 </TD><TD>(note 4) </TD></TR><TR><TD>EXP10 </TD><TD>46 </TD><TD/><TD/><TD>98-144 </TD><TD>(note 4) </TD></TR><TR><TD>SIN </TD><TD>47 </TD><TD/><TD/><TD>90-100 </TD><TD>(note 2) </TD></TR><TR><TD>COS </TD><TD>48 </TD><TD/><TD/><TD>108-110 </TD><TD>(note 2) </TD></TR><TR><TD>TAN </TD><TD>49 </TD><TD/><TD/><TD>103 </TD><TD>(note 2) </TD></TR><TR><TD>ASIN </TD><TD>4A </TD><TD/><TD/><TD>72-101 </TD><TD>(note 10) </TD></TR><TR><TD>ACOS </TD><TD>4B </TD><TD/><TD/><TD>77-96 </TD><TD>(note 10) </TD></TR><TR><TD>ATAN </TD><TD>4C </TD><TD/><TD/><TD>62-101 </TD><TD>(note 10) </TD></TR></Table><Table><TR><TD>ATAN2 </TD><TD>4D </TD><TD>nn </TD><TD/><TD>114-127 </TD><TD>(note 10) </TD></TR><TR><TD>DEGREES </TD><TD>4E </TD><TD/><TD/><TD>10-11 </TD><TD>(note 2) </TD></TR><TR><TD>RADIANS </TD><TD>4F </TD><TD/><TD/><TD>10-11 </TD><TD>(note 2) </TD></TR><TR><TD>FMOD </TD><TD>50 </TD><TD>nn </TD><TD/><TD>7-11 </TD><TD>(note 2) </TD></TR><TR><TD>FLOOR </TD><TD>51 </TD><TD/><TD/><TD>8-10 </TD><TD>(note 2) </TD></TR><TR><TD>CEIL </TD><TD>52 </TD><TD/><TD/><TD>10-11 </TD><TD>(note 2) </TD></TR><TR><TD>ROUND </TD><TD>53 </TD><TD/><TD/><TD>17-25 </TD><TD>(note 2) </TD></TR><TR><TD>FMIN </TD><TD>54 </TD><TD>nn </TD><TD/><TD>6-7 </TD><TD>(note 2) </TD></TR><TR><TD>FMAX </TD><TD>55 </TD><TD>nn </TD><TD/><TD>6-7 </TD><TD>(note 2) </TD></TR><TR><TD>FCNV </TD><TD>56 </TD><TD>bb </TD><TD/><TD>9-23 </TD><TD>(note 2) </TD></TR><TR><TD>FMAC </TD><TD>57 </TD><TD>nn,mm </TD><TD/><TD>16 </TD><TD/></TR><TR><TD>FMSC </TD><TD>58 </TD><TD>nn,mm </TD><TD/><TD>16 </TD><TD/></TR><TR><TD>LOADBYTE </TD><TD>59 </TD><TD>bb </TD><TD/><TD>10 </TD><TD/></TR><TR><TD>LOADUBYTE </TD><TD>5A </TD><TD>bb </TD><TD/><TD>10 </TD><TD/></TR><TR><TD>LOADWORD </TD><TD>5B </TD><TD>b1,b2 </TD><TD/><TD>10 </TD><TD/></TR><TR><TD>LOADUWORD </TD><TD>5C </TD><TD>b1,b2 </TD><TD/><TD>10 </TD><TD/></TR><TR><TD>LOADE </TD><TD>5D </TD><TD/><TD/><TD>7 </TD><TD/></TR><TR><TD>LOADPI </TD><TD>5E </TD><TD/><TD/><TD>7 </TD><TD/></TR><TR><TD>LOADCON </TD><TD>5F </TD><TD>bb </TD><TD/><TD>5 </TD><TD/></TR><TR><TD>FLOAT </TD><TD>60 </TD><TD/><TD/><TD>10-12 </TD><TD>(note 3) </TD></TR><TR><TD>FIX </TD><TD>61 </TD><TD/><TD/><TD>7-10 </TD><TD>(note 2) </TD></TR><TR><TD>FIXR </TD><TD>62 </TD><TD/><TD/><TD>18-26 </TD><TD>(note 2) </TD></TR><TR><TD>FRAC </TD><TD>63 </TD><TD/><TD/><TD>20 </TD><TD/></TR><TR><TD>FSPLIT </TD><TD>64 </TD><TD/><TD/><TD>21 </TD><TD/></TR><TR><TD>SELECTMA </TD><TD>65 </TD><TD>nn,bb,bb </TD><TD/><TD>4 </TD><TD/></TR><TR><TD>SELECTMB </TD><TD>66 </TD><TD>nn,bb,bb </TD><TD/><TD>4 </TD><TD/></TR><TR><TD>SELECTMC </TD><TD>67 </TD><TD>nn,bb,bb </TD><TD/><TD>4 </TD><TD/></TR><TR><TD>LOADMA </TD><TD>68 </TD><TD>bb,bb </TD><TD/><TD>5 </TD><TD/></TR><TR><TD>LOADMB </TD><TD>69 </TD><TD>bb,bb </TD><TD/><TD>5 </TD><TD/></TR><TR><TD>LOADMC </TD><TD>6A </TD><TD>bb,bb </TD><TD/><TD>5 </TD><TD/></TR><TR><TD>SAVEMA </TD><TD>6B </TD><TD>bb,bb </TD><TD/><TD>5 </TD><TD/></TR><TR><TD>SAVEMB </TD><TD>6C </TD><TD>bb,bb </TD><TD/><TD>5 </TD><TD/></TR><TR><TD>SAVEMC </TD><TD>6D </TD><TD>bb,bb </TD><TD/><TD>5 </TD><TD/></TR><TR><TD>MOP </TD><TD>6E </TD><TD>bb </TD><TD/><TD/><TD>(note 17) </TD></TR><TR><TD>FFT </TD><TD>6F </TD><TD>bb </TD><TD/><TD/><TD>(note 15) </TD></TR><TR><TD>WRBLK </TD><TD>70 </TD><TD>tc,t1…tn </TD><TD/><TD/><TD>(note 16) </TD></TR><TR><TD>RDBLK </TD><TD>71 </TD><TD>tc </TD><TD>t1…tn </TD><TD/><TD>(note 16) </TD></TR><TR><TD>LOADIND </TD><TD>7A </TD><TD>nn </TD><TD/><TD>5 </TD><TD/></TR><TR><TD>SAVEIND </TD><TD>7B </TD><TD>nn </TD><TD/><TD>5 </TD><TD/></TR><TR><TD>INDA </TD><TD>7C </TD><TD>nn </TD><TD/><TD>5 </TD><TD/></TR><TR><TD>INDX </TD><TD>7D </TD><TD>nn </TD><TD/><TD>5 </TD><TD/></TR><TR><TD>FCALL </TD><TD>7E </TD><TD>fn </TD><TD/><TD>5 </TD><TD>(note 7) </TD></TR><TR><TD>EECALL </TD><TD>7F </TD><TD>fn </TD><TD/><TD>13 </TD><TD>(note 7) </TD></TR><TR><TD>RET </TD><TD>80 </TD><TD/><TD/><TD>5 </TD><TD>(note 8) </TD></TR><TR><TD>BRA </TD><TD>81 </TD><TD>bb </TD><TD/><TD>6 </TD><TD>(note 8) </TD></TR><TR><TD>BRA,cc </TD><TD>82 </TD><TD>cc,bb </TD><TD/><TD>2-4 </TD><TD>(note 8) </TD></TR><TR><TD>JMP </TD><TD>83 </TD><TD>b1,b2 </TD><TD/><TD>7 </TD><TD>(note 8) </TD></TR><TR><TD>JMP,cc </TD><TD>84 </TD><TD>cc,b1,b2 </TD><TD/><TD>5 </TD><TD>(note 8) </TD></TR></Table><Table><TR><TD>TABLE </TD><TD>85 </TD><TD>tc,t1…tn </TD><TD/><TD>11 </TD><TD>(note 8) </TD></TR><TR><TD>FTABLE </TD><TD>86 </TD><TD>cc,tc,t1…tn </TD><TD/><TD>25 </TD><TD>(note 8) </TD></TR><TR><TD>LTABLE </TD><TD>87 </TD><TD>cc,tc,t1…tn </TD><TD/><TD>23 </TD><TD>(note 8) </TD></TR><TR><TD>POLY </TD><TD>88 </TD><TD>tc,t1…tn </TD><TD/><TD/><TD>(note 8, 9) </TD></TR><TR><TD>GOTO </TD><TD>89 </TD><TD>nn </TD><TD/><TD>7 </TD><TD>(note 8) </TD></TR><TR><TD>RET,cc </TD><TD>8A </TD><TD>cc </TD><TD/><TD>5 </TD><TD>(note 8) </TD></TR><TR><TD>LWRITE </TD><TD>90 </TD><TD>nn,b1,b2,b3,b4 </TD><TD/><TD>5 </TD><TD/></TR><TR><TD>LWRITEA </TD><TD>91 </TD><TD>b1,b2,b3,b4 </TD><TD/><TD>5 </TD><TD/></TR><TR><TD>LWRITEX </TD><TD>92 </TD><TD>b1,b2,b3,b4 </TD><TD/><TD>5 </TD><TD/></TR><TR><TD>LWRITE0 </TD><TD>93 </TD><TD>b1,b2,b3,b4 </TD><TD/><TD>5 </TD><TD/></TR><TR><TD>LREAD </TD><TD>94 </TD><TD>nn </TD><TD>b1,b2,b3,b4 </TD><TD/><TD>(note 1) </TD></TR><TR><TD>LREADA </TD><TD>95 </TD><TD/><TD>b1,b2,b3,b4 </TD><TD/><TD>(note 1) </TD></TR><TR><TD>LREADX </TD><TD>96 </TD><TD/><TD>b1,b2,b3,b4 </TD><TD/><TD>(note 1) </TD></TR><TR><TD>LREAD0 </TD><TD>97 </TD><TD/><TD>b1,b2,b3,b4 </TD><TD/><TD>(note 1) </TD></TR><TR><TD>LREADBYTE </TD><TD>98 </TD><TD/><TD>bb </TD><TD/><TD>(note 1) </TD></TR><TR><TD>LREADWORD </TD><TD>99 </TD><TD/><TD>b1,b2 </TD><TD/><TD>(note 1) </TD></TR><TR><TD>ATOL </TD><TD>9A </TD><TD>aa…00 </TD><TD/><TD>10-30 </TD><TD/></TR><TR><TD>LTOA </TD><TD>9B </TD><TD>bb </TD><TD/><TD>20-165 </TD><TD>(note 6) </TD></TR><TR><TD>LSET </TD><TD>9C </TD><TD>nn </TD><TD/><TD>5 </TD><TD/></TR><TR><TD>LADD </TD><TD>9D </TD><TD>nn </TD><TD/><TD>5 </TD><TD>(note 3) </TD></TR><TR><TD>LSUB </TD><TD>9E </TD><TD>nn </TD><TD/><TD>5 </TD><TD>(note 3) </TD></TR><TR><TD>LMUL </TD><TD>9F </TD><TD>nn </TD><TD/><TD>5 </TD><TD>(note 3) </TD></TR><TR><TD>LDIV </TD><TD>A0 </TD><TD>nn </TD><TD/><TD>22 </TD><TD>(note 3) </TD></TR><TR><TD>LCMP </TD><TD>A1 </TD><TD>nn </TD><TD/><TD>5 </TD><TD/></TR><TR><TD>LUDIV </TD><TD>A2 </TD><TD>nn </TD><TD/><TD>21 </TD><TD>(note 3) </TD></TR><TR><TD>LUCMP </TD><TD>A3 </TD><TD>nn </TD><TD/><TD>5 </TD><TD/></TR><TR><TD>LTST </TD><TD>A4 </TD><TD>nn </TD><TD/><TD>5 </TD><TD/></TR><TR><TD>LSET0 </TD><TD>A5 </TD><TD/><TD/><TD>7 </TD><TD/></TR><TR><TD>LADD0 </TD><TD>A6 </TD><TD/><TD/><TD>7 </TD><TD/></TR><TR><TD>LSUB0 </TD><TD>A7 </TD><TD/><TD/><TD>7 </TD><TD/></TR><TR><TD>LMUL0 </TD><TD>A8 </TD><TD/><TD/><TD>7 </TD><TD/></TR><TR><TD>LDIV0 </TD><TD>A9 </TD><TD/><TD/><TD>23 </TD><TD/></TR><TR><TD>LCMP0 </TD><TD>AA </TD><TD/><TD/><TD>6 </TD><TD/></TR><TR><TD>LUDIV0 </TD><TD>AB </TD><TD/><TD/><TD>22 </TD><TD/></TR><TR><TD>LUCMP0 </TD><TD>AC </TD><TD/><TD/><TD>6 </TD><TD/></TR><TR><TD>LTST0 </TD><TD>AD </TD><TD/><TD/><TD>6 </TD><TD/></TR><TR><TD>LSETI </TD><TD>AE </TD><TD>bb </TD><TD/><TD>5 </TD><TD/></TR><TR><TD>LADDI </TD><TD>AF </TD><TD>bb </TD><TD/><TD>5 </TD><TD/></TR><TR><TD>LSUBI </TD><TD>B0 </TD><TD>bb </TD><TD/><TD>5 </TD><TD/></TR><TR><TD>LMULI </TD><TD>B1 </TD><TD>bb </TD><TD/><TD>5 </TD><TD/></TR><TR><TD>LDIVI </TD><TD>B2 </TD><TD>bb </TD><TD/><TD>21 </TD><TD/></TR><TR><TD>LCMPI </TD><TD>B3 </TD><TD>bb </TD><TD/><TD>5 </TD><TD/></TR><TR><TD>LUDIVI </TD><TD>B4 </TD><TD>bb </TD><TD/><TD>21 </TD><TD/></TR><TR><TD>LUCMPI </TD><TD>B5 </TD><TD>bb </TD><TD/><TD>5 </TD><TD/></TR><TR><TD>LTSTI </TD><TD>B6 </TD><TD>bb </TD><TD/><TD>4 </TD><TD/></TR><TR><TD>LSTATUS </TD><TD>B7 </TD><TD>nn </TD><TD/><TD>4 </TD><TD/></TR><TR><TD>LSTATUSA </TD><TD>B8 </TD><TD/><TD/><TD>6 </TD><TD/></TR><TR><TD>LCMP2 </TD><TD>B9 </TD><TD>nn,mm </TD><TD/><TD>5 </TD><TD/></TR><TR><TD>LUCMP2 </TD><TD>BA </TD><TD>nn,mm </TD><TD/><TD>5 </TD><TD/></TR></Table><Table><TR><TD>LNEG </TD><TD>BB </TD><TD/><TD/><TD>6 </TD><TD/></TR><TR><TD>LABS </TD><TD>BC </TD><TD/><TD/><TD>6 </TD><TD/></TR><TR><TD>LINC </TD><TD>BD </TD><TD>nn </TD><TD/><TD>5 </TD><TD/></TR><TR><TD>LDEC </TD><TD>BE </TD><TD>nn </TD><TD/><TD>5 </TD><TD/></TR><TR><TD>LNOT </TD><TD>BF </TD><TD/><TD/><TD>7 </TD><TD/></TR><TR><TD>LAND </TD><TD>C0 </TD><TD>nn </TD><TD/><TD>5 </TD><TD/></TR><TR><TD>LOR </TD><TD>C1 </TD><TD>nn </TD><TD/><TD>5 </TD><TD/></TR><TR><TD>LXOR </TD><TD>C2 </TD><TD>nn </TD><TD/><TD>5 </TD><TD/></TR><TR><TD>LSHIFT </TD><TD>C3 </TD><TD>nn </TD><TD/><TD>5-11 </TD><TD/></TR><TR><TD>LMIN </TD><TD>C4 </TD><TD>nn </TD><TD/><TD>4-5 </TD><TD>(note 3) </TD></TR><TR><TD>LMAX </TD><TD>C5 </TD><TD>nn </TD><TD/><TD>4-5 </TD><TD>(note 3) </TD></TR><TR><TD>LONGBYTE </TD><TD>C6 </TD><TD>bb </TD><TD/><TD>5 </TD><TD/></TR><TR><TD>LONGUBYTE </TD><TD>C7 </TD><TD>bb </TD><TD/><TD>5 </TD><TD/></TR><TR><TD>LONGWORD </TD><TD>C8 </TD><TD>b1,b2 </TD><TD/><TD>5 </TD><TD/></TR><TR><TD>LONGUWORD </TD><TD>C9 </TD><TD>b1,b2 </TD><TD/><TD>5 </TD><TD/></TR><TR><TD>SETSTATUS </TD><TD>CD </TD><TD>ss </TD><TD/><TD>4 </TD><TD/></TR><TR><TD>SEROUT </TD><TD>CE </TD><TD>bb bb,bd bb,aa…00 </TD><TD/><TD/><TD>(note 14) </TD></TR><TR><TD>SERIN </TD><TD>CF </TD><TD>bb </TD><TD/><TD/><TD>(note 14) </TD></TR><TR><TD>SETOUT </TD><TD>D0 </TD><TD>bb </TD><TD/><TD>5 </TD><TD/></TR><TR><TD>ADCMODE </TD><TD>D1 </TD><TD>bb </TD><TD/><TD>6-7 </TD><TD/></TR><TR><TD>ADCTRIG </TD><TD>D2 </TD><TD/><TD/><TD>9 </TD><TD/></TR><TR><TD>ADCSCALE </TD><TD>D3 </TD><TD>ch </TD><TD/><TD>6 </TD><TD/></TR><TR><TD>ADCLONG </TD><TD>D4 </TD><TD>ch </TD><TD/><TD>8 </TD><TD/></TR><TR><TD>ADCLOAD </TD><TD>D5 </TD><TD>ch </TD><TD/><TD>17 </TD><TD/></TR><TR><TD>ADCWAIT </TD><TD>D6 </TD><TD/><TD/><TD/><TD>(note 11) </TD></TR><TR><TD>TIMESET </TD><TD>D7 </TD><TD/><TD/><TD>9 </TD><TD/></TR><TR><TD>TIMELONG </TD><TD>D8 </TD><TD/><TD/><TD>10 </TD><TD/></TR><TR><TD>TICKLONG </TD><TD>D9 </TD><TD/><TD/><TD>10 </TD><TD/></TR><TR><TD>EESAVE </TD><TD>DA </TD><TD>nn,ee </TD><TD/><TD>5590 </TD><TD/></TR><TR><TD>EESAVEA </TD><TD>DB </TD><TD>ee </TD><TD/><TD>5590 </TD><TD/></TR><TR><TD>EELOAD </TD><TD>DC </TD><TD>nn,ee </TD><TD/><TD>5 </TD><TD/></TR><TR><TD>EELOADA </TD><TD>DD </TD><TD>ee </TD><TD/><TD>5 </TD><TD/></TR><TR><TD>EEWRITE </TD><TD>DE </TD><TD>ee,bc,b1…bn </TD><TD/><TD>1120/byte </TD><TD/></TR><TR><TD>EXTSET </TD><TD>E0 </TD><TD/><TD/><TD>9 </TD><TD/></TR><TR><TD>EXTLONG </TD><TD>E1 </TD><TD/><TD/><TD>10 </TD><TD/></TR><TR><TD>EXTWAIT </TD><TD>E2 </TD><TD/><TD/><TD/><TD>(note 11) </TD></TR><TR><TD>STRSET </TD><TD>E3 </TD><TD>aa…00 </TD><TD/><TD>5 </TD><TD/></TR><TR><TD>STRSEL </TD><TD>E4 </TD><TD>bb,bb </TD><TD/><TD>6 </TD><TD/></TR><TR><TD>STRINS </TD><TD>E5 </TD><TD>aa…00 </TD><TD/><TD>5 </TD><TD/></TR><TR><TD>STRCMP </TD><TD>E6 </TD><TD>aa…00 </TD><TD/><TD>4-10 </TD><TD/></TR><TR><TD>STRFIND </TD><TD>E7 </TD><TD>aa…00 </TD><TD/><TD>7 </TD><TD/></TR><TR><TD>STRFCHR </TD><TD>E8 </TD><TD>aa…00 </TD><TD/><TD>5 </TD><TD/></TR><TR><TD>STRFIELD </TD><TD>E9 </TD><TD>bb </TD><TD/><TD>10 </TD><TD/></TR><TR><TD>STRTOF </TD><TD>EA </TD><TD/><TD/><TD>26-90 </TD><TD/></TR><TR><TD>STRTOL </TD><TD>EB </TD><TD/><TD/><TD>10-50 </TD><TD/></TR><TR><TD>READSEL </TD><TD>EC </TD><TD/><TD>aa…00 </TD><TD/><TD>(note 1) </TD></TR><TR><TD>STRBYTE </TD><TD>ED </TD><TD>bb </TD><TD/><TD/><TD/></TR></Table><Table><TR><TD>STRINC </TD><TD>EE </TD><TD/><TD/><TD/><TD/></TR><TR><TD>STRDEC </TD><TD>EF </TD><TD/><TD/><TD/><TD/></TR><TR><TD>SYNC </TD><TD>F0 </TD><TD/><TD>5C </TD><TD/><TD>(note 1) </TD></TR><TR><TD>READSTATUS </TD><TD>F1 </TD><TD/><TD>ss </TD><TD/><TD>(note 1) </TD></TR><TR><TD>READSTR </TD><TD>F2 </TD><TD/><TD>aa…00 </TD><TD/><TD>(note 1) </TD></TR><TR><TD>VERSION </TD><TD>F3 </TD><TD/><TD/><TD>9 </TD><TD/></TR><TR><TD>IEEEMODE </TD><TD>F4 </TD><TD/><TD/><TD>5 </TD><TD/></TR><TR><TD>PICMODE </TD><TD>F5 </TD><TD/><TD/><TD>5 </TD><TD/></TR><TR><TD>CHECKSUM </TD><TD>F6 </TD><TD/><TD/><TD>3888 </TD><TD/></TR><TR><TD>BREAK </TD><TD>F7 </TD><TD/><TD/><TD/><TD>(note 12) </TD></TR><TR><TD>TRACEOFF </TD><TD>F8 </TD><TD/><TD/><TD>20 </TD><TD/></TR><TR><TD>TRACEON </TD><TD>F9 </TD><TD/><TD/><TD>22 </TD><TD/></TR><TR><TD>TRACESTR </TD><TD>FA </TD><TD>aa…00 </TD><TD/><TD>8 </TD><TD/></TR><TR><TD>TRACEREG </TD><TD>FB </TD><TD>nn </TD><TD/><TD>28 </TD><TD/></TR><TR><TD>READVAR </TD><TD>FC </TD><TD>bb </TD><TD/><TD>5 </TD><TD/></TR><TR><TD>RESET </TD><TD>FF </TD><TD/><TD/><TD/><TD>(note 13) </TD></TR></Table><Sect><H5>Notes: </H5><L><LI><LI_Label>1. 	</LI_Label><LI_Title>The minimum Read Setup Delay must occur after all opcodes that return data. See the SPI or I2C instruction timing diagrams for details. </LI_Title></LI><LI><LI_Label>2. 	</LI_Label><LI_Title>Floating point values 1000.0 and 0.001 used for timing. </LI_Title></LI><LI><LI_Label>3. 	</LI_Label><LI_Title>Long integer values 100 and 100000 used for timing. </LI_Title></LI><LI><LI_Label>4. 	</LI_Label><LI_Title>Floating point values 30.0 and 0.001 used for timing. </LI_Title></LI><LI><LI_Label>5. 	</LI_Label><LI_Title>Strings 1.2, 1.23, 1.234, … 1.234567 used for timing. </LI_Title></LI><LI><LI_Label>6. 	</LI_Label><LI_Title>The timing depends on the register value and format speciﬁed. </LI_Title></LI><LI><LI_Label>7. 	</LI_Label><LI_Title>The timing depends on the user deﬁned function speciﬁed. </LI_Title></LI><LI><LI_Label>8. 	</LI_Label><LI_Title>Instruction only valid in Flash memory. </LI_Title></LI><LI><LI_Label>9. 	</LI_Label><LI_Title>Approximately (20 + 15 * order of the polynomial) microseconds. </LI_Title></LI><LI><LI_Label>10. </LI_Label><LI_Title>Floating point values 0.25 and 0.75 used for timing. </LI_Title></LI><LI><LI_Label>11. 	</LI_Label><LI_Title>Busy state is held indeﬁnitely until condition is met.</LI_Title></LI><LI><LI_Label>12. </LI_Label><LI_Title>Busy state is held indeﬁnitely until user continues execution from debugger.</LI_Title></LI><LI><LI_Label>13. </LI_Label><LI_Title>After 9 consecutive FF bytes the chip is reset, otherwise it is a NOP.</LI_Title></LI><LI><LI_Label>14. </LI_Label><LI_Title>Depends baud rate, number of characters and operation.</LI_Title></LI><L><LI><LI_Label>15. </LI_Label><LI_Title>The FFT instruction can do up to 64 point FFTs on-chip. The calculation times for these are as follows:2 point: 43 usec4 point: 175 usec8 point: 538 usec16 point: 1462 usec32 point: 3667 usec64 point: 8703 usec</LI_Title></LI><LI>If the data is on the microprocessor, then read/write data transfer times must be added. For larger FFTs, the FFT instruction is a multi-stage calculation.</LI></L><LI><LI_Label>16. </LI_Label><LI_Title>Depends on the transfer speed of the microcontroller.</LI_Title></LI><LI><LI_Label>17. </LI_Label><LI_Title>Depends on size of matrix and type of operation. </LI_Title></LI></L></Sect></Sect></Part></TaggedPDF-doc>