<?xml version="1.0" encoding="UTF-8" ?><!-- Created from PDF via Acrobat SaveAsXML --><!-- Mapping Table version: 28-February-2003 --><TaggedPDF-doc><?xpacket begin='﻿' id='W5M0MpCehiHzreSzNTczkc9d'?><?xpacket begin="﻿" id="W5M0MpCehiHzreSzNTczkc9d"?>
<x:xmpmeta xmlns:x="adobe:ns:meta/" x:xmptk="Adobe XMP Core 5.2-c001 63.139439, 2010/09/27-13:37:26        ">
   <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
      <rdf:Description rdf:about=""
            xmlns:pdf="http://ns.adobe.com/pdf/1.3/">
         <pdf:Producer>Acrobat Distiller 7.0 (Windows)</pdf:Producer>
      </rdf:Description>
      <rdf:Description rdf:about=""
            xmlns:pdfx="http://ns.adobe.com/pdfx/1.3/">
         <pdfx:SourceModified>D:20060127093652</pdfx:SourceModified>
      </rdf:Description>
      <rdf:Description rdf:about=""
            xmlns:xmp="http://ns.adobe.com/xap/1.0/">
         <xmp:CreateDate>2006-01-27T10:37:14+01:00</xmp:CreateDate>
         <xmp:CreatorTool>Acrobat PDFMaker 7.0 for Word</xmp:CreatorTool>
         <xmp:ModifyDate>2006-01-27T10:37:30+01:00</xmp:ModifyDate>
         <xmp:MetadataDate>2006-01-27T10:37:30+01:00</xmp:MetadataDate>
      </rdf:Description>
      <rdf:Description rdf:about=""
            xmlns:xmpMM="http://ns.adobe.com/xap/1.0/mm/">
         <xmpMM:DocumentID>uuid:46b23300-f8c5-4cbe-966b-3dd18f488d42</xmpMM:DocumentID>
         <xmpMM:InstanceID>uuid:7b6438f3-39d7-7a40-b398-b0d5ca35316d</xmpMM:InstanceID>
         <xmpMM:VersionID>
            <rdf:Seq>
               <rdf:li>36</rdf:li>
            </rdf:Seq>
         </xmpMM:VersionID>
      </rdf:Description>
      <rdf:Description rdf:about=""
            xmlns:dc="http://purl.org/dc/elements/1.1/">
         <dc:format>xml</dc:format>
         <dc:title>
            <rdf:Alt>
               <rdf:li xml:lang="x-default">Floating Point Unit</rdf:li>
            </rdf:Alt>
         </dc:title>
         <dc:creator>
            <rdf:Seq>
               <rdf:li>Jidan Al-Eryani</rdf:li>
            </rdf:Seq>
         </dc:creator>
         <dc:subject>
            <rdf:Bag>
               <rdf:li/>
            </rdf:Bag>
         </dc:subject>
      </rdf:Description>
      <rdf:Description rdf:about=""
            xmlns:photoshop="http://ns.adobe.com/photoshop/1.0/">
         <photoshop:headline>
            <rdf:Seq>
               <rdf:li/>
            </rdf:Seq>
         </photoshop:headline>
      </rdf:Description>
   </rdf:RDF>
</x:xmpmeta>
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                           
<?xpacket end="w"?><?xpacket end='r'?><bookmark-tree><bookmark title=" "><destination structID="LinkTarget_1225"/></bookmark><bookmark title="1. Introduction "><destination structID="LinkTarget_292"/></bookmark><bookmark title="2. Floating point numbers "><destination structID="LinkTarget_325"/></bookmark><bookmark title="3. IEEE Standard 754 for Binary Floating-Point Arithmetic "><destination structID="LinkTarget_350"/><bookmark title="3.1 Formats "><destination structID="LinkTarget_352"/></bookmark><bookmark title="3.2 Exceptions "><destination structID="LinkTarget_398"/><bookmark title="3.2.1 Invalid Operation "><destination structID="LinkTarget_401"/></bookmark><bookmark title="3.2.2 Division by Zero "><destination structID="LinkTarget_417"/></bookmark><bookmark title="3.2.3 Inexact "><destination structID="LinkTarget_420"/></bookmark><bookmark title="3.2.4 Underflow "><destination structID="LinkTarget_425"/></bookmark><bookmark title="3.2.5 Overflow "><destination structID="LinkTarget_428"/></bookmark><bookmark title="3.2.6 Infinity "><destination structID="LinkTarget_431"/></bookmark><bookmark title="3.2.7 Zero "><destination structID="LinkTarget_434"/></bookmark></bookmark><bookmark title=" "><destination structID="LinkTarget_437"/></bookmark><bookmark title="3.3 Rounding Modes "><destination structID="LinkTarget_438"/><bookmark title="3.3.1 Round to nearest even "><destination structID="LinkTarget_444"/></bookmark><bookmark title="3.3.2 Round-to-Zero "><destination structID="LinkTarget_453"/></bookmark><bookmark title="3.3.3 Round-Up "><destination structID="LinkTarget_456"/></bookmark><bookmark title="3.3.4 Round-Down "><destination structID="LinkTarget_461"/></bookmark></bookmark><bookmark title="4. Arithmetic on floating point numbers "><destination structID="LinkTarget_474"/><bookmark title="4.1 Addition and Subtraction "><destination structID="LinkTarget_478"/></bookmark><bookmark title=" "><destination structID="LinkTarget_520"/></bookmark><bookmark title="4.2 Multiplication "><destination structID="LinkTarget_522"/></bookmark><bookmark title="4.3 Division "><destination structID="LinkTarget_573"/></bookmark><bookmark title="4.4 Square-Root "><destination structID="LinkTarget_626"/></bookmark></bookmark><bookmark title=" "><destination structID="LinkTarget_634"/></bookmark><bookmark title="4. Hardware implementation "><destination structID="LinkTarget_636"/><bookmark title="4.1 Interface "><destination structID="LinkTarget_663"/></bookmark><bookmark title="4.2 Compilation and Synthesis "><destination structID="LinkTarget_670"/></bookmark><bookmark title="4.3 Test and verification "><destination structID="LinkTarget_706"/></bookmark><bookmark title="4.4 FPU comparsion "><destination structID="LinkTarget_713"/></bookmark></bookmark><bookmark title="5. Conclusion "><destination structID="LinkTarget_721"/></bookmark><bookmark title="6. References "><destination structID="LinkTarget_734"/></bookmark></bookmark></bookmark-tree><Sect><Normal> </Normal><Normal> </Normal><Normal><InlineShape><ImageData src="images/fpu_ip_opencores_jidan_2006_img_0.jpg"/></InlineShape> </Normal><Normal> </Normal><Normal>Jidan Al-Eryani </Normal><Normal> </Normal><Normal>jidan@gmx.net </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><Normal>Copyright (C) 2006 </Normal><Normal>Contents </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><TOC><TOCI><Link>1. Introduction....................................................................................................................1 </Link></TOCI><TOCI><Link>2. Floating point numbers.................................................................................................2 </Link></TOCI><TOCI><Link>3. IEEE Standard 754 for Binary Floating-Point Arithmetic..........................................3 </Link></TOCI><TOCI><Link>3.1 Formats.................................................................................................................................3 </Link></TOCI><TOCI><Link>3.2 Exceptions.............................................................................................................................5 </Link></TOCI><TOCI><Link>3.2.1 Invalid Operation..........................................................................................................................5 </Link></TOCI><TOCI><Link>3.2.2 Division by Zero...........................................................................................................................5 </Link></TOCI><TOCI><Link>3.2.3 Inexact...........................................................................................................................................5 </Link></TOCI><TOCI><Link>3.2.4 Underflow.....................................................................................................................................6 </Link></TOCI><TOCI><Link>3.2.5 Overflow.......................................................................................................................................6 </Link></TOCI><TOCI><Link>3.2.6 Infinity..........................................................................................................................................6 </Link></TOCI><TOCI><Link>3.2.7 Zero...............................................................................................................................................6 </Link></TOCI><TOCI><Link>3.3 Rounding Modes..................................................................................................................6 </Link></TOCI><TOCI><Link>3.3.1 Round to nearest even...................................................................................................................7 </Link></TOCI><TOCI><Link>3.3.2 Round-to-Zero...............................................................................................................................7 </Link></TOCI><TOCI><Link>3.3.3 Round-Up......................................................................................................................................7 </Link></TOCI><TOCI><Link>3.3.4 Round-Down.................................................................................................................................7 </Link></TOCI><TOCI><Link>4. Arithmetic on floating point numbers...........................................................................8 </Link></TOCI><TOCI><Link>4.1 Addition and Subtraction....................................................................................................8 </Link></TOCI><TOCI><Link>4.2 Multiplication.....................................................................................................................10 </Link></TOCI><TOCI><Link>4.3 Division................................................................................................................................12 </Link></TOCI><TOCI><Link>4.4 Square-Root........................................................................................................................14 </Link></TOCI><TOCI><Link>4. Hardware implementation...........................................................................................15 </Link></TOCI><TOCI><Link>4.1 Interface..............................................................................................................................17 </Link></TOCI><TOCI><Link>4.2 Compilation and Synthesis................................................................................................18 </Link></TOCI><TOCI><Link>4.3 Test and verification..........................................................................................................18 </Link></TOCI><TOCI><Link>4.4 FPU comparsion.................................................................................................................19 </Link></TOCI><TOCI><Link>5. Conclusion....................................................................................................................19 </Link></TOCI><TOCI><Link>6. References....................................................................................................................20 </Link></TOCI></TOC><heading-1 id="LinkTarget_1225"> </heading-1><Normal> </Normal><Normal> </Normal></Sect><Sect><heading-1 id="LinkTarget_292">1. Introduction </heading-1><Normal> </Normal><Normal> </Normal><Normal>The floating point unit (FPU) implemented during this project, is a 32-bit processing unit which allows arithmetic operations on floating point numbers. The FPU complies fully with the IEEE 754 Standard [1]. </Normal><Normal>The FPU supports the following arithmetic operations: </Normal><Normal> </Normal><L><LI><LBody>1. Add </LBody></LI><LI><LBody>2. Subtract </LBody></LI><LI><LBody>3. Multiply </LBody></LI><LI><LBody>4. Divide </LBody></LI><LI><LBody>5. Square Root </LBody></LI></L><Normal> </Normal><Normal>For each operation the following rounding modes are supported: </Normal><Normal> </Normal><L><LI><LBody>1. Round to nearest even </LBody></LI><LI><LBody>2. Round to zero </LBody></LI><LI><LBody>3. Round up </LBody></LI><LI><LBody>4. Round down </LBody></LI></L><Normal> </Normal><Normal> </Normal><Normal>The FPU was written in VHDL with top priority to be able to run at approximately 100-MHz and at the same time as small as possible. Meeting both goals at the same time was very difficult and tradeoffs were made.  </Normal><Normal>In the following sections I will explain the theory behind the FPU core and describe its implementation on hardware. </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><heading-1 id="LinkTarget_325">2. Floating point numbers </heading-1><Normal> </Normal><Normal> </Normal><Normal>The floating-point representation is one way to represent real numbers. A floating-point number n is represented with an exponent e and a mantissa m, so that: </Normal><Normal> </Normal><Normal>n = be × m, …where b is the base number (also called radix) </Normal><Normal> </Normal><Normal>So for example, if we choose the number n=17 and the base b=10, the floating-point representation of 17 would be: </Normal><Normal> </Normal><Normal>  17 = 101 x 1.7 </Normal><Normal> </Normal><Normal>Another way to represent real numbers is to use fixed-point number representation. A fixed-point number with 4 digits after the decimal point could be used to represent numbers such as: 1.0001, 12.1019, 34.0000, etc. Both representations are used depending on the situation. For the implementation on hardware, the base-2 exponents are used, since digital systems work with binary numbers. </Normal><Normal>Using base-2 arithmetic brings problems with it, so for example fractional powers of 10 like 0.1 or 0.01 cannot exactly be represented with the floating-point format, while with fixed-point format, the decimal point can be thought away (provided the value is within the range) giving an exact representation. Fixed-point arithmetic, which is faster than floating-point arithmetic, can then be used. This is one of the reasons why fixed-point representations are used for financial and commercial applications.  </Normal><Normal>The floating-point format can represent a wide range of scale without losing precision, while the fixed-point format has a fixed window of representation.  So for example in a 32-bit floating-point representation, numbers from 3.4 x 1038 to 1.4 x 10-45 can be represented with ease, which is one of the reasons why floating-point representation is the most common solution.  </Normal><Normal>Floating-point representations also include special values like infinity, Not-a-Number (e.g. result of square root of a negative number). </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><heading-1 id="LinkTarget_350">3. IEEE Standard 754 for Binary Floating-Point Arithmetic </heading-1><Normal> </Normal><heading-2 id="LinkTarget_352">3.1 Formats </heading-2><Normal> </Normal><Normal>The IEEE (Institute of Electrical and Electronics Engineers) has produced a Standard to define floating-point representation and arithmetic. Although there are other representations, it is the most common representation used for floating point numbers.  </Normal><Normal>The standard brought out by the IEEE come to be known as IEEE 754. </Normal><Normal>The standard specifies [1]: </Normal><Normal> </Normal><Normal>1) Basic and extended floating-point number formats </Normal><Normal>2) Add, subtract, multiply, divide, square root, remainder, and compare operations </Normal><Normal>3) Conversions between integer and floating-point formats </Normal><Normal>4) Conversions between different floating-point formats </Normal><Normal>5) Conversions between basic format floating-point numbers and decimal strings </Normal><Normal>6) Floating-point exceptions and their handling, including non numbers (NaNs) </Normal><Normal> </Normal><Normal> </Normal><Normal>When it comes to their precision and width in bits, the standard defines two groups: basic- and extended format. The extended format is implementation dependent and doesn’t concern this project. </Normal><Normal>The basic format is further divided into single-precision format with 32-bits wide, and double-precision format with 64-bits wide. The three basic components are the sign, exponent, and mantissa.  The storage layout for single-precision is show below: </Normal><Normal> </Normal><Normal>Single precision </Normal><Normal>     <InlineShape><ImageData src="images/fpu_ip_opencores_jidan_2006_img_1.jpg"/></InlineShape> </Normal><Normal> </Normal><Normal> </Normal><Normal>The most significant bit starts from the left. </Normal><Normal> </Normal><Normal>The double-precision doesn’t concern this project and therefore will not be discussed further.  </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><Normal>The number represented by the single-precision format is:  </Normal><Normal> </Normal><Normal>value   = (-1)s2e × 1.f  (normalized) when E &gt; 0 else </Normal><Normal>  = (-1)s2-126 × 0.f   (denormalized)  </Normal><Normal> </Normal><Normal>where </Normal><Normal>f  = (b23-1+b22-2+ bin +…+b0-23) where bin =1 or 0 </Normal><Normal>s = sign (0 is positive; 1 is negative) </Normal><Normal>E =biased exponent; Emax=255 , Emin=0. E=255 and E=0 are used to represent special values. </Normal><Normal>e =unbiased exponent; e = E – 127(bias) </Normal><Normal> </Normal><Normal>A bias of 127 is added to the actual exponent to make negative exponents possible without using a sign bit. So for example if the value 100 is stored in the exponent placeholder, the exponent is actually -27 (100 – 127).  Not the whole range of E is used to represent numbers. As you may have seen from the above formula, the leading fraction bit before the decimal point is actually implicit (not given) and can be 1 or 0 depending on the exponent and therefore saving one bit.  Below is a table with the corresponding values for a given representation to help better understand what was explained above: </Normal><Normal> </Normal><Normal> </Normal><Table><TBody><TR><TD><Normal>Sign(s) </Normal></TD><TD><Normal>Exponent(e) </Normal></TD><TD><Normal>Fraction </Normal></TD><TD><Normal>Value </Normal></TD></TR><TR><TD><Normal>0 </Normal></TD><TD><Normal>00000000 </Normal></TD><TD><Normal>00000000000000000000000</Normal></TD><TD><Normal>+0 </Normal><Normal>(positive zero) </Normal></TD></TR><TR><TD><Normal>1 </Normal></TD><TD><Normal>00000000 </Normal></TD><TD><Normal>00000000000000000000000</Normal></TD><TD><Normal>-0 </Normal><Normal>(negative zero) </Normal></TD></TR><TR><TD><Normal>1 </Normal></TD><TD><Normal>00000000 </Normal></TD><TD><Normal>10000000000000000000000</Normal></TD><TD><Normal>-20-127x0.(2-1)= </Normal><Normal>-20-127x 0.5 </Normal></TD></TR><TR><TD><Normal>0 </Normal></TD><TD><Normal>00000000 </Normal></TD><TD><Normal>00000000000000000000001</Normal></TD><TD><Normal>+20-127x0.(2-23) </Normal><Normal>(smallest value) </Normal></TD></TR><TR><TD><Normal>0 </Normal></TD><TD><Normal>00000001 </Normal></TD><TD><Normal>01000000000000000000000</Normal></TD><TD><Normal>+21-127x1.(2-2)= </Normal><Normal>+21-127x1.25 </Normal></TD></TR><TR><TD><Normal>0 </Normal></TD><TD><Normal>10000001 </Normal></TD><TD><Normal>00000000000000000000000</Normal></TD><TD><Normal>+2129-127x1.0= </Normal><Normal>4 </Normal></TD></TR><TR><TD><Normal>0 </Normal></TD><TD><Normal>11111111 </Normal></TD><TD><Normal>00000000000000000000000</Normal></TD><TD><Normal>+ infinity </Normal><Normal> </Normal></TD></TR><TR><TD><Normal>1 </Normal></TD><TD><Normal>11111111 </Normal></TD><TD><Normal>00000000000000000000000</Normal></TD><TD><Normal>- infinity </Normal><Normal> </Normal></TD></TR><TR><TD><Normal>0 </Normal></TD><TD><Normal>11111111 </Normal></TD><TD><Normal>10000000000000000000000</Normal></TD><TD><Normal>Not a Number(NaN)</Normal><Normal> </Normal></TD></TR><TR><TD><Normal>1 </Normal></TD><TD><Normal>11111111 </Normal></TD><TD><Normal>10000100010000000001100</Normal></TD><TD><Normal>Not a Number(NaN)</Normal><Normal> </Normal></TD></TR></TBody></Table><Normal> </Normal><Normal>   </Normal><Normal> </Normal><Normal> </Normal><heading-2 id="LinkTarget_398">3.2 Exceptions </heading-2><Normal> </Normal><Normal>The IEEE standard defines five types of exceptions that should be signaled through a one bit status flag when encountered. </Normal><heading-3 id="LinkTarget_401">3.2.1 Invalid Operation </heading-3><Normal> </Normal><Normal>Some arithmetic operations are invalid, such as a division by zero or square root of a negative number. The result of an invalid operation shall be a NaN. There are two types of NaN, quiet NaN (QNaN) and signaling NaN (SNaN). They have the following format, where s is the sign bit: </Normal><Normal> </Normal><Normal>QNaN  = s 11111111  10000000000000000000001 </Normal><Normal>SNaN  = s 11111111  00000000000000000000001 </Normal><Normal> </Normal><Normal>The result of every invalid operation shall be a QNaN string with a QNaN or SNaN exception.  The SNaN string can never be the result of any operation, only the SNaN exception can be signaled and this happens whenever one of the input operand is a SNaN string otherwise the QNaN exception will be signaled.  The SNaN exception can for example be used to signal operations with uninitialized operands, if we set the uninitialized operands to SNaN. However this is not the subject of this standard. </Normal><Normal> </Normal><Normal>The following are some arithmetic operations which are invalid operations and that give as a result a QNaN string and that signal a QNaN exception: </Normal><Normal> </Normal><Normal>1) Any operation on a NaN  </Normal><Normal>2) Addition or subtraction: ∞ + (−∞) </Normal><Normal>3) Multiplication: ± 0 × ± ∞ </Normal><Normal>4) Division: ± 0/ ± 0 or ± ∞/ ± ∞ </Normal><Normal>5) Square root: if the operand is less than zero </Normal><heading-3 id="LinkTarget_417">3.2.2 Division by Zero </heading-3><Normal> </Normal><Normal>The division of any number by zero other than zero itself gives infinity as a result. The addition or multiplication of two numbers may also give infinity as a result. So to differentiate between the two cases, a divide-by-zero exception was implemented. </Normal><heading-3 id="LinkTarget_420">3.2.3 Inexact </heading-3><Normal> </Normal><Normal>This exception should be signaled whenever the result of an arithmetic operation is not exact due to the restricted exponent and/or precision range. </Normal><Normal> </Normal><Normal> </Normal><heading-3 id="LinkTarget_425">3.2.4 Underflow </heading-3><Normal> </Normal><Normal>Two events cause the underflow exception to be signaled, tininess and loss of accuracy. Tininess is detected after or before rounding when a result lies between ±2Emin. Loss of accuracy is detected when the result is simply inexact or only when a denormalization loss occurs. The implementer has the choice to choose how these events are detected. They should be the same for all operations. The implemented FPU core signals an underflow exception whenever tininess is detected after rounding and at the same time the result is inexact. </Normal><heading-3 id="LinkTarget_428">3.2.5 Overflow </heading-3><Normal> </Normal><Normal>The overflow exception is signaled whenever the result exceeds the maximum value that can be represented due to the restricted exponent range. It is not signaled when one of the operands is infinity, because infinity arithmetic is always exact. Division by zero also doesn’t trigger this exception. </Normal><heading-3 id="LinkTarget_431">3.2.6 Infinity </heading-3><Normal> </Normal><Normal>This exception is signaled whenever the result is infinity without regard to how that occurred. This exception is not defined in the standard and was added to detect faster infinity results. </Normal><heading-3 id="LinkTarget_434">3.2.7 Zero </heading-3><Normal> </Normal><Normal>This exception is signaled whenever the result is zero without regard to how that occurred. This exception is not defined in the standard and was added to detect faster zero results. </Normal><heading-2 id="LinkTarget_437"> </heading-2><heading-2 id="LinkTarget_438">3.3 Rounding Modes </heading-2><Normal> </Normal><Normal>Since the result precision is not infinite, sometimes rounding is necessary.  To increase the precision of the result and to enable round-to-nearest-even rounding mode, three bits were added internally and temporally to the actual fraction: guard, round, and sticky bit. While guard and round bits are normal storage holders, the sticky bit is turned ‘1’ when ever a ‘1’ is shifted out of range.   </Normal><Normal>As an example we take a 5-bits binary number:  1.1001.  If we left-shift the number four positions, the number will be 0.0001, no rounding is possible and the result will no be accurate. Now, let’s say we add the three extra bits. After left-shifting the number four positions, the number will be 0.0001 101 (remember, the last bit is ‘1’ because a ‘1’ was shifted out). If we round it back to 5-bits it will yield: 0.0010, therefore giving a more accurate result. </Normal><Normal> </Normal><Normal>The standard specifies four rounding modes: </Normal><heading-3 id="LinkTarget_444">3.3.1 Round to nearest even </heading-3><Normal> </Normal><Normal>This is the standard default rounding. The value is rounded up or down to the nearest infinitely precise result. If the value is exactly halfway between two infinitely precise results, then it should be rounded up to the nearest infinitely precise even. </Normal><Normal> </Normal><Normal> </Normal><Normal>For example: </Normal><Normal> </Normal><Table><TBody><TR><TD><Normal>Unrounded </Normal></TD><TD><Normal>Rounded </Normal></TD></TR><TR><TD><Normal>3.4 </Normal></TD><TD><Normal>3 </Normal></TD></TR><TR><TD><Normal>5.6 </Normal></TD><TD><Normal>6 </Normal></TD></TR><TR><TD><Normal>3.5 </Normal></TD><TD><Normal>4 </Normal></TD></TR><TR><TD><Normal>2.5 </Normal></TD><TD><Normal>2 </Normal></TD></TR></TBody></Table><Normal> </Normal><heading-3 id="LinkTarget_453">3.3.2 Round-to-Zero </heading-3><Normal> </Normal><Normal>Basically in this mode the number will not be rounded. The excess bits will simply get truncated, e.g. 3.47 will be truncated to 3.4. </Normal><heading-3 id="LinkTarget_456">3.3.3 Round-Up </heading-3><Normal> </Normal><Normal>The number will be rounded up towards +∞, e.g. 3.2 will be rounded to 4, while -3.2 to  </Normal><Normal>-3. </Normal><Normal> </Normal><heading-3 id="LinkTarget_461">3.3.4 Round-Down </heading-3><Normal> </Normal><Normal>The opposite of round-up, the number will be rounded up towards -∞, e.g. 3,2 will be rounded to 3, while -3,2 to  -4. </Normal><Normal>  </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><heading-1 id="LinkTarget_474">4. Arithmetic on floating point numbers </heading-1><Normal> </Normal><Normal>In the following sections, the basic algorithms for arithmetic operations will be outlined. For more exact detail please see the VHDL code, the code was commented as much as possible. </Normal><Normal> </Normal><heading-2 id="LinkTarget_478">4.1 Addition and Subtraction </heading-2><Normal> </Normal><Normal>Addition and Subtraction operations on floating-point numbers are a lot more complex than that on integers. The basic algorithm for adding or subtracting FP numbers is shown in the following flow diagram. </Normal><Normal> </Normal><Normal><InlineShape><ImageData src="images/fpu_ip_opencores_jidan_2006_img_2.jpg"/></InlineShape> </Normal><Normal>An example is given below to demonstrate the basic steps for adding/subtracting two FP numbers. </Normal><Normal>Let’s say we want to add two 5-digits binary FP numbers: </Normal><Normal> </Normal><Normal>24 × 1.1001 </Normal><Normal>+ 22 × 1.0010 </Normal><Normal>_________________ </Normal><Normal> </Normal><Normal>Step1: get the number with the larger exponent and subtract it from the smaller exponent. </Normal><Normal> </Normal><Normal>eL = 24, eS = 22 , so diff = 4 -2 = 2 </Normal><Normal> </Normal><Normal>Step 2: shift the fraction with the smaller exponent diff positions to the right. We can now leave out the exponent since they are both equal. This gives us the following: </Normal><Normal> </Normal><Normal>1.1001   000 </Normal><Normal>+ 0.0100   100  </Normal><Normal>_________________ </Normal><Normal> </Normal><Normal>Step 3: Add both fractions </Normal><Normal> </Normal><Normal>1.1001   000 </Normal><Normal>+ 0.0100   100  </Normal><Normal>_________________ </Normal><Normal> 1.1101   100 </Normal><Normal> </Normal><Normal>Step 4: Round-to-nearest-even </Normal><Normal> </Normal><Normal>1.1110 </Normal><Normal> </Normal><Normal>Step 5: Result </Normal><Normal> </Normal><Normal>24 × 1.1110 </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><heading-2 id="LinkTarget_520"> </heading-2><Normal> </Normal><heading-2 id="LinkTarget_522">4.2 Multiplication </heading-2><Normal> </Normal><Normal> </Normal><Normal><InlineShape><ImageData src="images/fpu_ip_opencores_jidan_2006_img_3.jpg"/></InlineShape> </Normal><Normal> </Normal><Normal> </Normal><Normal>The multiplication was done parallel to save clock cycles, at the cost of hardware. </Normal><Normal>If done serial it would have taken 32 clock cycles (without pre-, post-normalization) instead of the actual 5 clock cycles needed. Disadvantage, the hardware needed for the parallel 32-bit multiplier is approximately 3 times that of serial. </Normal><Normal>To demonstrate the basic steps, let’s say we want to multiply two 5-digits FP numbers: </Normal><Normal> </Normal><Normal>2100 × 1.1001 </Normal><Normal>× 2110 × 1.0010 </Normal><Normal>_________________ </Normal><Normal> </Normal><Normal>Step 1:  multiply fractions and calculate the result exponent. </Normal><Normal> </Normal><Normal>1.1001 </Normal><Normal>× 1.0010 </Normal><Normal>_________________ </Normal><Normal>1.11000010   </Normal><Normal> </Normal><Normal>so fracO= 1.11000010  and eO = 2100+110-bias = 283 </Normal><Normal> </Normal><Normal>Step 2: Round the fraction to nearest-even </Normal><Normal> </Normal><Normal>fracO= 1.1100  </Normal><Normal> </Normal><Normal>Step 3: Result </Normal><Normal> </Normal><Normal> 283 × 1.1100 </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><heading-2 id="LinkTarget_573">4.3 Division </heading-2><Normal> </Normal><Normal> </Normal><Normal><InlineShape><ImageData src="images/fpu_ip_opencores_jidan_2006_img_4.jpg"/></InlineShape> </Normal><Normal> </Normal><Normal>The division was done serially using the basic algorithm taught in most schools, which is division through multiple subtractions. Since divisions are not needed as often as multiplications (divisions can be done also through multiplications!), it was implemented as serial and in the process saving some hardware area.  </Normal><Normal>To demonstrate the basic steps of division, let’s say we want to divide two 5-digits FP numbers: </Normal><Normal> </Normal><Normal>2110 × 1.0000 </Normal><Normal>÷ 2100 × 0.0011 </Normal><Normal>_________________ </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><Normal>Step 1: count leading zeros in both fractions. </Normal><Normal> </Normal><Normal>zA = 0, zB = 3 </Normal><Normal> </Normal><Normal> </Normal><Normal>Step 2: shift-left the fractions according to zA, zB . Calculate the result exponent </Normal><Normal> </Normal><Normal>fracA = 10000 00000 </Normal><Normal>fracB = 00000 11000 </Normal><Normal> </Normal><Normal>eO = 2110-100+bias-0+3 = 2140 </Normal><Normal> </Normal><Normal>Step 3: divide both fractions </Normal><Normal> </Normal><Normal>100000,0000 </Normal><Normal>÷ 000001,1000 </Normal><Normal>_________________ </Normal><Normal>            1,0101 </Normal><Normal> </Normal><Normal>Step 4: result </Normal><Normal>  </Normal><Normal> 1,0101 × 2140 </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><heading-2 id="LinkTarget_626">4.4 Square-Root </heading-2><Normal> </Normal><Normal><InlineShape><ImageData src="images/fpu_ip_opencores_jidan_2006_img_5.jpg"/></InlineShape> </Normal><Normal>* The sign of result is always positive except for -0 </Normal><Normal> </Normal><Normal>The square root is calculated using an iterative algorithm, which needs the same number of loops as the precision of the result.  The square-root algorithm used here doesn’t need any multipliers or divisors, because all multiplications were replaced with left-shifts and all divisions with right-shifts. This makes the algorithm very efficient and fast for hardware implementations. </Normal><Normal> </Normal><Normal> </Normal><heading-1 id="LinkTarget_634"> </heading-1><Normal> </Normal><heading-1 id="LinkTarget_636">4. Hardware implementation </heading-1><Normal> </Normal><Normal>The FPU core basic architecture is shown below: </Normal><Normal> </Normal><Normal><InlineShape><ImageData src="images/fpu_ip_opencores_jidan_2006_img_6.jpg"/></InlineShape> </Normal><Normal>The FPU core was designed to be as modular as possible. The current core supports five arithmetic operations: </Normal><Normal> </Normal><L><LI><LBody>1. Add </LBody></LI><LI><LBody>2. Subtract </LBody></LI><LI><LBody>3. Multiply </LBody></LI><LI><LBody>4. Divide </LBody></LI><LI><LBody>5. Square Root </LBody></LI></L><Normal> </Normal><Normal>To save logic elements on the chip, one can disable the arithmetic units that are not needed by modifying the output multiplexer code, since all units are totally independent from each other. Future arithmetic units can be added very easily just by instantiating the unit and connecting its output to the output multiplexer.  </Normal><Normal>All arithmetic operations have these three stages: </Normal><Normal> </Normal><L><LI><LBody>1. Pre-normalize:  the operands are transformed into formats that makes them easy and efficient to handle internally. </LBody></LI></L><Normal> </Normal><L><LI><LBody>2. Arithmetic core:  the basic arithmetic operations are done here. </LBody></LI></L><Normal> </Normal><L><LI><LBody>3. Post-normalize:  the result will be normalized if possible (leading bit before decimal point is 1, if possible) and then transformed into the format specified by the IEEE standard. </LBody></LI></L><Normal> </Normal><Normal>A common post-normalization unit for all arithmetic operations was not used, although it was possible to combine them all in one unit. It was not done so because:  </Normal><L><LI><LBody>• Post-normalizations differ from one arithmetic operation to another, e.g. the post-normalization unit for addition/subtraction needs 259 logic elements (LCs) while multiplication needs 889 LCs.  </LBody></LI><LI><LBody>• Most importantly, less clock cycles are needed for some operations </LBody></LI><LI><LBody>• Hardware can be saved if not all operations are wanted </LBody></LI></L><Normal> </Normal><Normal>Through pipelining the FPU core was able to reach higher fmax at the cost of throughput (more clock cycles). The number of clock cycles that the FPU needs for each arithmetic operation is listed below: </Normal><Normal> </Normal><Table><TBody><TR><TD><Normal>Operation </Normal></TD><TD><Normal>Number of clock cycles </Normal></TD></TR><TR><TD><Normal>Addition </Normal></TD><TD><Normal>7 </Normal></TD></TR><TR><TD><Normal>Subtraction </Normal></TD><TD><Normal>7 </Normal></TD></TR><TR><TD><Normal>Multiplication </Normal></TD><TD><Normal>12 </Normal></TD></TR><TR><TD><Normal>Division </Normal></TD><TD><Normal>34 </Normal></TD></TR><TR><TD><Normal>Square-root </Normal></TD><TD><Normal>35 </Normal></TD></TR></TBody></Table><Normal> </Normal><Normal>By lowering the amount of pipelining, the clock cycles needed can be reduced, but at the same time fmax decreases. To reduce the clock cycles needed and therefore increase the speed of processing without much effecting fmax, the precision can be decreased. So for example when dividing, the serial divider needs 26 clock cycles (again, without pre-, post-normalization) for the 24-bits precision result and the extra 3-bits to enable rounding. So if we reduced the precision to let’s say 10-bits, we can reduce the needed clock cycles to 13 clock cycles. The same thing can be done with the square root operation. Decreasing the precision will also save hardware area. </Normal><Normal> </Normal><heading-2 id="LinkTarget_663">4.1 Interface </heading-2><Normal> </Normal><Normal>Input signals: </Normal><Table><TBody><TR><TD><Normal>Signal Name </Normal></TD><TD><Normal>Width </Normal></TD><TD><Normal>Description </Normal></TD></TR><TR><TD><Normal>clk_i </Normal></TD><TD><Normal>1 </Normal></TD><TD><Normal>clock signal </Normal></TD></TR><TR><TD><Normal>opa_i </Normal></TD><TD><Normal>32 </Normal></TD><TD><Normal>operand A </Normal></TD></TR><TR><TD><Normal>opb_i </Normal></TD><TD><Normal>32 </Normal></TD><TD><Normal>operand B </Normal></TD></TR><TR><TD><Normal>fpu_op_i </Normal></TD><TD><Normal>3 </Normal></TD><TD><Normal>FPU operations: </Normal><Normal>000 = add, </Normal><Normal>001 = subtract, </Normal><Normal>010 = multiply, </Normal><Normal>011 = divide, </Normal><Normal>100 = square root </Normal><Normal>101 = unused </Normal><Normal>110 = unused </Normal><Normal>111 = unused </Normal></TD></TR><TR><TD><Normal>rmode_i </Normal></TD><TD><Normal>2 </Normal></TD><TD><Normal>Rounding modes: </Normal><Normal>00 = round to nearest even  </Normal><Normal>01 = round to zero </Normal><Normal>10 = round up </Normal><Normal>11 = round down </Normal></TD></TR><TR><TD><Normal>start_i </Normal></TD><TD><Normal>1 </Normal></TD><TD><Normal>Start signal </Normal></TD></TR></TBody></Table><Normal> </Normal><Normal>Output signals: </Normal><Table><TBody><TR><TD><Normal>Signal Name </Normal></TD><TD><Normal>Width </Normal></TD><TD><Normal>Description </Normal></TD></TR><TR><TD><Normal>output_o </Normal></TD><TD><Normal> </Normal></TD><TD><Normal>output </Normal></TD></TR><TR><TD><Normal>ready_o </Normal></TD><TD><Normal> </Normal></TD><TD><Normal>ready signal </Normal></TD></TR><TR><TD><Normal>Exceptions </Normal></TD></TR><TR><TD><Normal>ine_o </Normal></TD><TD><Normal>1 </Normal></TD><TD><Normal>inexact </Normal></TD></TR><TR><TD><Normal>overflow_o </Normal></TD><TD><Normal>1 </Normal></TD><TD><Normal>overflow </Normal></TD></TR><TR><TD><Normal>underflow_o </Normal></TD><TD><Normal>1 </Normal></TD><TD><Normal>underflow </Normal></TD></TR><TR><TD><Normal>div_zero_o </Normal></TD><TD><Normal>1 </Normal></TD><TD><Normal>divide by zero </Normal></TD></TR><TR><TD><Normal>inf_o </Normal></TD><TD><Normal>1 </Normal></TD><TD><Normal>infinity </Normal></TD></TR><TR><TD><Normal>zero_o </Normal></TD><TD><Normal>1 </Normal></TD><TD><Normal>zero </Normal></TD></TR><TR><TD><Normal>qnan_o </Normal></TD><TD><Normal>1 </Normal></TD><TD><Normal>QNaN </Normal></TD></TR><TR><TD><Normal>snan_o </Normal></TD><TD><Normal>1 </Normal></TD><TD><Normal>SNaN </Normal></TD></TR></TBody></Table><heading-2 id="LinkTarget_670">4.2 Compilation and Synthesis </heading-2><Normal> </Normal><Normal>The FPU core was compiled and synthesized successfully with Altera Quartus II v.5 and Synplify Pro 8.1. The  Cyclone I–EP1C6Q240C6  was the intended FPGA.  </Normal><Normal>The order in which the files shall be compiled are: </Normal><Normal> </Normal><Normal>fpupack.vhd </Normal><Normal>pre_norm_addsub.vhd </Normal><Normal>addsub_28.vhd </Normal><Normal>post_norm_addsub.vhd </Normal><Normal>pre_norm_mul.vhd </Normal><Normal>mul_24.vhd </Normal><Normal>post_norm_mul.vhd </Normal><Normal>pre_norm_div.vhd </Normal><Normal>serial_div.vhd </Normal><Normal>post_norm_div.vhd </Normal><Normal>pre_norm_sqrt.vhd </Normal><Normal>sqrt.vhd </Normal><Normal>post_norm_sqrt.vhd </Normal><Normal>comppack.vhd </Normal><Normal>fpu.vhd </Normal><Normal> </Normal><Normal>The number of Logic elements needed for each unit is shown below. </Normal><Normal> </Normal><Normal>Altera Quartus II v.5 </Normal><Normal> </Normal><Normal>fmax:  102.7 MHz </Normal><Normal> </Normal><Normal>Number of  logic elements:   </Normal><Normal>Addition unit:   684 </Normal><Normal>Multiplication unit:  1530 </Normal><Normal>Division unit:   928 </Normal><Normal>Square-root unit:  919 </Normal><Normal>Top unit:  326 </Normal><Normal>_______________________________ </Normal><Normal>Total:    4387 </Normal><Normal> </Normal><heading-2 id="LinkTarget_706">4.3 Test and verification </heading-2><Normal> </Normal><Normal>The FPU was tested in Modelsim with all boundary values known and some miscellaneous values. The output result of the FPU was then compared in a test bench with hand calculated results and Usselmann’s FPU [4]. The reasons for choosing this 2nd FPU is because its open source and supposedly the FPU complies fully with IEEE 754 and was tested with over 14 Million test vectors [4]. However, during the verification bugs were fond on his FPU. Worth mentioning is also that the underflow flag is signaled differently. </Normal><Normal>That’s why, hand calculated results in parallel with the results of the 2nd FPU were used to verify the FPU.  </Normal><Normal>The FPU mastered also successfully the hardware test. The test was was done in connection with the Java processor JOP (<Link>www.jopdesign.com</Link>). </Normal><Normal> </Normal><Normal> </Normal><heading-2 id="LinkTarget_713">4.4 FPU comparsion </heading-2><Normal> </Normal><Normal>I compared the FPU presented here with Usselmann’s FPU, since it was the only open source FPU known to me. Both FPU’s were tested with Altera Quartus II v.5 using Cyclone I–EP1C6Q240C6. Summery of the most important parameters are shown in the table below. </Normal><Normal> </Normal><Table><TBody><TR><TD><Normal> </Normal></TD><TD><Normal>FPU #1 (presented here) </Normal></TD><TD><Normal>FPU #2 (Usselmann) </Normal></TD></TR><TR><TD><Normal>Nr. of logic elements </Normal></TD><TD><Normal>*3468 </Normal></TD><TD><Normal>7392 </Normal></TD></TR><TR><TD><Normal>fmax </Normal></TD><TD><Normal>102.7 MHz </Normal></TD><TD><Normal>6.17 MHz </Normal></TD></TR><TR><TD><Normal>Clock Cycles </Normal></TD></TR><TR><TD><Normal>Addition/Subtraction </Normal></TD><TD><Normal>7 </Normal></TD><TD><Normal>3 </Normal></TD></TR><TR><TD><Normal>Multiplication </Normal></TD><TD><Normal>12 </Normal></TD><TD><Normal>3 </Normal></TD></TR><TR><TD><Normal>Division </Normal></TD><TD><Normal>34 </Normal></TD><TD><Normal>3 </Normal></TD></TR><TR><TD><Normal>Square-root </Normal></TD><TD><Normal>35 </Normal></TD><TD><Normal>NA </Normal></TD></TR></TBody></Table><Normal> </Normal><Normal>* Without the square-unit </Normal><Normal> </Normal><heading-1 id="LinkTarget_721">5. Conclusion </heading-1><Normal> </Normal><Normal> </Normal><Normal>An FPU was implemented, which successfully achieved the goals stated at the beginning which were: </Normal><L><LI><LBody>• 100 MHz operating frequency </LBody></LI><LI><LBody>• Few clock cycles </LBody></LI><LI><LBody>• Few logic elements </LBody></LI></L><Normal> </Normal><Normal>Further, the FPU was tested, verified, and implemented in hardware successfully. </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><Normal> </Normal><Normal>  </Normal><heading-1 id="LinkTarget_734">6. References </heading-1><Normal> </Normal><L><LI><LBody>1. IEEE computer society: IEEE Standard 754 for Binary Floating-Point Arithmetic, 1985. </LBody></LI></L><Normal> </Normal><L><LI><LBody>2. David Goldberg: What Every Computer Scientist Should Know About Floating-Point Arithmetic, 1991. </LBody></LI></L><Normal> </Normal><L><LI><LBody>3. W. Kahan: IEEE Standard 754 for Binary Floating-Point Arithmetic, 1996. </LBody></LI></L><Normal> </Normal><L><LI><LBody>4. Rudolf Usselmann: Floating Point Unit, <Link>http://www.opencores.org/projects.cgi/web/fpu/overview</Link>, 2005. </LBody></LI></L><Normal> </Normal></Sect></TaggedPDF-doc>