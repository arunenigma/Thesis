<?xml version="1.0" encoding="UTF-8" ?><!-- Created from PDF via Acrobat SaveAsXML --><!-- Mapping Table version: 28-February-2003 --><TaggedPDF-doc><?xpacket begin='﻿' id='W5M0MpCehiHzreSzNTczkc9d'?><?xpacket begin="﻿" id="W5M0MpCehiHzreSzNTczkc9d"?>
<x:xmpmeta xmlns:x="adobe:ns:meta/" x:xmptk="Adobe XMP Core 5.2-c001 63.139439, 2010/09/27-13:37:26        ">
   <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
      <rdf:Description rdf:about=""
            xmlns:dc="http://purl.org/dc/elements/1.1/">
         <dc:format>xml</dc:format>
         <dc:description>
            <rdf:Alt>
               <rdf:li xml:lang="x-default">Megafunctions that perform floating-point arithmetic in FPGAs through parameterizable functions</rdf:li>
            </rdf:Alt>
         </dc:description>
         <dc:title>
            <rdf:Alt>
               <rdf:li xml:lang="x-default">Floating-Point Megafunctions User Guide</rdf:li>
            </rdf:Alt>
         </dc:title>
         <dc:creator>
            <rdf:Seq>
               <rdf:li>Altera Corporation</rdf:li>
            </rdf:Seq>
         </dc:creator>
      </rdf:Description>
      <rdf:Description rdf:about=""
            xmlns:pdf="http://ns.adobe.com/pdf/1.3/">
         <pdf:Producer>Acrobat Distiller 9.4.6 (Windows)</pdf:Producer>
         <pdf:Keywords>floating-point; fixed-point; arithmetic; inverse; inverse square root; absolute value; exponential; divider; adder; subtractor; multiplier; matrix multiplier; square root; logarithm; converter; comparator; matrix inverse; trigonometric; sine; cosine</pdf:Keywords>
         <pdf:Copyright>(c) 2011, Altera Corporation. All rights reserved.</pdf:Copyright>
      </rdf:Description>
      <rdf:Description rdf:about=""
            xmlns:xmp="http://ns.adobe.com/xap/1.0/">
         <xmp:CreatorTool>FrameMaker 9.0</xmp:CreatorTool>
         <xmp:ModifyDate>2011-11-08T18:01:12+08:00</xmp:ModifyDate>
         <xmp:CreateDate>2011-11-08T17:24:25Z</xmp:CreateDate>
         <xmp:MetadataDate>2011-11-08T18:01:12+08:00</xmp:MetadataDate>
      </rdf:Description>
      <rdf:Description rdf:about=""
            xmlns:pdfx="http://ns.adobe.com/pdfx/1.3/">
         <pdfx:Copyright>(c) 2011, Altera Corporation. All rights reserved.</pdfx:Copyright>
      </rdf:Description>
      <rdf:Description rdf:about=""
            xmlns:xmpMM="http://ns.adobe.com/xap/1.0/mm/">
         <xmpMM:DocumentID>uuid:e777e222-81d7-49ea-aba7-e7c29ea712eb</xmpMM:DocumentID>
         <xmpMM:InstanceID>uuid:aa1b9256-4826-1e47-8a95-494223a127c1</xmpMM:InstanceID>
      </rdf:Description>
   </rdf:RDF>
</x:xmpmeta>
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                           
<?xpacket end="w"?><?xpacket end='r'?><bookmark-tree><bookmark title="Floating-Point Megafunctions User Guide"><destination structID="LinkTarget_7150"/><bookmark title="1. About Floating-Point Megafunctions"><destination structID="LinkTarget_7151"/><bookmark title="Device Family Support"><destination structID="LinkTarget_7152"/></bookmark><bookmark title="General Features"><destination structID="LinkTarget_7153"/></bookmark><bookmark title="IEEE-754 Standard for Floating-Point Arithmetic"><destination structID="LinkTarget_7154"/><bookmark title="Floating-Point Formats"><destination structID="LinkTarget_7155"/><bookmark title="Single-Precision Format"><destination structID="LinkTarget_7156"/></bookmark><bookmark title="Double-Precision Format"><destination structID="LinkTarget_7157"/></bookmark><bookmark title="Single-Extended Precision Format"><destination structID="LinkTarget_7158"/></bookmark></bookmark><bookmark title="Special Case Numbers"><destination structID="LinkTarget_7159"/></bookmark><bookmark title="Rounding"><destination structID="LinkTarget_7160"/></bookmark></bookmark><bookmark title="Non-IEEE-754 Standard Format"><destination structID="LinkTarget_7161"/></bookmark><bookmark title="Output Latency"><destination structID="LinkTarget_7162"/></bookmark><bookmark title="Design Flow"><destination structID="LinkTarget_7163"/></bookmark><bookmark title="Design Example Files"><destination structID="LinkTarget_7164"/></bookmark></bookmark><bookmark title="2. ALTFP_ADD_SUB"><destination structID="LinkTarget_7165"/><bookmark title="Features"><destination structID="LinkTarget_7166"/></bookmark><bookmark title="Output Latency"><destination structID="LinkTarget_7167"/></bookmark><bookmark title="Truth Table"><destination structID="LinkTarget_7168"/></bookmark><bookmark title="Resource Utilization and Performance"><destination structID="LinkTarget_7169"/></bookmark><bookmark title="Design Example: Addition of Double-Precision Format Numbers"><destination structID="LinkTarget_7170"/><bookmark title="Design Files"><destination structID="LinkTarget_7171"/></bookmark><bookmark title="Understanding the Simulation Results"><destination structID="LinkTarget_7172"/></bookmark></bookmark><bookmark title="Specifications"><destination structID="LinkTarget_7173"/><bookmark title="VHDL Component Declaration"><destination structID="LinkTarget_7174"/></bookmark><bookmark title="VHDL LIBRARY-USE Declaration"><destination structID="LinkTarget_7175"/></bookmark><bookmark title="Ports and Parameters"><destination structID="LinkTarget_7176"/></bookmark></bookmark></bookmark><bookmark title="3. ALTFP_DIV"><destination structID="LinkTarget_7177"/><bookmark title="Features"><destination structID="LinkTarget_7178"/></bookmark><bookmark title="Output Latency"><destination structID="LinkTarget_7179"/></bookmark><bookmark title="Truth Table"><destination structID="LinkTarget_7180"/></bookmark><bookmark title="Resource Utilization and Performance"><destination structID="LinkTarget_7181"/></bookmark><bookmark title="Design Example: Division of Single-Precision Format Numbers with Low Latency"><destination structID="LinkTarget_7182"/><bookmark title="Design Files"><destination structID="LinkTarget_7183"/></bookmark><bookmark title="Understanding the Simulation Results"><destination structID="LinkTarget_7184"/></bookmark></bookmark><bookmark title="Specifications"><destination structID="LinkTarget_7185"/><bookmark title="VHDL Component Declaration"><destination structID="LinkTarget_7186"/></bookmark><bookmark title="VHDL LIBRARY-USE Declaration"><destination structID="LinkTarget_7187"/></bookmark><bookmark title="Ports and Parameters"><destination structID="LinkTarget_7188"/></bookmark></bookmark></bookmark><bookmark title="4. ALTFP_MULT"><destination structID="LinkTarget_7189"/><bookmark title="Features"><destination structID="LinkTarget_7190"/></bookmark><bookmark title="Output Latency"><destination structID="LinkTarget_7191"/></bookmark><bookmark title="Truth Table"><destination structID="LinkTarget_7192"/></bookmark><bookmark title="Resource Utilization and Performance"><destination structID="LinkTarget_7193"/></bookmark><bookmark title="Design Example: Multiplication of Double-Precision Format Numbers"><destination structID="LinkTarget_7194"/><bookmark title="Design Files"><destination structID="LinkTarget_7195"/></bookmark><bookmark title="Understanding the Simulation Results"><destination structID="LinkTarget_7196"/></bookmark></bookmark><bookmark title="Specifications"><destination structID="LinkTarget_7197"/><bookmark title="VHDL Component Declaration"><destination structID="LinkTarget_7198"/></bookmark><bookmark title="VHDL LIBRARY-USE Declaration"><destination structID="LinkTarget_7199"/></bookmark><bookmark title="Ports and Parameters"><destination structID="LinkTarget_7200"/></bookmark></bookmark></bookmark><bookmark title="5. ALTFP_SQRT"><destination structID="LinkTarget_7201"/><bookmark title="Features"><destination structID="LinkTarget_7202"/></bookmark><bookmark title="Output Latency"><destination structID="LinkTarget_7203"/></bookmark><bookmark title="Truth Table"><destination structID="LinkTarget_7204"/></bookmark><bookmark title="Resource Utilization and Performance"><destination structID="LinkTarget_7205"/></bookmark><bookmark title="Design Example: Square Root of Single-Precision Format Numbers"><destination structID="LinkTarget_7206"/><bookmark title="Design Files"><destination structID="LinkTarget_7207"/></bookmark><bookmark title="Understanding the Simulation Results"><destination structID="LinkTarget_7208"/></bookmark></bookmark><bookmark title="Specifications"><destination structID="LinkTarget_7209"/><bookmark title="VHDL Component Declaration"><destination structID="LinkTarget_7210"/></bookmark><bookmark title="VHDL LIBRARY-USE Declaration"><destination structID="LinkTarget_7211"/></bookmark><bookmark title="Ports and Parameters"><destination structID="LinkTarget_7212"/></bookmark></bookmark></bookmark><bookmark title="6. ALTFP_EXP"><destination structID="LinkTarget_7213"/><bookmark title="Features"><destination structID="LinkTarget_7214"/></bookmark><bookmark title="Output Latency"><destination structID="LinkTarget_7215"/></bookmark><bookmark title="Truth Table"><destination structID="LinkTarget_7216"/></bookmark><bookmark title="Resource Utilization and Performance"><destination structID="LinkTarget_7217"/></bookmark><bookmark title="Design Example: Exponential of Single-Precision Format Numbers"><destination structID="LinkTarget_7218"/><bookmark title="Design Files"><destination structID="LinkTarget_7219"/></bookmark><bookmark title="Understanding the Simulation Results"><destination structID="LinkTarget_7220"/></bookmark></bookmark><bookmark title="Specifications"><destination structID="LinkTarget_7221"/><bookmark title="VHDL Component Declaration"><destination structID="LinkTarget_7222"/></bookmark><bookmark title="VHDL LIBRARY-USE Declaration"><destination structID="LinkTarget_7223"/></bookmark><bookmark title="Ports and Parameters"><destination structID="LinkTarget_7224"/></bookmark></bookmark></bookmark><bookmark title="7. ALTFP_INV"><destination structID="LinkTarget_7225"/><bookmark title="Features"><destination structID="LinkTarget_7226"/></bookmark><bookmark title="Output Latency"><destination structID="LinkTarget_7227"/></bookmark><bookmark title="Truth Table"><destination structID="LinkTarget_7228"/></bookmark><bookmark title="Resource Utilization and Performance"><destination structID="LinkTarget_7229"/></bookmark><bookmark title="Design Example: Inverse of Single-Precision Format Numbers"><destination structID="LinkTarget_7230"/><bookmark title="Design Files"><destination structID="LinkTarget_7231"/></bookmark><bookmark title="Understanding the Simulation Results"><destination structID="LinkTarget_7232"/></bookmark></bookmark><bookmark title="Specifications"><destination structID="LinkTarget_7233"/><bookmark title="VHDL Component Declaration"><destination structID="LinkTarget_7234"/></bookmark><bookmark title="VHDL LIBRARY-USE Declaration"><destination structID="LinkTarget_7235"/></bookmark><bookmark title="Ports and Parameters"><destination structID="LinkTarget_7236"/></bookmark></bookmark></bookmark><bookmark title="8. ALTFP_INV_SQRT"><destination structID="LinkTarget_7237"/><bookmark title="Features"><destination structID="LinkTarget_7238"/></bookmark><bookmark title="Output Latency"><destination structID="LinkTarget_7239"/></bookmark><bookmark title="Truth Table"><destination structID="LinkTarget_7240"/></bookmark><bookmark title="Resource Utilization and Performance"><destination structID="LinkTarget_7241"/></bookmark><bookmark title="Design Example: Inverse Square Root of Single-Precision Format Numbers"><destination structID="LinkTarget_7242"/><bookmark title="Design Files"><destination structID="LinkTarget_7243"/></bookmark><bookmark title="Understanding the Simulation Results"><destination structID="LinkTarget_7244"/></bookmark></bookmark><bookmark title="Specifications"><destination structID="LinkTarget_7245"/><bookmark title="VHDL Component Declaration"><destination structID="LinkTarget_7246"/></bookmark><bookmark title="VHDL LIBRARY-USE Declaration"><destination structID="LinkTarget_7247"/></bookmark><bookmark title="Ports and Parameters"><destination structID="LinkTarget_7248"/></bookmark></bookmark></bookmark><bookmark title="9. ALTFP_LOG"><destination structID="LinkTarget_7249"/><bookmark title="Features"><destination structID="LinkTarget_7250"/></bookmark><bookmark title="Output Latency"><destination structID="LinkTarget_7251"/></bookmark><bookmark title="Truth Table"><destination structID="LinkTarget_7252"/></bookmark><bookmark title="Resource Utilization and Performance"><destination structID="LinkTarget_7253"/></bookmark><bookmark title="Design Example: Natural Logarithm of Single-Precision Format Numbers"><destination structID="LinkTarget_7254"/><bookmark title="Design Files"><destination structID="LinkTarget_7255"/></bookmark><bookmark title="Understanding the Simulation Results"><destination structID="LinkTarget_7256"/></bookmark></bookmark><bookmark title="Specifications"><destination structID="LinkTarget_7257"/><bookmark title="VHDL Component Declaration"><destination structID="LinkTarget_7258"/></bookmark><bookmark title="VHDL LIBRARY-USE Declaration"><destination structID="LinkTarget_7259"/></bookmark><bookmark title="Ports and Parameters"><destination structID="LinkTarget_7260"/></bookmark></bookmark></bookmark><bookmark title="10. ALTFP_ATAN"><destination structID="LinkTarget_7261"/><bookmark title="Features"><destination structID="LinkTarget_7262"/></bookmark><bookmark title="Output Latency"><destination structID="LinkTarget_7263"/></bookmark><bookmark title="Resource Utilization and Performance"><destination structID="LinkTarget_7264"/></bookmark><bookmark title="Specifications"><destination structID="LinkTarget_7265"/><bookmark title="VHDL Component Declaration"><destination structID="LinkTarget_7266"/></bookmark><bookmark title="VHDL LIBRARY-USE Declaration"><destination structID="LinkTarget_7267"/></bookmark><bookmark title="Ports and Parameters"><destination structID="LinkTarget_7268"/></bookmark></bookmark></bookmark><bookmark title="11. ALTFP_SINCOS"><destination structID="LinkTarget_7269"/><bookmark title="Features"><destination structID="LinkTarget_7270"/></bookmark><bookmark title="Output Latency"><destination structID="LinkTarget_7271"/></bookmark><bookmark title="Resource Utilization and Performance"><destination structID="LinkTarget_7272"/></bookmark><bookmark title="Specifications"><destination structID="LinkTarget_7273"/><bookmark title="VHDL Component Declaration"><destination structID="LinkTarget_7274"/></bookmark><bookmark title="VHDL LIBRARY-USE Declaration"><destination structID="LinkTarget_7275"/></bookmark><bookmark title="Ports and Parameters"><destination structID="LinkTarget_7276"/></bookmark></bookmark></bookmark><bookmark title="12. ALTFP_ABS"><destination structID="LinkTarget_7277"/><bookmark title="Features"><destination structID="LinkTarget_7278"/></bookmark><bookmark title="Output Latency"><destination structID="LinkTarget_7279"/></bookmark><bookmark title="Resource Utilization and Performance"><destination structID="LinkTarget_7280"/></bookmark><bookmark title="Design Example: Absolute Value of Multiplication Results"><destination structID="LinkTarget_7281"/><bookmark title="Design Files"><destination structID="LinkTarget_7282"/></bookmark><bookmark title="Understanding the Simulation Results"><destination structID="LinkTarget_7283"/></bookmark></bookmark><bookmark title="Specifications"><destination structID="LinkTarget_7284"/><bookmark title="VHDL Component Declaration"><destination structID="LinkTarget_7285"/></bookmark><bookmark title="VHDL LIBRARY-USE Declaration"><destination structID="LinkTarget_7286"/></bookmark><bookmark title="Ports and Parameters"><destination structID="LinkTarget_7287"/></bookmark></bookmark></bookmark><bookmark title="13. ALTFP_COMPARE"><destination structID="LinkTarget_7288"/><bookmark title="Features"><destination structID="LinkTarget_7289"/></bookmark><bookmark title="Output Latency"><destination structID="LinkTarget_7290"/></bookmark><bookmark title="Resource Utilization and Performance"><destination structID="LinkTarget_7291"/></bookmark><bookmark title="Design Example: Comparison of Single-precision Format Numbers"><destination structID="LinkTarget_7292"/><bookmark title="Design Files"><destination structID="LinkTarget_7293"/></bookmark><bookmark title="Understanding the Simulation Results"><destination structID="LinkTarget_7294"/></bookmark></bookmark><bookmark title="Specifications"><destination structID="LinkTarget_7295"/><bookmark title="VHDL Component Declaration"><destination structID="LinkTarget_7296"/></bookmark><bookmark title="VHDL LIBRARY-USE Declaration"><destination structID="LinkTarget_7297"/></bookmark><bookmark title="Ports and Parameters"><destination structID="LinkTarget_7298"/></bookmark></bookmark></bookmark><bookmark title="14. ALTFP_CONVERT"><destination structID="LinkTarget_7299"/><bookmark title="Features"><destination structID="LinkTarget_7300"/></bookmark><bookmark title="Conversion Operations"><destination structID="LinkTarget_7301"/><bookmark title="Integer-to-Float Conversion"><destination structID="LinkTarget_7302"/></bookmark><bookmark title="Float-to-Integer Conversion"><destination structID="LinkTarget_7303"/></bookmark><bookmark title="Float-to-Float Conversion"><destination structID="LinkTarget_7304"/></bookmark><bookmark title="Fixed-to-Float Conversion"><destination structID="LinkTarget_7305"/></bookmark><bookmark title="Float-to-Fixed Conversion"><destination structID="LinkTarget_7306"/></bookmark></bookmark><bookmark title="Output Latency"><destination structID="LinkTarget_7307"/></bookmark><bookmark title="Resource Utilization and Performance"><destination structID="LinkTarget_7308"/></bookmark><bookmark title="Design Example: Convert Double-Precision Floating-Point Format Numbers to 64-bit Integers"><destination structID="LinkTarget_7309"/><bookmark title="Design Files"><destination structID="LinkTarget_7310"/></bookmark><bookmark title="Understanding the Simulation Results"><destination structID="LinkTarget_7311"/></bookmark></bookmark><bookmark title="Specifications"><destination structID="LinkTarget_7312"/><bookmark title="VHDL Component Declaration"><destination structID="LinkTarget_7313"/></bookmark><bookmark title="VHDL LIBRARY-USE Declaration"><destination structID="LinkTarget_7314"/></bookmark><bookmark title="Ports and Parameters"><destination structID="LinkTarget_7315"/></bookmark></bookmark></bookmark><bookmark title="15. ALTFP_MATRIX_INV"><destination structID="LinkTarget_7316"/><bookmark title="Features"><destination structID="LinkTarget_7317"/></bookmark><bookmark title="Output Latency"><destination structID="LinkTarget_7318"/></bookmark><bookmark title="Resource Utilization and Performance"><destination structID="LinkTarget_7319"/></bookmark><bookmark title="Functional Description"><destination structID="LinkTarget_7320"/><bookmark title="Cholesky Decomposition Function"><destination structID="LinkTarget_7321"/></bookmark><bookmark title="Triangular Matrix Inversion Algorithm"><destination structID="LinkTarget_7322"/></bookmark><bookmark title="Matrix Multiplication"><destination structID="LinkTarget_7323"/></bookmark><bookmark title="Matrix Inversion Operation"><destination structID="LinkTarget_7324"/></bookmark></bookmark><bookmark title="Design Example: Matrix Inverse of Single-Precision Format Numbers"><destination structID="LinkTarget_7325"/><bookmark title="Design Files"><destination structID="LinkTarget_7326"/></bookmark><bookmark title="Understanding the Simulation Results"><destination structID="LinkTarget_7327"/></bookmark></bookmark><bookmark title="Sample Matrix Data"><destination structID="LinkTarget_7328"/></bookmark><bookmark title="Specifications"><destination structID="LinkTarget_7329"/><bookmark title="VHDL Component Declaration"><destination structID="LinkTarget_7330"/></bookmark><bookmark title="VHDL LIBRARY-USE Declaration"><destination structID="LinkTarget_7331"/></bookmark><bookmark title="Ports and Parameters"><destination structID="LinkTarget_7332"/></bookmark></bookmark></bookmark><bookmark title="16. ALTFP_MATRIX_MULT"><destination structID="LinkTarget_7333"/><bookmark title="Features"><destination structID="LinkTarget_7334"/></bookmark><bookmark title="Output Latency"><destination structID="LinkTarget_7335"/></bookmark><bookmark title="Resource Utilization and Performance"><destination structID="LinkTarget_7336"/></bookmark><bookmark title="Functional Description"><destination structID="LinkTarget_7337"/><bookmark title="AA and BB Matrix Storage"><destination structID="LinkTarget_7338"/></bookmark><bookmark title="Cache Storage"><destination structID="LinkTarget_7339"/></bookmark><bookmark title="Matrix Multiplication Operation"><destination structID="LinkTarget_7340"/><bookmark title="Example 1"><destination structID="LinkTarget_7341"/></bookmark><bookmark title="Example 2"><destination structID="LinkTarget_7342"/></bookmark></bookmark></bookmark><bookmark title="Design Example: Matrix Multiplication of Single-Precision Format Numbers"><destination structID="LinkTarget_7343"/><bookmark title="Design Files"><destination structID="LinkTarget_7344"/></bookmark><bookmark title="Understanding the Simulation Results"><destination structID="LinkTarget_7345"/></bookmark><bookmark title="Sample Matrix Data"><destination structID="LinkTarget_7346"/></bookmark></bookmark><bookmark title="Specifications"><destination structID="LinkTarget_7347"/><bookmark title="VHDL Component Declaration"><destination structID="LinkTarget_7348"/></bookmark><bookmark title="VHDL LIBRARY-USE Declaration"><destination structID="LinkTarget_7349"/></bookmark><bookmark title="Ports and Parameters"><destination structID="LinkTarget_7350"/></bookmark></bookmark><bookmark title="Document Revision History"><destination structID="LinkTarget_7351"/></bookmark></bookmark></bookmark></bookmark-tree><Figure id="LinkTarget_7150"><ImageData src="images/math_ip_altera_megafunctions_img_0.jpg"/></Figure><P>Floating-Point Megafunctions 
</P><Part><Sect><H2>User Guide 
</H2></Sect><Figure><ImageData src="images/math_ip_altera_megafunctions_img_1.jpg"/></Figure><P>101 Innovation Drive San Jose, CA 95134 </P><P><Link>www.altera.com </Link></P><Sect><P>Copyright © 2011 Altera Corporation. All rights reserved. Altera, The Programmable Solutions Company, the stylized Altera logo, and specific device designations are trademarks and/or service marks of Altera Corporation in the U.S. and other countries. All other words and logos identified as trademarks and/or service marks are the property of Altera Corporation or their respective owners. Altera products are protected under numerous U.S. and foreign patents and pending applications, maskwork rights, and copyrights. Altera warrants performance of its semiconductor products to current specifications in accordance with Altera's standard warranty, but reserves the right to make changes to any products and services at any time without notice. Altera assumes no responsibility or liability arising out of the application or use of any information, product, or service described herein except as expressly agreed to in writing by Altera. Altera customers are advised to obtain the latest version of device specifications before relying on any published information and before placing orders for products or services. </P><Figure><ImageData src="images/math_ip_altera_megafunctions_img_2.jpg"/></Figure></Sect><P>UG-01058-6.0 Document last updated for Altera Complete Design Suite version: 
Document publication date: November 2011 
</P><Link><Sect><Figure><ImageData src="images/math_ip_altera_megafunctions_img_3.jpg"/></Figure></Sect></Link><Sect><P>Subscribe </P></Sect><Figure><ImageData src="images/math_ip_altera_megafunctions_img_4.jpg"/></Figure><Sect><Sect><H2 id="LinkTarget_7151">1. About Floating-Point Megafunctions 
</H2><P>This user guide provides information about the Altera® floating-point megafunctions, which enable you to perform floating-point arithmetic in FPGAs through optimized parameterizable functions for Altera device architectures. You can customize the megafunctions by configuring various parameters to accommodate your needs. </P><P><Link>Table 1–1</Link> lists the floating-point megafunctions described in this user guide. </P><P>Table 1–1. List of Megafunctions </P></Sect><Table><TR><TD>Megafunction Name </TD><TD/><TD>Function Overview </TD></TR><TR><TD>Operator Functions </TD><TD/></TR><TR><TD><Link>ALTFP_ADD_SUB </Link></TD><TD/><TD>Adder/Subtractor </TD></TR><TR><TD><Link>ALTFP_DIV</Link></TD><TD/><TD> Divider </TD></TR><TR><TD><Link>ALTFP_MULT</Link></TD><TD/><TD> Multiplier </TD></TR><TR><TD><Link>ALTFP_SQRT </Link></TD><TD/><TD>Square Root </TD></TR><TR><TD>Algebraic and Trancendental Functions </TD><TD/></TR><TR><TD><Link>ALTFP_EXP</Link></TD><TD/><TD> Exponential </TD></TR><TR><TD><Link>ALTFP_INV</Link></TD><TD/><TD> Inverse </TD></TR><TR><TD><Link>ALTFP_INV_SQRT </Link></TD><TD/><TD>Inverse Square Root </TD></TR><TR><TD><Link>ALTFP_LOG </Link></TD><TD/><TD>Natural Logarithm </TD></TR><TR><TD>Trigonometric Functions </TD><TD/></TR><TR><TD><Link>ALTFP_ATAN </Link></TD><TD/><TD>Arctangent </TD></TR><TR><TD><Link>ALTFP_SINCOS </Link></TD><TD/><TD>Trigonometric Sine/Cosine </TD></TR><TR><TD>Other Functions </TD><TD/></TR><TR><TD><Link>ALTFP_ABS</Link></TD><TD/><TD> Absolute value </TD></TR><TR><TD><Link>ALTFP_COMPARE</Link></TD><TD/><TD> Comparator </TD></TR><TR><TD><Link>ALTFP_CONVERT </Link></TD><TD/><TD>Converter </TD></TR><TR><TD>Complex Functions </TD><TD/></TR><TR><TD><Link>ALTFP_MATRIX_INV </Link></TD><TD/><TD>Matrix Inverse </TD></TR><TR><TD><Link>ALTFP_MATRIX_MULT </Link></TD><TD/><TD>Matrix Multiplier </TD></TR></Table><P>f 	This user guide assumes that you are familiar with megafunctions and know how to instantiate and use these megafunctions. If you are unfamiliar with megafunctions, refer to the <Link>Megafunction Overview User Guide</Link>. </P><P>f 	Altera also offers the single-precision floating-point option in the FFT MegaCore. For more information about the FFT MegaCore functions, refer to the <Link>FFT MegaCore </Link><Link>Function User Guide</Link>. </P><Sect/><P id="LinkTarget_7152">Device Family Support </P><Sect><P>All Altera floating-point megafunctions, except for the complex IP megafunctions, support all device families in the Arria®, Cyclone®, HardCopy®, and Stratix® series of devices. The complex IP megafunctions, ALTFP_MATRIX_INV and ALTFP_MATRIX_MULT, support Arria II GX, HardCopy III, HardCopy IV, Stratix II, Stratix II GX, Stratix IV, and Stratix V devices. </P></Sect><P id="LinkTarget_7153">General Features </P><Sect><P>All Altera floating-point megafunctions offer the following features: </P><L><LI><LI_Label>■ 	</LI_Label><LI_Title>Support for floating-point formats. </LI_Title></LI><LI><LI_Label>■ 	</LI_Label><LI_Title>Input support for not-a-number (NaN), infinity, zero, and normal numbers. </LI_Title></LI><LI><LI_Label>■ 	</LI_Label><LI_Title>Optional asynchronous input ports including asynchronous clear (aclr) and clock enable (clk_en). </LI_Title></LI><LI><LI_Label>■ 	</LI_Label><LI_Title>Support for round-to-nearest-even rounding mode. </LI_Title></LI><LI><LI_Label>■ 	</LI_Label><LI_Title>Compute results of any mathematical operations according to the IEEE-754 standard compliance with a maximum of 1 unit in the last place (u.l.p.) error. This assumption is applied to all floating-point megafunctions excluding complex matrix multiplication and inverse operations (for example, ALTFP_MATRIX_MULTI and ALFP_MATRIX_INV), where a slight increase in errors is observed due to the accumulation of errors during the mathematical operation. </LI_Title></LI></L><P>Altera floating-point megafunctions do not support denormal number inputs. If the input is a denormal value, the megafunction forces the value to zero and treats the value as a zero before going through any operation. </P></Sect><P id="LinkTarget_7154">IEEE-754 Standard for Floating-Point Arithmetic </P><Sect><P>The floating-point megafunctions implement the following representations in the IEEE-754 standard: </P><L><LI><LI_Label>■ 	</LI_Label><LI_Title>Floating-point numbers </LI_Title></LI><LI><LI_Label>■ 	</LI_Label><LI_Title>Special values (zero, infinity, denormal numbers, and NaN bit combinations) </LI_Title></LI><LI><LI_Label>■ 	</LI_Label><LI_Title>Single-precision, double-precision, and single-extended precision formats for floating-point numbers </LI_Title></LI></L></Sect><P id="LinkTarget_7155">Floating-Point Formats </P><Sect><P>All floating-point formats have binary patterns. In <Link>Figure 1–1</Link>, S represents a sign bit, E represents an exponent field, and M is the mantissa (part of a logarithm, or fraction) field. </P><P>For a normal floating-point number, a leading 1 is always implied, for example, binary 1.0011 or decimal 1.1875 is stored as 0011 in the mantissa field. This format saves the mantissa field from using an extra bit to represent the leading 1. However, the leading bit for a denormal number can be either 0 or 1. For zero, infinity, and NaN, the mantissa field does not have an implied leading 1 nor any explicit leading bit. </P></Sect><Sect><P><Link>Figure 1–1</Link> shows a floating-point format. </P><P>Figure 1–1. IEEE-754 Floating-Point Format </P><Figure><ImageData src="images/math_ip_altera_megafunctions_img_5.jpg"/>S E M </Figure><P id="LinkTarget_7156">Single-Precision Format </P><P>The single-precision format contains the following binary patterns: </P><L><LI><LI_Label>■ 	</LI_Label><LI_Title>The MSB holds the sign bit. </LI_Title></LI><LI><LI_Label>■ 	</LI_Label><LI_Title>The next 8 bits hold the exponent bits. </LI_Title></LI><LI><LI_Label>■ 	</LI_Label><LI_Title>23 LSBs hold the mantissa. </LI_Title></LI></L><P>The total width of a floating-point number in the single-precision format is 32 bits. 
The bias for the single-precision format is 127. 
<Link>Figure 1–2</Link> shows a single-precision representation. 
</P><P>Figure 1–2. Single-Precision Representation </P><P>3130 2322 	0 </P><Table><TR><TH>S </TH><TH>E </TH><TH>M </TH></TR></Table><P id="LinkTarget_7157">Double-Precision Format </P><P>The double-precision format contains the following binary patterns: </P><L><LI><LI_Label>■ 	</LI_Label><LI_Title>The MSB holds the sign bit. </LI_Title></LI><LI><LI_Label>■ 	</LI_Label><LI_Title>The next 11 bits hold the exponent bits. </LI_Title></LI><LI><LI_Label>■ 	</LI_Label><LI_Title>52 LSBs hold the mantissa. </LI_Title></LI></L><P>The total width of a floating-point number in the double-precision format is 64 bits. 
The bias for the double-precision format is 1023. 
<Link>Figure 1–3</Link> shows a double-precision representation. 
</P><P>Figure 1–3. Double-Precision Representation </P><P>6362 5251 	0 </P><Table><TR><TH>S </TH><TH>E </TH><TH>M </TH></TR></Table><P id="LinkTarget_7158">Single-Extended Precision Format </P><P>The single-extended precision format contains the following binary patterns: </P><L><LI><LI_Label>■ 	</LI_Label><LI_Title>The MSB holds the sign bit. </LI_Title></LI><LI><LI_Label>■ 	</LI_Label><LI_Title>The exponent and mantissa fields do not have fixed widths. </LI_Title></LI><LI><LI_Label>■ 	</LI_Label><LI_Title>The minimum exponent field width is 11 bits and must be less than the width of the mantissa field. </LI_Title></LI><LI><LI_Label>■ </LI_Label><LI_Title>The width of the mantissa field must be a minimum of 31 bits. </LI_Title></LI></L></Sect><Sect><P>The sum of the widths of the sign bit, exponent field, and mantissa field must be a minimum of 43 bits and a maximum of 64 bits. The bias for the single-extended precision format is unspecified in the IEEE-754 standard. In these megafunctions, a bias of 2(WIDTH_EXP–1)–1is assumed for the single-extended precision format. </P></Sect><P id="LinkTarget_7159">Special Case Numbers </P><Sect><P><Link>Table 1–2</Link> lists the special case numbers defined by the IEEE-754 standard and the data bit representations. </P><P>Table 1–2. Special Case Numbers in IEEE-754 Representation </P></Sect><Table><TR><TH>Meaning </TH><TH>Sign Field </TH><TH>Exponent Field </TH><TH>Mantissa Field </TH></TR><TR><TD>Zero </TD><TD>Don’t care </TD><TD>All 0’s </TD><TD>All 0’s </TD></TR><TR><TD>Positive Denormalized </TD><TD>0 </TD><TD>All 0’s </TD><TD>Non-zero </TD></TR><TR><TD>Negative Denormalized </TD><TD>1 </TD><TD>All 0’s </TD><TD>Non-zero </TD></TR><TR><TD>Positive Infinity </TD><TD>0 </TD><TD>All 1’s </TD><TD>All 0’s </TD></TR><TR><TD>Negative Infinity </TD><TD>1 </TD><TD>All 1’s </TD><TD>All 0’s </TD></TR><TR><TD>Not-a-Number (NaN) </TD><TD>Don’t care </TD><TD>All 1’s </TD><TD>Non-zero </TD></TR></Table><P id="LinkTarget_7160">Rounding </P><Sect><P>The IEEE-754 standard defines four types of rounding modes: round-to-nearest-even, round-toward-zero, round-toward-positive-infinity, and round-toward-negativeinfinity. Altera floating-point megafunctions support only the most commonly used rounding mode, which is the round-to-nearest-even mode. With round-to-nearesteven, the megafunction rounds the result to the nearest floating-point number. If the result is exactly halfway between two floating-point numbers, the megafunction rounds the result so that the LSB becomes a zero, which is even. </P></Sect><P id="LinkTarget_7161">Non-IEEE-754 Standard Format </P><Sect><P>Only one of the floating point megafunctions, ALTFP_CONVERT, supports the fixed-point format. </P><P>The fixed-point data type is similar to the conventional integer data type, except that the fixed-point data carries a predetermined number of fractional bits. If the width of the fraction is 0, the data becomes a normal signed integer. </P><P>The notation for fixed-point format numbers in this user guide is Qm.f, where Q designates that the number is in Q format notation, m is the number of bits used to indicate the integer portion of the number, and f is the number of bits used to indicate the fractional portion of the number. </P><P>For example, Q4.12 describes a number with 4 integer bits and 12 fractional bits in a 16-bit word. </P><P><Link>Figure 1–4</Link> and <Link>Figure 1–5</Link> show the difference between the signed-integer format and the fixed-point format for a 32-bit number. </P></Sect><Sect><P>Figure 1–4. Signed-Integer Format </P><P>31 	0 </P><Table><TR><TH>Sign bit </TH><TH>Integer bits </TH></TR></Table><P>Figure 1–5. Fixed-Point Format </P><P>31 	0 </P><Table><TR><TH>Sign bit </TH><TH>Integer bits </TH><TH>Fraction bits </TH></TR></Table></Sect><P id="LinkTarget_7162">Output Latency </P><Sect><P>The megafunctions measure the output latency in clock cycles and is different for each megafunction. In some megafunctions, the precision modes determine the number of clock cycles between the input and output result. When you select a mode, the options for latency are fixed for that mode. </P><P>For specific details about latency options, refer to the Output Latency section of your selected megafunction in this user guide. </P><P id="LinkTarget_7163">Design Flow </P><P>Altera strongly recommends that you use the MegaWizardTM Plug-In Manager flow for complex megafunctions. Using the MegaWizard Plug-In Manager flow ensures that you set all megafunction ports and parameters properly. </P><P>If you are an expert user, and choose to configure the megafunction directly through parameterized instantiation in your design, refer to the port and parameter details. The details of these ports and parameters are hidden in the MegaWizard Plug-In Manager. </P></Sect><P id="LinkTarget_7164">Design Example Files </P><Sect><P>The design examples for each megafunction in this user guide use the MegaWizard Plug-In Manager in the Quartus II software. </P><P>The design example files are available for download from the following locations: </P><L><LI><LI_Label>■ 	</LI_Label><LI_Title>On the <Link>Quartus II Development and Software Literature</Link> page, under Using Megafunctions in the Arithmetic section </LI_Title></LI><LI><LI_Label>■ 	</LI_Label><LI_Title>On the <Link>Literature: User Guides</Link> webpage, with this user guide </LI_Title></LI></L><P>Simulate the designs in the ModelSim®-Altera software to generate a waveform display of the device behavior. You must be familiar with the ModelSim-Altera software before trying out the design examples. If you are unfamiliar with the ModelSim-Altera software, refer to the <Link>ModelSim-Altera Software Support</Link> page on the Altera website. The support page includes links topics such as installation, usage, and troubleshooting. </P></Sect><Sect><P>For more details, refer to the Design Example section of your selected megafunction in this user guide. </P></Sect><Figure><ImageData src="images/math_ip_altera_megafunctions_img_6.jpg"/></Figure></Sect><Sect><Sect><H2 id="LinkTarget_7165">2. ALTFP_ADD_SUB 
</H2><P><Link>Figure 2–1</Link> shows the ports for the ALTFP_ADD_SUB megafunction. </P><P>Figure 2–1. ALTFP_ADD_SUB Ports </P><Figure><ImageData src="images/math_ip_altera_megafunctions_img_7.jpg"/>dataa[] datab[] add_subclock clk_en inst ALTFP_ADD_SUB result[] overflow nan underflow zero aclr </Figure><P id="LinkTarget_7166">Features </P><P>The ALTFP_ADD_SUB megafunction offers the following features: </P><L><LI><LI_Label>■ 	</LI_Label><LI_Title>Dynamically configurable adder and subtracter functions. </LI_Title></LI><LI><LI_Label>■ 	</LI_Label><LI_Title>Optional exception handling output ports such as zero, overflow, underflow, and nan. </LI_Title></LI><LI><LI_Label>■ 	</LI_Label><LI_Title>Optimization of speed and area. </LI_Title></LI></L></Sect><P id="LinkTarget_7167">Output Latency </P><Sect><P>The output latency options for the ALTFP_ADD_SUB megafunction are the same for all three precision formats—single, double, and single-extended. The options available are 7, 8, 9, 10, 11, 12, 13, and 14 clock cycles. </P></Sect><Sect><P id="LinkTarget_7168">Truth Table </P><P><Link>Figure 2–2</Link> lists the truth table for the addition/subtraction operations. </P></Sect><P>Figure 2–2. Truth Table for Addition/Subtraction Operations </P><Table><TR><TH>DATAA[] </TH><TH>DATAB[] </TH><TH>SIGN BIT </TH><TH>RESULT[] </TH><TH>Overflow </TH><TH>Underflow </TH><TH>Zero </TH><TH>NaN </TH></TR><TR><TH>Normal </TH><TH>Normal </TH><TD>0 </TD><TD>Zero </TD><TD>0 </TD><TD>0 </TD><TD>1 </TD><TD>0 </TD></TR><TR><TH>Normal </TH><TH>Normal </TH><TD>0/1</TD><TD> Normal </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD></TR><TR><TH>Normal </TH><TH>Normal </TH><TD>0/1 </TD><TD>Denormal </TD><TD>0 </TD><TD>1 </TD><TD>1 </TD><TD>0 </TD></TR><TR><TH>Normal </TH><TH>Normal </TH><TD>0/1 </TD><TD>Infinity </TD><TD>1 </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD></TR><TR><TH>Normal </TH><TH>Denormal </TH><TD>0/1 </TD><TD>Normal </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD></TR><TR><TH>Normal </TH><TH>Zero </TH><TD>0/1 </TD><TD>Normal </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD></TR><TR><TH>Normal </TH><TH>Infinity </TH><TD>0/1 </TD><TD>Infinity </TD><TD>1 </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD></TR><TR><TH>Normal </TH><TH>NaN </TH><TD>X </TD><TD>NaN </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>1 </TD></TR><TR><TH>Denormal </TH><TH>Normal </TH><TD>0/1 </TD><TD>Normal </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD></TR><TR><TH>Denormal </TH><TH>Denormal </TH><TD>0/1 </TD><TD>Normal </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD></TR><TR><TH>Denormal </TH><TH>Zero </TH><TD>0/1 </TD><TD>Zero </TD><TD>0 </TD><TD>0 </TD><TD>1 </TD><TD>0 </TD></TR><TR><TH>Denormal </TH><TH>Infinity </TH><TD>0/1 </TD><TD>Infinity </TD><TD>1 </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD></TR><TR><TH>Denormal </TH><TH>NaN </TH><TD>X </TD><TD>NaN </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>1 </TD></TR><TR><TH>Zero </TH><TH>Normal </TH><TD>0/1 </TD><TD>Normal </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD></TR><TR><TH>Zero </TH><TH>Denormal </TH><TD>0/1 </TD><TD>Zero </TD><TD>0 </TD><TD>0 </TD><TD>1 </TD><TD>0 </TD></TR><TR><TH>Zero </TH><TH>Zero </TH><TD>0/1 </TD><TD>Zero </TD><TD>0 </TD><TD>0 </TD><TD>1 </TD><TD>0 </TD></TR><TR><TH>Zero </TH><TH>Infinity </TH><TD>0/1 </TD><TD>Infinity </TD><TD>1 </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD></TR><TR><TH>Zero </TH><TH>NaN </TH><TD>X </TD><TD>NaN </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>1 </TD></TR><TR><TH>Infinity </TH><TH>Normal </TH><TD>0/1 </TD><TD>Infinity </TD><TD>1 </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD></TR><TR><TH>Infinity </TH><TH>Denormal </TH><TD>0/1 </TD><TD>Infinity </TD><TD>1 </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD></TR><TR><TH>Infinity </TH><TH>Zero </TH><TD>0/1 </TD><TD>Infinity </TD><TD>1 </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD></TR><TR><TH>Infinity </TH><TH>Infinity </TH><TD>0/1 </TD><TD>Infinity </TD><TD>1 </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD></TR><TR><TH>Infinity </TH><TH>NaN </TH><TD>X </TD><TD>NaN </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>1 </TD></TR><TR><TH>NaN </TH><TH>Normal </TH><TD>X </TD><TD>NaN </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>1 </TD></TR><TR><TH>NaN </TH><TH>Denormal </TH><TD>X </TD><TD>NaN </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>1 </TD></TR><TR><TH>NaN </TH><TH>Zero </TH><TD>X </TD><TD>NaN </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>1 </TD></TR><TR><TH>NaN </TH><TH>Infinity </TH><TD>X </TD><TD>NaN </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>1 </TD></TR><TR><TH>NaN </TH><TH>NaN </TH><TD>X </TD><TD>NaN </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>1 </TD></TR></Table><P id="LinkTarget_7169">Resource Utilization and Performance </P><Sect><P><Link>Table 2–1</Link> and <Link>Table 2–2</Link> list the resource utilization and performance information for the ALTFP_ADD_SUB megafunction. The information was derived using the Quartus II software version 10.0. </P></Sect><P>Table 2–1. ALTFP_ADD_SUB Resource Utilization and Performance for the Stratix Series of Devices </P><Table><TR><TH>Device Family </TH><TH>Precision </TH><TH>Optimization </TH><TH>Output latency </TH><TH>Adaptive Look-Up Tables (ALUTs) </TH><TH>Dedicated Logic Registers (DLRs) </TH><TH>Adaptive Logic Modules (ALMs) </TH><TH>fMAX (MHz) </TH></TR><TR><TH>Stratix III </TH><TH>single </TH><TH>speed </TH><TD>7 </TD><TD>592 </TD><TD>376 </TD><TD>386 </TD><TD>218 </TD></TR><TR><TD>14 </TD><TD>688 </TD><TD>727 </TD><TD>509 </TD><TD>442 </TD></TR><TR><TH>area </TH><TD>7 </TD><TD>576 </TD><TD>345 </TD><TD>372 </TD><TD>218 </TD></TR><TR><TD>14 </TD><TD>599 </TD><TD>603 </TD><TD>427 </TD><TD>416 </TD></TR><TR><TH>double </TH><TH>speed </TH><TD>7 </TD><TD>1,193 </TD><TD>687 </TD><TD>821 </TD><TD>180 </TD></TR><TR><TD>14 </TD><TD>996 </TD><TD>1,607 </TD><TD>1,085 </TD><TD>345 </TD></TR><TR><TH>area </TH><TD>7 </TD><TD>1,104 </TD><TD>630 </TD><TD>765 </TD><TD>182 </TD></TR><TR><TD>14 </TD><TD>903 </TD><TD>1,518 </TD><TD>1,013 </TD><TD>212 </TD></TR><TR><TH>Stratix IV </TH><TH>single </TH><TH>speed </TH><TD>7 </TD><TD>594 </TD><TD>376 </TD><TD>385 </TD><TD>228 </TD></TR><TR><TD>14 </TD><TD>674 </TD><TD>686 </TD><TD>498 </TD><TD>495 </TD></TR><TR><TH>area </TH><TD>7 </TD><TD>576 </TD><TD>345 </TD><TD>375 </TD><TD>227 </TD></TR><TR><TD>14 </TD><TD>596 </TD><TD>603 </TD><TD>421 </TD><TD>484 </TD></TR><TR><TH>double </TH><TH>speed </TH><TD>7 </TD><TD>1,198 </TD><TD>687 </TD><TD>824 </TD><TD>187 </TD></TR><TR><TD>14 </TD><TD>997 </TD><TD>1,607 </TD><TD>1,080 </TD><TD>398 </TD></TR><TR><TH>area </TH><TD>7 </TD><TD>1,106 </TD><TD>630 </TD><TD>762 </TD><TD>189 </TD></TR><TR><TD>14 </TD><TD>904 </TD><TD>1,518 </TD><TD>1,013 </TD><TD>265 </TD></TR></Table><P>Table 2–2. ALTFP_ADD_SUB Resource Utilization and Performance for the Cyclone Series of Devices </P><Table><TR><TH>Device Family </TH><TH>Precision </TH><TH>Optimization </TH><TH>Output latency </TH><TH>Logic Elements (LEs) </TH><TH>Dedicated Logic Registers (DLRs) </TH><TH>Logic Usage </TH><TH>fMAX (MHz) </TH></TR><TR><TH>Cyclone II </TH><TH>single </TH><TH>speed </TH><TD>7 </TD><TD>831 </TD><TD>346 </TD><TD>831 </TD><TD>153 </TD></TR><TR><TH>area </TH><TD>7 </TD><TD>785 </TD><TD>317 </TD><TD>785 </TD><TD>143 </TD></TR><TR><TH>double </TH><TH>speed </TH><TD>7 </TD><TD>1,764 </TD><TD>648 </TD><TD>1,764 </TD><TD>119 </TD></TR><TR><TH>area </TH><TD>7 </TD><TD>1,656 </TD><TD>591 </TD><TD>1,656 </TD><TD>101 </TD></TR><TR><TH>Cyclone III </TH><TH>single </TH><TH>speed </TH><TD>7 </TD><TD>822 </TD><TD>346 </TD><TD>822 </TD><TD>154 </TD></TR><TR><TH>area </TH><TD>7 </TD><TD>775 </TD><TD>317 </TD><TD>775 </TD><TD>149 </TD></TR><TR><TH>double </TH><TH>speed </TH><TD>7 </TD><TD>1,743 </TD><TD>648 </TD><TD>1,743 </TD><TD>128 </TD></TR><TR><TH>area </TH><TD>7 </TD><TD>1,631 </TD><TD>591 </TD><TD>1,631 </TD><TD>116 </TD></TR></Table><Sect/><P id="LinkTarget_7170">Design Example: Addition of Double-Precision Format Numbers </P><Sect><P>This design example uses the ALTFP_ADD_SUB megafunction to perform the addition of double-precision format numbers using the MegaWizard Plug-In Manager flow in the Quartus II software. </P></Sect><P id="LinkTarget_7171">Design Files </P><Sect><P>The following files are related to the ALTFP_ADD_SUB megafunction: </P><L><LI><LI_Label>■ </LI_Label><LI_Title>altfp_add_sub_DesignExample.zip (Quartus II design files) </LI_Title></LI><LI><LI_Label>■ </LI_Label><LI_Title>altfp_add_sub_ex_msim.zip (ModelSim-Altera files) </LI_Title></LI></L></Sect><P id="LinkTarget_7172">Understanding the Simulation Results </P><Sect><P><Link>Figure 2–3</Link> shows the expected simulation results in ModelSim-Altera software. </P></Sect><P>1 	The simulation waveform in this design example is not shown in its entirety. Run the design example files in the ModelSim-Altera software to see the complete simulation waveforms. </P><P>Figure 2–3. ALTFP_ADD_SUB Simulation Waveform </P><Figure><ImageData src="images/math_ip_altera_megafunctions_img_8.jpg"/><Caption><P>4250 ns40.511 ns 43.750 ns </P></Caption></Figure><Sect><P>This design example implements a floating-point adder for the addition of double-precision format numbers. All the optional input ports (clk_en and aclr) and optional output ports (overflow, underflow, zero, and nan) are enabled. </P><P>In this example, the output latency of the multiplier is set to 7 clock cycles. Every addition result appears at the result[] port 7 clock cycles after the input values are captured on the dataa[] and datab[] ports. </P></Sect><Sect><P><Link>Table 2–3</Link> lists the inputs and corresponding outputs obtained from the simulation in <Link>Figure 2–3</Link>. </P><P>Table 2–3. Summary of Input Values and Corresponding Outputs </P></Sect><Table><TR><TD>Time </TD><TD>Event </TD></TR><TR><TD>0 ns, start-up </TD><TD>dataa[] value: 0000 0000 0000 0000h datab[] value: 7FF0 0000 0000 0000h Output value: All values seen on the output port before the 7th clock cycle are merely due to the behavior of the system during startup and should be disregarded. </TD></TR><TR><TD>4250 ns </TD><TD>Output value: 7FF0 0000 0000 0000h Exception handling ports: overflow asserts The addition of zero at the input port dataa[], and infinity value at the input port datab[] results in infinity value. </TD></TR><TR><TD>40,511 ns </TD><TD>dataa[] value: 0000 0000 0000 0000h datab[] value: 0000 0000 1000 0123h The is the addition of a zero and a denormal value. </TD></TR><TR><TD>43,750 ns </TD><TD>Output value: 0000 0000 0000 0000h Exception handling ports: zero remains asserted. Denormal inputs are not supported and are forced to zero before addition takes place.This results in a zero. </TD></TR></Table><P id="LinkTarget_7173">Specifications </P><Sect><P>This section describes the component declarations, ports, and parameters of the ALTFP_ADD_SUB megafunction. The ports and parameters are available to customize the ALTFP_ADD_SUB megafunction according to your application. </P></Sect><P id="LinkTarget_7174">VHDL Component Declaration </P><Sect><P>The following VHDL component declaration is located in the VHDL Design File (.vhd) altera_mf_components.vhd in the &lt;Quartus II installation directory&gt;\libraries\vhdl\altera_mf directory. </P></Sect><P>component altfp_add_sub
</P><P> generic (
     denormal_support    :     string := &quot;YES&quot;;
     intended_device_family  :     string := &quot;unused&quot;;
     direction  :     string := &quot;ADD&quot;;
     exception_handling  :     string := &quot;YES&quot;;
     optimize   :     string := &quot;SPEED&quot;;
     pipeline   :     natural := 11;
     reduced_functionality  :     string := &quot;NO&quot;;
     rounding   :     string := &quot;TO_NEAREST&quot;;
     speed_optimized :       string := &quot;STRATIX_ONLY&quot;;
     width_exp  :     natural := 8;
     width_man  :     natural := 23;
     lpm_hint   :     string := &quot;UNUSED&quot;;
     lpm_type   :     string := &quot;altfp_add_sub"
</P><Sect><P> );
</P></Sect><P> port(
     aclr  :      in std_logic := '0';
     add_sub :       in std_logic := '1'; 
</P><Sect/><Table><TR><TH/><TH>     clk_en  </TH><TH>: </TH><TH>     in std_logic := '1';</TH></TR><TR><TD/><TD>     clock  </TD><TD>: </TD><TD>     in std_logic;</TD></TR><TR><TD/><TD>     dataa  </TD><TD>: </TD><TD>     in std_logic_vector(width_exp+width_man+1-1 downto 0);</TD></TR><TR><TD/><TD>     datab  </TD><TD>: </TD><TD>     in std_logic_vector(width_exp+width_man+1-1 downto 0);</TD></TR><TR><TD/><TD>     denormal   </TD><TD>: </TD><TD>    out std_logic;</TD></TR><TR><TD/><TD>     indefinite </TD><TD>: </TD><TD>    out std_logic;</TD></TR><TR><TD/><TD> nan</TD><TD> : </TD><TD>     out std_logic;</TD></TR><TR><TD/><TD>     overflow   </TD><TD>: </TD><TD>    out std_logic;</TD></TR><TR><TD/><TD>     result  </TD><TD>: </TD><TD>     out std_logic_vector(width_exp+width_man+1-1 downto 0);</TD></TR><TR><TD/><TD>     underflow  </TD><TD>: </TD><TD>    out std_logic;</TD></TR><TR><TD/><TD>     zero  </TD><TD>: </TD><TD>     out std_logic</TD></TR><TR><TD> ); </TD><TD/><TD/></TR></Table><Sect><P>end component; 
</P></Sect><P id="LinkTarget_7175">VHDL LIBRARY-USE Declaration </P><Sect><P>The VHDL LIBRARY-USE declaration is not required if you use the VHDL Component Declaration. </P><P>LIBRARY altera_mf; 
USE altera_mf_altera_mf_components.all; 
</P></Sect><P id="LinkTarget_7176">Ports and Parameters </P><Sect><P><Link>Table 2–4</Link> lists the input ports of the ALTFP_ADD_SUB megafunction. </P></Sect><P>Table 2–4. ALTFP_ADD_SUB Megafunction Input Ports </P><Table><TR><TH>Port Name </TH><TH>Required </TH><TH>Description </TH></TR><TR><TD>aclr </TD><TD>No </TD><TD>Asynchronous clear input for floating-point adder or subtractor. The source is asynchronously reset when the aclr signal is asserted high. </TD></TR><TR><TD>add_sub </TD><TD>No </TD><TD>Optional input port to enable dynamic switching between the adder and subtractor functions. The add_subport must be used when the DIRECTION parameter is set to VARIABLE. When the add_sub port is high, result[] = dataa[] + datab[], otherwise, result[] = dataa[] - datab[]. </TD></TR><TR><TD>clk_en </TD><TD>No </TD><TD>Clock enable to the floating-point adder or subtractor. This port allows addition or subtraction to occur when asserted high. When asserted low, no operations occur and the outputs are unchanged. </TD></TR><TR><TD>clock </TD><TD>Yes </TD><TD>Clock input to the megafunction. </TD></TR><TR><TD>dataa[] </TD><TD>Yes </TD><TD>Data input to the floating-point adder or subtractor. The MSB is the sign bit, the next MSBs are the exponent, and the LSBs are the mantissa bits. The size of this port is the total width of the sign bit, the exponent bits, and the mantissa bits. </TD></TR><TR><TD>datab[] </TD><TD>Yes </TD><TD>Data input to the floating-point adder or subtractor. This port is configured in the same way as dataa[]. </TD></TR></Table><Sect><P><Link>Table 2–5</Link> lists the output ports of the ALTFP_ADD_SUB megafunction. </P></Sect><P>Table 2–5. ALTFP_ADD_SUB Megafunction Output Ports </P><Table><TR><TH>Port Name </TH><TH>Required </TH><TH>Description </TH></TR><TR><TD>nan </TD><TD>Yes </TD><TD>NaN exception output. Asserted when an illegal addition or subtraction occurs, such as infinity minus infinity. When an invalid addition or subtraction occurs, a NaN value is output to the result[] port. Any adding or subtracting involving NaN values also produces a NaN value. </TD></TR><TR><TD>overflow </TD><TD>Yes </TD><TD>Overflow exception port. Asserted when the result of the addition or subtraction, after rounding, exceeds or reaches infinity. Infinity is defined as a number in which the exponent exceeds 2WIDTH_EXP -1. </TD></TR><TR><TD>result[] </TD><TD>Yes </TD><TD>Floating-point output result. Like the input values, the MSB is the sign, the next MSBs are the exponent, and the LSBs are the mantissa. The size of this port is the total width of the sign bit, exponent bits, and mantissa bits. </TD></TR><TR><TD>underflow </TD><TD>Yes </TD><TD>Underflow port for the adder or subtractor. Asserted when the result of the addition or subtraction, after rounding, the value is zero and the inputs are not equal. The underflow port is also asserted when the result is a denormalized number. </TD></TR><TR><TD>zero </TD><TD>No </TD><TD>Zero port for the adder or subtractor. Asserted when the result[] port is zero. </TD></TR></Table><Sect><P><Link>Table 2–6</Link> lists the parameters of the ALTFP_ADD_SUB megafunction. </P></Sect><P>Table 2–6. ALTFP_ADD_SUB Megafunction Parameters (Part 1 of 2) </P><Table><TR><TH>Parameter Name </TH><TH>Type </TH><TH>Required </TH><TH>Description </TH></TR><TR><TD>DIRECTION </TD><TD>String </TD><TD>Yes </TD><TD>Specifies addition or subtraction operations. Values are ADD, SUB, or VARIABLE. If this parameter is not specified, the default is ADD. When the value is VARIABLE, the add_sub port determines whether the operation is addition or subtraction. The add_sub port must be connected if the DIRECTION parameter is set to VARIABLE. If the value is ADD or SUB, the add_sub port is ignored. </TD></TR><TR><TD>PIPELINE </TD><TD>Integer </TD><TD>No </TD><TD>Specifies the latency in clock cycles used in the ALTFP_ADD_SUB megafunction. The PIPELINE parameter supports values of 7 through 14. If this parameter is not specified, the default value is 11. In general, a higher pipeline value produces better fMAX performance. </TD></TR><TR><TD>ROUNDING </TD><TD>String </TD><TD>Yes </TD><TD>Specifies the rounding mode. The default value is TO_NEAREST. Other rounding modes are currently not supported. </TD></TR><TR><TD>OPTIMIZE </TD><TD>String </TD><TD>No </TD><TD>Defines the design preference, whether the design is optimized for speed (faster fMAX), or optimized for area (lower resource count). Values are SPEED and AREA. If this parameter is not specified, the default is SPEED. </TD></TR></Table><Sect/><P>Table 2–6. ALTFP_ADD_SUB Megafunction Parameters (Part 2 of 2) </P><Table><TR><TH>Parameter Name </TH><TH>Type </TH><TH>Required </TH><TH>Description </TH></TR><TR><TD>WIDTH_EXP </TD><TD>Integer </TD><TD>No </TD><TD>Specifies the precision of the exponent. The bias of the exponent is always set to 2(WIDTH_EXP-1) -1 (that is, 127 for single-precision format and 1023 for double-precision format). The WIDTH_EXP parameter must be 8 for the single-precision mode and 11 for the double-precision mode, or a minimum of 11for the single-extended precision mode. The WIDTH_EXP parameter must be less than the WIDTH_MAN parameter. The sum of WIDTH_EXP and the WIDTH_MAN parameters must be less than 64. If this parameter is not specified, the default is 8. </TD></TR><TR><TD>WIDTH_MAN </TD><TD>Integer </TD><TD>No </TD><TD>Specifies the precision of the mantissa. The WIDTH_MAN parameter must be 23 (to comply with the IEEE-754 standard for the single-precision mode) when the WIDTH_EXP parameter is 8. Otherwise, the WIDTH_MAN parameter must have a value that is greater than or equal to 31. The WIDTH_MAN parameter must be greater than the WIDTH_EXP parameter. The sum of the WIDTH_EXP and WIDTH_MAN parameters must be less than 64. If this parameter is not specified, the default is 23. </TD></TR></Table><Figure><ImageData src="images/math_ip_altera_megafunctions_img_9.jpg"/></Figure></Sect><Sect><Sect><H2 id="LinkTarget_7177">3. ALTFP_DIV 
</H2><P><Link>Figure 3–1</Link> shows the ports for the ALTFP_DIV megafunction. </P><P>Figure 3–1. ALTFP_DIV Ports </P><Figure><ImageData src="images/math_ip_altera_megafunctions_img_10.jpg"/>dataa[] datab[] clk_en clock inst ALTFP_DIV result[] overflow underflow zero nan division_by_zero aclr </Figure><P id="LinkTarget_7178">Features </P><P>The ALTFP_DIV megafunction offers the following features: </P><L><LI><LI_Label>■ 	</LI_Label><LI_Title>Division functions. </LI_Title></LI><LI><LI_Label>■ 	</LI_Label><LI_Title>Optional exception handling output ports such as zero, division_by_zero, overflow, underflow, and nan. </LI_Title></LI><LI><LI_Label>■ 	</LI_Label><LI_Title>Optimization of speed and area. </LI_Title></LI><LI><LI_Label>■ 	</LI_Label><LI_Title>Low latency option. </LI_Title></LI></L></Sect><P id="LinkTarget_7179">Output Latency </P><Sect><P>The output latency options for the ALTFP_DIV megafunction differs depending on the precision selected, the width of the mantissa, or both. You have the choice of selecting the smaller figures of clock cycles delay in your design if the low latency option is desired. </P><P><Link>Table 3–1 </Link>lists the output latency options that can be selected for each precision format. </P><P>Table 3–1. Latency Options for Each Operation (Part 1 of 2) </P></Sect><Table><TR><TH>Precision </TH><TH>Mantissa Width </TH><TH>Latency (in clock cycles) </TH></TR><TR><TD>Single </TD><TD>23 </TD><TD>6, 14, 33 </TD></TR><TR><TD>Double </TD><TD>52 </TD><TD>10, 24, 61 </TD></TR></Table><Sect><P>Table 3–1. Latency Options for Each Operation (Part 2 of 2) </P></Sect><Table><TR><TH>Precision </TH><TH>Mantissa Width </TH><TH>Latency (in clock cycles) </TH></TR><TR><TH/><TD>31 – 32 </TD><TD>8, 18, 41 </TD></TR><TR><TH/><TD>33 – 34 </TD><TD>8, 18, 43 </TD></TR><TR><TH/><TD>35 – 36 </TD><TD>8, 18, 45 </TD></TR><TR><TH/><TD>37 – 38 </TD><TD>8, 18, 47 </TD></TR><TR><TH/><TD>39 – 40 </TD><TD>8, 18, 49 </TD></TR><TR><TH>Single Extended </TH><TD>41 </TD><TD>10, 24, 41 </TD></TR><TR><TD>42 </TD><TD>10, 24, 51 </TD></TR><TR><TD>43 – 44 </TD><TD>10, 24, 53 </TD></TR><TR><TD>45 – 46 </TD><TD>10, 24, 55 </TD></TR><TR><TD>47 – 48 </TD><TD>10, 24, 57 </TD></TR><TR><TD>49 – 50 </TD><TD>10, 24, 59 </TD></TR><TR><TD>51 – 52 </TD><TD>10, 24, 61 </TD></TR></Table><Sect><P id="LinkTarget_7180">Truth Table </P><P><Link>Table 3–2 </Link>lists the truth table for the division operation. </P></Sect><P>Table 3–2. Truth Table for Division Operations (Part 1 of 2) </P><Table><TR><TH>DATAA[] </TH><TH>DATAB[] </TH><TH>SIGN BIT </TH><TH>RESULT[] </TH><TH>Overflow </TH><TH>Underflow </TH><TH>Zero </TH><TH>Division-by-zero </TH><TH>NaN </TH></TR><TR><TH>Normal </TH><TH>Normal </TH><TD>0/1 </TD><TD>Normal </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD></TR><TR><TH>Normal </TH><TH>Normal </TH><TD>0/1</TD><TD> Denormal </TD><TD>0 </TD><TD>0 </TD><TD>1 </TD><TD>0 </TD><TD>0 </TD></TR><TR><TH>Normal </TH><TH>Normal </TH><TD>0/1 </TD><TD>Infinity </TD><TD>1 </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD></TR><TR><TH>Normal </TH><TH>Normal </TH><TD>0/1 </TD><TD>Zero </TD><TD>0 </TD><TD>1 </TD><TD>1 </TD><TD>0 </TD><TD>0 </TD></TR><TR><TH>Normal </TH><TH>Denormal </TH><TD>0/1 </TD><TD>Infinity </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>1 </TD><TD>0 </TD></TR><TR><TH>Normal </TH><TH>Zero </TH><TD>0/1 </TD><TD>Infinity </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>1 </TD><TD>0 </TD></TR><TR><TH>Normal </TH><TH>Infinity </TH><TD>0/1 </TD><TD>Zero </TD><TD>0 </TD><TD>0 </TD><TD>1 </TD><TD>0 </TD><TD>0 </TD></TR><TR><TH>Normal </TH><TH>NaN </TH><TD>X </TD><TD>NaN </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>1 </TD></TR><TR><TH>Denormal </TH><TH>Normal </TH><TD>0/1 </TD><TD>Zero </TD><TD>0 </TD><TD>0 </TD><TD>1 </TD><TD>0 </TD><TD>0 </TD></TR><TR><TH>Denormal </TH><TH>Denormal </TH><TD>0/1 </TD><TD>NaN </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>1 </TD></TR><TR><TH>Denormal </TH><TH>Zero </TH><TD>0/1 </TD><TD>NaN </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>1 </TD></TR><TR><TH>Denormal </TH><TH>Infinity </TH><TD>0/1 </TD><TD>Zero </TD><TD>0 </TD><TD>0 </TD><TD>1 </TD><TD>0 </TD><TD>0 </TD></TR><TR><TH>Denormal </TH><TH>NaN </TH><TD>X </TD><TD>NaN </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>1 </TD></TR><TR><TH>Zero </TH><TH>Normal </TH><TD>0/1 </TD><TD>Zero </TD><TD>0 </TD><TD>0 </TD><TD>1 </TD><TD>0 </TD><TD>0 </TD></TR><TR><TH>Zero </TH><TH>Denormal </TH><TD>0/1 </TD><TD>NaN </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>1 </TD></TR><TR><TH>Zero </TH><TH>Zero </TH><TD>0/1 </TD><TD>NaN </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>1 </TD></TR><TR><TH>Zero </TH><TH>Infinity </TH><TD>0/1 </TD><TD>Zero </TD><TD>0 </TD><TD>0 </TD><TD>1 </TD><TD>0 </TD><TD>0 </TD></TR><TR><TH>Zero </TH><TH>NaN </TH><TD>X </TD><TD>NaN </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>1 </TD></TR><TR><TH>Infinity </TH><TH>Normal </TH><TD>0/1 </TD><TD>Infinity </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD></TR><TR><TH>Infinity </TH><TH>Denormal </TH><TD>0/1 </TD><TD>Infinity </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD></TR><TR><TH>Infinity </TH><TH>Zero </TH><TD>0/1 </TD><TD>Infinity </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD></TR></Table><P>Table 3–2. Truth Table for Division Operations (Part 2 of 2) </P><Table><TR><TH>DATAA[] </TH><TH>DATAB[] </TH><TH>SIGN BIT </TH><TH>RESULT[] </TH><TH>Overflow </TH><TH>Underflow </TH><TH>Zero </TH><TH>Division-by-zero </TH><TH>NaN </TH></TR><TR><TD>Infinity </TD><TD>Infinity </TD><TD>0/1 </TD><TD>NaN </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>1 </TD></TR><TR><TD>Infinity </TD><TD>NaN </TD><TD>X </TD><TD>NaN </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>1 </TD></TR><TR><TD>NaN </TD><TD>Normal </TD><TD>X </TD><TD>NaN </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>1 </TD></TR><TR><TD>NaN </TD><TD>Denormal </TD><TD>X </TD><TD>NaN </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>1 </TD><TD>1 </TD></TR><TR><TD>NaN </TD><TD>Zero </TD><TD>X </TD><TD>NaN </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>1 </TD><TD>1 </TD></TR><TR><TD>NaN </TD><TD>Infinity </TD><TD>X </TD><TD>NaN </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>1 </TD></TR><TR><TD>NaN </TD><TD>NaN </TD><TD>X </TD><TD>NaN </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>1 </TD></TR></Table><P id="LinkTarget_7181">Resource Utilization and Performance </P><Sect><P><Link>Table 3–3 </Link>lists the resource utilization and performance information for the ALTFP_DIV megafunction. The information was derived using the Quartus II software version 10.0. </P></Sect><P>Table 3–3. ALTFP_DIV Resource Utilization and Performance for the Stratix Series of Devices </P><Table><TR><TH>Device family </TH><TH>Precision </TH><TH>Optimization </TH><TH>Output latency </TH><TH/><TH>Logic Usage </TH><TH/><TH>fMAX(MHz) </TH></TR><TR><TH>Adaptive Look-Up Tables (ALUTs) </TH><TH>Dedicated Logic Registers (DLRs) </TH><TH>Adaptive Logic Modules (ALMs) </TH><TH>18-bit DSP </TH></TR><TR><TH>Stratix III </TH><TH>Single </TH><TH>Speed </TH><TD>33 </TD><TD>3,658 </TD><TD>3,374 </TD><TD>2,510 </TD><TD>— </TD><TD>283 </TD></TR><TR><TH>Area </TH><TD>33 </TD><TD>1,722 </TD><TD>2,097 </TD><TD>1,467 </TD><TD>— </TD><TD>278 </TD></TR><TR><TH>Double </TH><TH>Speed </TH><TD>61 </TD><TD>14,191 </TD><TD>13,298 </TD><TD>10,501 </TD><TD>— </TD><TD>264 </TD></TR><TR><TH>Area </TH><TD>61 </TD><TD>5,425 </TD><TD>7,515 </TD><TD>5,021 </TD><TD>— </TD><TD>216 </TD></TR><TR><TH>Stratix IV </TH><TH>Single </TH><TH>Speed </TH><TD>33 </TD><TD>3,593 </TD><TD>3,351 </TD><TD>2,500 </TD><TD>— </TD><TD>313 </TD></TR><TR><TH>Area </TH><TD>33 </TD><TD>1,646 </TD><TD>2,074 </TD><TD>1,441 </TD><TD>— </TD><TD>308 </TD></TR><TR><TH>Double </TH><TH>Speed </TH><TD>61 </TD><TD>13,867 </TD><TD>13,143 </TD><TD>10,196 </TD><TD>— </TD><TD>292 </TD></TR><TR><TH>Area </TH><TD>61 </TD><TD>5,125 </TD><TD>7,360 </TD><TD>4,842 </TD><TD>— </TD><TD>267 </TD></TR><TR><TH/><TH/><TH/><TH>Low Latency Option </TH><TD/><TD/><TD/></TR><TR><TH>Stratix III </TH><TH>Single </TH><TH>— </TH><TD>6 </TD><TD>207 </TD><TD>304 </TD><TD>208 </TD><TD>16 </TD><TD>136 </TD></TR><TR><TH>— </TH><TD>14 </TD><TD>295 </TD><TD>331 </TD><TD>262 </TD><TD>16 </TD><TD>296 </TD></TR><TR><TH>Double </TH><TH>— </TH><TD>10 </TD><TD>714 </TD><TD>1,077 </TD><TD>768 </TD><TD>44 </TD><TD>133 </TD></TR><TR><TH>— </TH><TD>24 </TD><TD>1,104 </TD><TD>1,592 </TD><TD>963 </TD><TD>44 </TD><TD>195 </TD></TR><TR><TH>Stratix IV </TH><TH>Single </TH><TH>— </TH><TD>6 </TD><TD>207 </TD><TD>304 </TD><TD>212 </TD><TD>16 </TD><TD>154 </TD></TR><TR><TH>— </TH><TD>14 </TD><TD>253 </TD><TD>638 </TD><TD>385 </TD><TD>16 </TD><TD>358 </TD></TR><TR><TH>Double </TH><TH>— </TH><TD>10 </TD><TD>714 </TD><TD>1,077 </TD><TD>779 </TD><TD>44 </TD><TD>151 </TD></TR><TR><TH>— </TH><TD>24 </TD><TD>765 </TD><TD>2,488 </TD><TD>1,397 </TD><TD>44 </TD><TD>238 </TD></TR></Table><Sect/><P id="LinkTarget_7182">Design Example: Division of Single-Precision Format Numbers with Low Latency </P><Sect><P>This design example uses the ALTFP_DIV megafunction to implement a floating-point divider for the division of single-precision format numbers with low latency. This example uses the MegaWizard Plug-In Manager flow in the Quartus II software. </P></Sect><P id="LinkTarget_7183">Design Files </P><Sect><P>The following files are related to the ALTFP_DIV megafunction: </P><L><LI><LI_Label>■ </LI_Label><LI_Title>altfp_div_DesignExample.zip (Quartus II design files) </LI_Title></LI><LI><LI_Label>■ </LI_Label><LI_Title>altfp_div_ex_msim.zip (ModelSim-Altera files) </LI_Title></LI></L></Sect><P id="LinkTarget_7184">Understanding the Simulation Results </P><Sect><P><Link>Figure 1 </Link>shows the expected simulation results in the ModelSim-Altera software. </P></Sect><P>1 	The simulation waveform in this design example is not shown in its entirety. Run the design example files in the ModelSim-Altera software to see the complete simulation waveforms. </P><P>Figure 1. ALTFP_DIV Simulation Waveform </P><Figure><ImageData src="images/math_ip_altera_megafunctions_img_11.jpg"/></Figure><Sect><P>17600 ns 20800 ns 27200 ns </P><P>This design example implements a floating-point divider for the division of single-precision numbers with a low latency option. The output latency is 6, hence every division generates the output result 6 clock cycles later. </P></Sect><Sect><P><Link>Table 3–4</Link> lists the inputs and corresponding outputs obtained from the simulation in <Link>Figure 1</Link>. </P><P>Table 3–4. Summary of Input Values and Corresponding Outputs </P></Sect><Table><TR><TD>Time </TD><TD>Event </TD></TR><TR><TD>0 ns, start-up </TD><TD>dataa[] value: 0000 0000h datab[] value: 0000 0000h Output value: The undefined value is seen on the result[] port, which is ignored. All values seen on the output port before the 6th clock cycle are merely due to the behavior of the system during start-up and should be disregarded. </TD></TR><TR><TD>17600 ns </TD><TD>Output value: 7FC0 0000h Exception handling ports: nan asserts The division of zeros result in a NaN. </TD></TR><TR><TD>2000 ns </TD><TD>dataa[] value: 2D0B 496Ah datab[] value: 3A5A FC26h Both inputs hold normal values. </TD></TR><TR><TD>20800 ns </TD><TD>Output result: 321F 6EC6h Exception output ports: nan deasserts The division of two normal value results in a normal value. </TD></TR><TR><TD>11000 ns </TD><TD>dataa[] value: 046E 78BCh datab[] value: 6798 698Bh Both inputs hold normal values. </TD></TR><TR><TD>27200 ns </TD><TD>Output value: 0h Exception handling ports: underflow and zero asserts The division of the two normal values results in a denormal value. As denormal values are not supported, the result is zero and the underflow port asserts. The zero port is also asserted to indicate that the result is zero. </TD></TR><TR><TD>2600 ns </TD><TD>dataa[] value: 0D72 54A8h datab[] value: 0070 0000h The input port dataa[] holds a normal value while the input port datab[] holds a denormal value. </TD></TR><TR><TD>36800 ns </TD><TD>Output value: 7F80 0000h Exception handling ports: division_by_zero asserts Denormal numbers are forced-zero values, therefore, attempts to divide a normal value with a zero result in an infinity value. </TD></TR></Table><Sect/><P id="LinkTarget_7185">Specifications </P><Sect><P>This section describes the component declarations, ports, and parameters of the ALTFP_DIV megafunction. The ports and parameters are available to customize the ALTFP_DIV megafunction according to your application. </P></Sect><P id="LinkTarget_7186">VHDL Component Declaration </P><Sect><P>The following VHDL component declaration is located in the VHDL Design File (.vhd) altera_mf_components.vhd in the &lt;Quartus II installation directory&gt;\libraries\vhdl\altera_mf directory. </P></Sect><P>component altfp_div
</P><P> generic (
     intended_device_family  :    string := &quot;unused&quot;;
     exception_handling  :    string := &quot;YES&quot;;
     optimize   :     string := &quot;SPEED&quot;;
     pipeline   :     natural := 32;
     rounding   :     string := &quot;TO_NEAREST&quot;;
     width_exp  :     natural := 8;
     width_man  :     natural := 23;
     lpm_hint   :     string := &quot;UNUSED&quot;;
     lpm_type   :     string := &quot;altfp_div"
</P><Sect><P> );
</P></Sect><P> port(
     aclr  :      in std_logic := '0';
     clk_en  :      in std_logic := '1';
     clock  :      in std_logic;
     dataa  :      in std_logic_vector(width_exp+width_man+1-1 downto 0);
     datab  :      in std_logic_vector(width_exp+width_man+1-1 downto 0);
     division_by_zero    :     out std_logic;
 nan :      out std_logic;
     overflow   :     out std_logic;
     result  :      out std_logic_vector(width_exp+width_man+1-1 downto 0);
     underflow  :     out std_logic;
     zero  :      out std_logic 
</P><Sect><P>); 
end component; 
</P></Sect><P id="LinkTarget_7187">VHDL LIBRARY-USE Declaration </P><Sect><P>The VHDL LIBRARY-USE declaration is not required if you use the VHDL Component Declaration. </P><P>LIBRARY altera_mf; 
</P><P>USE altera_mf_altera_mf_components.all; 
</P></Sect><Sect/><P id="LinkTarget_7188">Ports and Parameters </P><Sect><P><Link>Table 3–5</Link> lists the input ports of the ALTFP_DIV megafunction. </P></Sect><P>Table 3–5. ALTFP_DIV Megafunction Input Ports </P><Table><TR><TH>Port Name </TH><TH>Required </TH><TH>Description </TH></TR><TR><TD>aclr </TD><TD>No </TD><TD>Asynchronous clear input for the floating-point divider. The source is asynchronously reset when the aclr signal is asserted high. </TD></TR><TR><TD>clock </TD><TD>Yes </TD><TD>Clock input to the megafunction. </TD></TR><TR><TD>clk_en </TD><TD>No </TD><TD>Clock enable to the floating-point divider. This port enables division. This signal is active high. When this signal is low, no division takes place and the outputs remain the same. </TD></TR><TR><TD>dataa[] </TD><TD>Yes </TD><TD>Numerator data input. The MSB is the sign bit, the next MSBs are the exponent, and the LSBs are the mantissa. The size of this port is the total width of the sign bit, exponent bits and mantissa bits. </TD></TR><TR><TD>datab[] </TD><TD>Yes </TD><TD>Denominator data input.The MSB is the sign bit, the next MSBs are the exponent, and the LSBs are the mantissa. The size of this port is the total width of the sign bit, exponent bits and mantissa bits. </TD></TR></Table><Sect><P><Link>Table 3–6</Link> lists the output ports of the ALTFP_DIV megafunction. </P></Sect><P>Table 3–6. ALTFP_DIV Megafunction Output Ports </P><Table><TR><TH>Port Name </TH><TH>Required </TH><TH>Description </TH></TR><TR><TD>result[] </TD><TD>Yes </TD><TD>Divider output port. The division result (after rounding). As with the input values, the MSB is the sign, the next MSBs are the exponent, and the LSBs are the mantissa. The size of this port is the total width of the sign bit, exponent bits, and mantissa bits. </TD></TR><TR><TD>overflow </TD><TD>No </TD><TD>Overflow port for the divider. Asserted when the result of the division (after rounding) exceeds or reaches infinity. Infinity is defined as a number in which the exponent exceeds 2WIDTH_EXP–1. </TD></TR><TR><TD>underflow </TD><TD>No </TD><TD>Underflow port for the divider. Asserted when the result of the division (after rounding) is zero even though neither of the inputs to the divider is zero, or when the result is a denormalized number. </TD></TR><TR><TD>zero </TD><TD>No </TD><TD>Zero port for the divider. Asserted when the value of result[] is zero. </TD></TR><TR><TD>division_by_zero </TD><TD>No </TD><TD>Division-by-zero output port for the divider. Asserted when the value of datab[] is a zero. </TD></TR><TR><TD>nan </TD><TD>No </TD><TD>NaN port. Asserted when an invalid division occurs, such as infinity dividing infinity or zero dividing zero. A NaN value appears as output at the result[] port. Any division of a NaN value causes the nan output port to be asserted. </TD></TR></Table><Sect><P><Link>Table 3–7</Link> lists the parameters of the ALTFP_DIV megafunction. </P></Sect><P>Table 3–7. ALTFP_DIV Megafunction Parameters </P><Table><TR><TH>Parameter Name </TH><TH>Type </TH><TH>Required </TH><TH>Description </TH></TR><TR><TD>WIDTH_EXP </TD><TD>Integer </TD><TD>Yes </TD><TD>Specifies the precision of the exponent. If this parameter is not specified, the default is 8. The bias of the exponent is always set to (2 ^ (WIDTH_EXP - 1)) - 1, that is, 127 for single precision and 1023 for double precision. The value of WIDTH_EXP must be 8 for single precision, 11 for double precision, and a minimum of 11 for single extended precision. The value of WIDTH_EXP must be less than the value of WIDTH_MAN, and the sum of WIDTH_EXP and WIDTH_MAN must be less than 64. </TD></TR><TR><TD>WIDTH_MAN </TD><TD>Integer </TD><TD>Yes </TD><TD>Specifies the precision of the mantissa. If this parameter is not specified, the default is 23. When WIDTH_EXP is 8 and the floating-point format is the single-precision format, the WIDTH_MAN value must be 23. Otherwise, the value of WIDTH_MAN must be a minimum of 31. The value of WIDTH_MANmust be greater than the value of WIDTH_EXP, and the sum of WIDTH_EXP and WIDTH_MAN must be less than 64. </TD></TR><TR><TD>ROUNDING </TD><TD>String </TD><TD>Yes </TD><TD>Specifies the rounding mode. The default value is TO_NEAREST. The floating-point divider does not support other rounding modes. </TD></TR><TR><TD>OPTIMIZE </TD><TD>String </TD><TD>No </TD><TD>Specifies whether to optimize for area or for speed. Values are AREA and SPEED. A value of AREA optimizes the design using less total logic utilization or resources. A value of SPEED optimizes the design for better performance. If this parameter is not specified, the default value is SPEED. </TD></TR><TR><TD>PIPELINE </TD><TD>Integer </TD><TD>No </TD><TD>Specifies the number of clock cycles needed to produce the result. For the single-precision format, the latency options are 33, 14 or 6. For the double-precision format, the latency options are 61, 24 or 10. For the single-extended precision format, the value ranges from a minimum of 41 to a maximum of 61. For the low-latency option, the latency is determined from the mantissa width. For a mantissa width of 31 to 40 bits, the value is 8or 18. For a mantissa width of 41 bits or more, the value is 10 or 24. </TD></TR></Table><Figure><ImageData src="images/math_ip_altera_megafunctions_img_12.jpg"/></Figure></Sect><Sect><Sect><H2 id="LinkTarget_7189">4. ALTFP_MULT 
</H2><P><Link>Figure 4–1</Link> shows the ports for the ALTFP_MULT megafunction. </P><P>Figure 4–1. ALTFP_MULT Ports </P><Figure><ImageData src="images/math_ip_altera_megafunctions_img_13.jpg"/>dataa[] datab[] clock clk_en inst ALTFP_MULT result[] overflow nan underflow zero aclr </Figure><P id="LinkTarget_7190">Features </P><P>The ALTFP_MULT megafunction offers the following features: </P><L><LI><LI_Label>■ 	</LI_Label><LI_Title>Multiplication functions. </LI_Title></LI><LI><LI_Label>■ 	</LI_Label><LI_Title>Optional exception handling output ports such as zero, overflow, underflow, and nan. </LI_Title></LI><LI><LI_Label>■ 	</LI_Label><LI_Title>Optional dedicated multiplier circuitries in Cyclone, HardCopy, and Stratix series. </LI_Title></LI></L></Sect><P id="LinkTarget_7191">Output Latency </P><Sect><P>The output latency options for the ALTFP_MULT megafunction are similar for all precisions. </P><P><Link>Table 4–1 </Link>lists the output latency options required for each precision format. </P><P>Table 4–1. Latency Options for Each Precision Format </P></Sect><Table><TR><TH>Precision </TH><TH>Mantissa Width </TH><TH>Latency (in clock cycles) </TH></TR><TR><TD>Single </TD><TD>23 </TD><TD>5, 6, 10,11 </TD></TR><TR><TD>Double </TD><TD>52 </TD><TD>5, 6, 10,11 </TD></TR><TR><TD>Single-Extended </TD><TD>31–52 </TD><TD>5, 6, 10,11 </TD></TR></Table><Sect><P id="LinkTarget_7192">Truth Table </P><P><Link>Table 4–2</Link> lists the truth table for the multiplier operation. </P><P>Table 4–2. Truth Table for Multiplier Operations </P></Sect><Table><TR><TH>DATAA[] </TH><TH>DATAB[] </TH><TH>RESULT[] </TH><TH>Overflow </TH><TH>Underflow </TH><TH>Zero </TH><TH>NaN </TH></TR><TR><TH>Normal </TH><TH>Normal </TH><TH>Normal </TH><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD></TR><TR><TH>Normal </TH><TH>Normal </TH><TH>Denormal </TH><TD>0 </TD><TD>1 </TD><TD>1 </TD><TD>0 </TD></TR><TR><TH>Normal </TH><TH>Normal </TH><TH>Infinity </TH><TD>1 </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD></TR><TR><TH>Normal </TH><TH>Normal </TH><TH>Zero </TH><TD>0 </TD><TD>1 </TD><TD>1 </TD><TD>0 </TD></TR><TR><TH>Normal </TH><TH>Denormal </TH><TH>Zero </TH><TD>0 </TD><TD>0 </TD><TD>1 </TD><TD>0 </TD></TR><TR><TH>Normal </TH><TH>Zero </TH><TH>Zero </TH><TD>0 </TD><TD>0 </TD><TD>1 </TD><TD>0 </TD></TR><TR><TH>Normal </TH><TH>Infinity </TH><TH>Infinity </TH><TD>1 </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD></TR><TR><TH>Normal </TH><TH>NaN </TH><TH>NaN </TH><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>1 </TD></TR><TR><TH>Denormal </TH><TH>Normal </TH><TH>Zero </TH><TD>0 </TD><TD>0 </TD><TD>1 </TD><TD>0 </TD></TR><TR><TH>Denormal </TH><TH>Denormal </TH><TH>Zero </TH><TD>0 </TD><TD>0 </TD><TD>1 </TD><TD>0 </TD></TR><TR><TH>Denormal </TH><TH>Zero </TH><TH>Zero </TH><TD>0 </TD><TD>0 </TD><TD>1 </TD><TD>0 </TD></TR><TR><TH>Denormal </TH><TH>Infinity </TH><TH>NaN </TH><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>1 </TD></TR><TR><TH>Denormal </TH><TH>NaN </TH><TH>NaN </TH><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>1 </TD></TR><TR><TH>Zero </TH><TH>Normal </TH><TH>Zero </TH><TD>0 </TD><TD>0 </TD><TD>1 </TD><TD>0 </TD></TR><TR><TH>Zero </TH><TH>Denormal </TH><TH>Zero </TH><TD>0 </TD><TD>0 </TD><TD>1 </TD><TD>0 </TD></TR><TR><TH>Zero </TH><TH>Zero </TH><TH>Zero </TH><TD>0 </TD><TD>0 </TD><TD>1 </TD><TD>0 </TD></TR><TR><TH>Zero </TH><TH>Infinity </TH><TH>NaN </TH><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>1 </TD></TR><TR><TH>Zero </TH><TH>NaN </TH><TH>NaN </TH><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>1 </TD></TR><TR><TH>Infinity </TH><TH>Normal </TH><TH>Infinity </TH><TD>1 </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD></TR><TR><TH>Infinity </TH><TH>Denormal </TH><TH>NaN </TH><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>1 </TD></TR><TR><TH>Infinity </TH><TH>Zero </TH><TH>NaN </TH><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>1 </TD></TR><TR><TH>Infinity </TH><TH>Infinity </TH><TH>Infinity </TH><TD>1 </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD></TR><TR><TH>Infinity </TH><TH>NaN </TH><TH>NaN </TH><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>1 </TD></TR><TR><TH>NaN </TH><TH>Normal </TH><TH>NaN </TH><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>1 </TD></TR><TR><TH>NaN </TH><TH>Denormal </TH><TH>NaN </TH><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>1 </TD></TR><TR><TH>NaN </TH><TH>Zero </TH><TH>NaN </TH><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>1 </TD></TR><TR><TH>NaN </TH><TH>Infinity </TH><TH>NaN </TH><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>1 </TD></TR><TR><TH>NaN </TH><TH>NaN </TH><TH>NaN </TH><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>1 </TD></TR></Table><P id="LinkTarget_7193">Resource Utilization and Performance </P><Sect><P><Link>Table 4–3</Link> and <Link>Table 4–4</Link> list the resource utilization and performance information for the ALTFP_MULT megafunction. The information was derived using the Quartus II software version 10.0. </P></Sect><P>Table 4–3. ALTFP_MULT Resource Utilization and Performance for the Stratix Series of Devices with Dedicated Multiplier Circuitry </P><Table><TR><TH>Device Family </TH><TH>Precision </TH><TH>Output latency </TH><TH/><TH>Logic usage </TH><TH/><TH>fMAX (MHz)</TH></TR><TR><TH>Adaptive Look-Up Tables (ALUTs) </TH><TH>Dedicated Logic Registers (DLRs) </TH><TH>Adaptive Logic Modules (ALMs) </TH><TH>18-bit DSP </TH></TR><TR><TH>Stratix III </TH><TH>Single </TH><TD>5 </TD><TD>138 </TD><TD>148 </TD><TD>101 </TD><TD>4 </TD><TD>240 </TD></TR><TR><TD>11 </TD><TD>195 </TD><TD>301 </TD><TD>206 </TD><TD>4 </TD><TD>466 </TD></TR><TR><TH>Double </TH><TD>5 </TD><TD>306 </TD><TD>367 </TD><TD>272 </TD><TD>10 </TD><TD>214 </TD></TR><TR><TD>11 </TD><TD>416 </TD><TD>523 </TD><TD>347 </TD><TD>10 </TD><TD>312 </TD></TR><TR><TH>Stratix IV </TH><TH>Single </TH><TD>5 </TD><TD>138 </TD><TD>148 </TD><TD>100 </TD><TD>4 </TD><TD>274 </TD></TR><TR><TD>11 </TD><TD>185 </TD><TD>301 </TD><TD>190 </TD><TD>4 </TD><TD>445 </TD></TR><TR><TH>Double </TH><TD>5 </TD><TD>306 </TD><TD>367 </TD><TD>272 </TD><TD>10 </TD><TD>255 </TD></TR><TR><TD>11 </TD><TD>419 </TD><TD>523 </TD><TD>348 </TD><TD>10 </TD><TD>395 </TD></TR></Table><P>Table 4–4. ALTFP_MULT Resource Utilization and Performance for the Cyclone Series of Devices with Dedicated Multiplier Circuitry </P><Table><TR><TH>Device Family </TH><TH>Precision </TH><TH>Output latency </TH><TH/><TH>Logic usage </TH><TH/><TH>fMAX (MHz)</TH></TR><TR><TD> Logic Elements (LEs) </TD><TD>Dedicated Logic Registers (DLRs) </TD><TD>Total Logic Utilization </TD></TR><TR><TH>Cyclone II </TH><TD>Single </TD><TD>5 </TD><TD>296 </TD><TD>221 </TD><TD>296 </TD><TD>188 </TD></TR><TR><TD>Double </TD><TD>5 </TD><TD>688 </TD><TD>412 </TD><TD>688 </TD><TD>101 </TD></TR><TR><TH>Cyclone III </TH><TD>Single </TD><TD>5 </TD><TD>295 </TD><TD>221 </TD><TD>295 </TD><TD>209 </TD></TR><TR><TD>Double </TD><TD>5 </TD><TD>687 </TD><TD>412 </TD><TD>687 </TD><TD>122 </TD></TR></Table><Sect/><P id="LinkTarget_7194">Design Example: Multiplication of Double-Precision Format Numbers </P><Sect><P>This design example uses the ALTFP_MULT megafunction to compute the multiplication results of two double-precision format numbers. This example uses the MegaWizard Plug-In Manager in the Quartus II software. </P></Sect><P id="LinkTarget_7195">Design Files </P><Sect><P>The following files are related to the ALTFP_MULT megafunction: </P><L><LI><LI_Label>■ </LI_Label><LI_Title>altfp_mult_DesignExample.zip (Quartus II design files) </LI_Title></LI><LI><LI_Label>■ </LI_Label><LI_Title>altfp_mult_ex_msim.zip (ModelSim-Altera files) </LI_Title></LI></L></Sect><P id="LinkTarget_7196">Understanding the Simulation Results </P><Sect><P><Link>Figure 4–2</Link> shows the expected simulation results in the ModelSim-Altera software. </P></Sect><P>1 	The simulation waveform in this design example is not shown in its entirety. Run the design example files in the ModelSim-Altera software to see the complete simulation waveforms. </P><P>Figure 4–2. ALTFP_MULT Simulation Waveform </P><Figure><ImageData src="images/math_ip_altera_megafunctions_img_14.jpg"/></Figure><Sect><P>110 ns </P><P>This design example implements a floating-point multiplier for the multiplication of double-precision format numbers. All the optional input ports (clk_en and aclr) and output ports (overflow, underflow, zero, and nan) are enabled. </P><P>In this example, the latency is set to 6 clock cycles. Therefore, every multiplication result appears at the result port 6 clock cycles later. </P></Sect><Sect><P><Link>Table 4–5</Link> lists the inputs and corresponding outputs obtained from the simulation in <Link>Figure 4–2</Link>. </P><P>Table 4–5. Summary of Input Values and Corresponding Outputs </P></Sect><Table><TR><TD>Time </TD><TD>Event </TD></TR><TR><TD>0 ns, start-up </TD><TD>dataa[] value: 0000 0000 0000 0000h datab[] value: 4037 742C 3C9E ECC0h Output value: All values seen on the output port before the 6th clock cycle are merely due to the behavior of the system during start-up and should be disregarded. </TD></TR><TR><TD>110 ns </TD><TD>Output value: 0000 0000 0000 0000h Exception handling ports: zero asserts The multiplication of zero at the input port dataa[], and a non-zero value at the input port datab[] results in a zero. </TD></TR><TR><TD>600 ns </TD><TD>dataa[] value: 7FF0 0000 0000 0000h datab[] value: 4037 742C 3C9E ECC0h This is the multiplication of an infinity value and a normal value. </TD></TR><TR><TD>710 ns </TD><TD>Output value: 7FF0 0000 0000 0000h Exception handling ports: overflow asserts The multiplication of an infinity value and a normal value results in infinity. All multiplications with an infinity value results in infinity except when infinity is multiplied with a zero. </TD></TR></Table><P id="LinkTarget_7197">Specifications </P><Sect><P>This section describes the component declarations, ports, and parameters of the ALTFP_MULT megafunction. The ports and parameters are available to customize the ALTFP_MULT megafunction according to your application. </P></Sect><P id="LinkTarget_7198">VHDL Component Declaration </P><Sect><P>The following VHDL component declaration is located in the VHDL Design File (.vhd) altera_mf_components.vhd in the &lt;Quartus II installation directory&gt;\libraries\vhdl\altera_mf directory. </P></Sect><P>component altfp_mult
</P><P>     generic (
     dedicated_multiplier_circuitry  :     string := &quot;AUTO&quot;;
     intended_device_family  :     string := &quot;unused&quot;;
     pipeline    :     natural := 5;
     width_exp   :     natural := 8;
     width_man   :     natural := 23;
     lpm_hint    :     string := &quot;UNUSED&quot;;
     lpm_type    :     string := &quot;altfp_mult"
</P><Sect><P> );
</P></Sect><P>     port(
     aclr  :     in std_logic := '0';
     clk_en  :     in std_logic := '1';
     clock  :     in std_logic;
     dataa  :     in std_logic_vector(width_exp+width_man+1-1 downto 0);
     datab  :     in std_logic_vector(width_exp+width_man+1-1 downto 0);
 nan :     out std_logic;
     overflow    :     out std_logic; 
</P><Sect/><Table><TR><TH>  result  </TH><TH>:</TH><TH> out std_logic_vector(width_exp+width_man+1-1 downto 0);</TH></TR><TR><TD>     underflow   </TD><TD>: </TD><TD>    out std_logic;</TD></TR><TR><TD>     zero  </TD><TD>: </TD><TD>    out std_logic</TD></TR><TR><TD> ); </TD><TD/><TD/></TR><TR><TD>end component; </TD><TD/><TD/></TR></Table><P id="LinkTarget_7199">VHDL LIBRARY-USE Declaration </P><Sect><P>The VHDL LIBRARY-USE declaration is not required if you use the VHDL Component Declaration. </P><P>LIBRARY altera_mf; 
USE altera_mf_altera_mf_components.all; 
</P></Sect><P id="LinkTarget_7200">Ports and Parameters </P><Sect><P><Link>Table 4–6</Link> lists the input ports of the ALTFP_MULT megafunction. </P></Sect><P>Table 4–6. ALTFP_MULT Megafunction Input Ports </P><Table><TR><TH>Port Name </TH><TH>Required </TH><TH>Description </TH></TR><TR><TD>clock </TD><TD>Yes </TD><TD>Clock input to the megafunction. </TD></TR><TR><TD>clk_en </TD><TD>No </TD><TD>Clock enable. Allows multiplication to take place when asserted high. When signal is asserted low, no multiplication occurs and the outputs remain unchanged. </TD></TR><TR><TD>aclr </TD><TD>No </TD><TD>Synchronous clear. Source is asynchronously reset when asserted high. </TD></TR><TR><TD>dataa[] </TD><TD>Yes </TD><TD>Floating-point input data input to the multiplier. The MSB is the sign, the next MSBs are the exponent, and the LSBs are the mantissa. This input port size is the total width of sign bit, exponent bits, and mantissa bits. </TD></TR><TR><TD>datab[] </TD><TD>Yes </TD><TD>Floating-point input data to the multiplier. The MSB is the sign, the next MSBs are the exponent, and the LSBs are the mantissa. This input port size is the total width of sign bit, exponent bits, and mantissa bits. </TD></TR></Table><Sect><P><Link>Table 4–7</Link> lists the output ports of the ALTFP_MULT megafunction. </P></Sect><P>Table 4–7. ALTFP_MULT Megafunction Output Ports </P><Table><TR><TH>Port Name </TH><TH>Required </TH><TH>Description </TH></TR><TR><TD>result[] </TD><TD>Yes </TD><TD>Output port for the multiplier. The floating-point result after rounding. The MSB is the sign, the next MSBs are the exponent, and the LSBs are the mantissa. </TD></TR><TR><TD>overflow </TD><TD>No </TD><TD>Overflow port for the multiplier. Asserted when the result of the multiplication, after rounding, exceeds or reaches infinity. Infinity is defined as a number in which the exponent exceeds 2WIDTH_EXP-1. </TD></TR><TR><TD>underflow </TD><TD>No </TD><TD>Underflow port for the multiplier. Asserted when the result of the multiplication (after rounding) is 0 while none of the inputs to the multiplication is 0, or asserted when the result is a denormalized number. </TD></TR><TR><TD>zero </TD><TD>No </TD><TD>Zero port for the multiplier. Asserted when the value of result[] is 0. </TD></TR><TR><TD>nan </TD><TD>No </TD><TD>NaN port for the multiplier. This port is asserted when an invalid multiplication occurs, such as the multiplication of infinity and zero. In this case, a NaN value is the output generated at the result[] port. The multiplication of any value and NaN produces NaN. </TD></TR></Table><Sect><P><Link>Table 4–8</Link> lists the parameters of the ALTFP_MULT megafunction. </P></Sect><P>Table 4–8. ALTFP_MULT Megafunction Parameters </P><Table><TR><TH>Parameter Name </TH><TH>Type </TH><TH>Required </TH><TH>Description </TH></TR><TR><TD>WIDTH_EXP </TD><TD>Integer </TD><TD>No </TD><TD>Specifies the value of the exponent. If this parameter is not specified, the default is 8. The bias of the exponent is always 2(WIDTH_EXP-1)-1 (that is, 127 for the single-precision format and 1023for the double-precision format). WIDTH_EXP must be 8for the single-precision format or a minimum of 11 for the double-precision format and the single-extended precision format. WIDTH_EXP must less than WIDTH_MAN. The sum of WIDTH_EXP and WIDTH_MAN must be less than 64. </TD></TR><TR><TD>WIDTH_MAN </TD><TD>Integer </TD><TD>No </TD><TD>Specifies the value of the mantissa. If this parameter is not specified, the default is 23. When WIDTH_EXP is 8 and the floating-point format is single-precision, the WIDTH_MAN value must be 23; otherwise, the value of WIDTH_MANmust be a minimum of 31. The WIDTH_MAN value must always be greater than the WIDTH_EXP value. The sum of WIDTH_EXP and WIDTH_MAN must be less than 64. </TD></TR><TR><TD>DEDICATED_MULTIPLIER_ CIRCUITRY </TD><TD>String </TD><TD>No </TD><TD>Specifies whether to use dedicated multiplier circuitry. Values are AUTO, YES, or NO. If this parameter is not specified, the default is AUTO. If a device does not have dedicated multiplier circuitry, the DEDICATED_MULTIPLIER_CIRCUITRY parameter has no effect and defaults to NO. </TD></TR><TR><TD>PIPELINE </TD><TD>Integer </TD><TD>No </TD><TD>Specifies the number of clock cycles needed to produce the multiplied result. Values are 5, 6, 10, and 11. If this parameter is not specified, the default is 5. </TD></TR></Table><Figure><ImageData src="images/math_ip_altera_megafunctions_img_15.jpg"/></Figure></Sect><Sect><Sect><H2 id="LinkTarget_7201">5. ALTFP_SQRT 
</H2><P><Link>Figure 5–1</Link> shows the ports for the ALTFP_SQRT megafunction. </P><P>Figure 5–1. ALTFP_SQRT Ports </P><Figure><ImageData src="images/math_ip_altera_megafunctions_img_16.jpg"/>data[] clock clk_en inst ALTFP_SQRT result[] overflow nan zero aclr </Figure><P id="LinkTarget_7202">Features </P><P>The ALTFP_SQRT megafunction offers the following features: </P><L><LI><LI_Label>■ </LI_Label><LI_Title>Square root functions. </LI_Title></LI><LI><LI_Label>■ </LI_Label><LI_Title>Optional exception handling output ports such as zero, overflow, and nan. </LI_Title></LI></L></Sect><P id="LinkTarget_7203">Output Latency </P><Sect><P>The output latency options for the ALTFP_SQRT megafunction differs depending on the precision selected, the width of the mantissa, or both. </P><P><Link>Table 5–1 </Link>lists the output latency options required for each precision format. </P><P>Table 5–1. Latency Options for Each Precision Format (Part 1 of 2) </P></Sect><Table><TR><TH>Precision </TH><TH>Mantissa Width </TH><TH>Latency (in clock cycles) </TH></TR><TR><TD>Single </TD><TD>23 </TD><TD>16, 28 </TD></TR><TR><TD>Double </TD><TD>52 </TD><TD>30, 57 </TD></TR></Table><Sect><P>Table 5–1. Latency Options for Each Precision Format (Part 2 of 2) </P></Sect><Table><TR><TH>Precision </TH><TH>Mantissa Width </TH><TH>Latency (in clock cycles) </TH></TR><TR><TH>Single-extended </TH><TD>31 </TD><TD>20, 36 </TD></TR><TR><TD>32 </TD><TD>20, 37 </TD></TR><TR><TD>33 </TD><TD>21, 38 </TD></TR><TR><TD>34 </TD><TD>21, 39 </TD></TR><TR><TD>35 </TD><TD>22, 40 </TD></TR><TR><TD>36 </TD><TD>22, 41 </TD></TR><TR><TD>37 </TD><TD>23, 42 </TD></TR><TR><TD>38 </TD><TD>23, 43 </TD></TR><TR><TD>39 </TD><TD>24, 44 </TD></TR><TR><TD>40 </TD><TD>24, 45 </TD></TR><TR><TD>41 </TD><TD>25, 46 </TD></TR><TR><TD>42 </TD><TD>25, 47 </TD></TR><TR><TD>43 </TD><TD>26, 48 </TD></TR><TR><TD>44 </TD><TD>26, 49 </TD></TR><TR><TD>45 </TD><TD>27, 50 </TD></TR><TR><TD>46 </TD><TD>27, 51 </TD></TR><TR><TD>47 </TD><TD>28, 52 </TD></TR><TR><TD>48 </TD><TD>28, 53 </TD></TR><TR><TD>49 </TD><TD>29, 54 </TD></TR><TR><TD>50 </TD><TD>29, 55 </TD></TR><TR><TD>51 </TD><TD>30, 56 </TD></TR></Table><Sect><P id="LinkTarget_7204">Truth Table </P><P><Link>Table 5–2 </Link>lists the truth table for square root operations. </P><P>Table 5–2. Truth Table for Square Root Operations </P></Sect><Table><TR><TH>DATA[] </TH><TH>SIGN BIT </TH><TH>RESULT[] </TH><TH>NaN </TH><TH>Overflow </TH><TH>Zero </TH></TR><TR><TH>Normal </TH><TD>0 </TD><TD>Normal </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD></TR><TR><TH>Denormal </TH><TD>0/1 </TD><TD>Zero </TD><TD>0 </TD><TD>0 </TD><TD>1 </TD></TR><TR><TH>Positive Infinity </TH><TD>0 </TD><TD>Infinity </TD><TD>0 </TD><TD>1 </TD><TD>0 </TD></TR><TR><TH>Negative Infinity </TH><TD>1 </TD><TD>All 1’s </TD><TD>1 </TD><TD>0 </TD><TD>0 </TD></TR><TR><TH>Positive NaN </TH><TD>0 </TD><TD>All 1’s </TD><TD>1 </TD><TD>0 </TD><TD>0 </TD></TR><TR><TH>Negative NaN </TH><TD>1 </TD><TD>All 1’s </TD><TD>1 </TD><TD>0 </TD><TD>0 </TD></TR><TR><TH>Zero </TH><TD>0/1 </TD><TD>Zero </TD><TD>0 </TD><TD>0 </TD><TD>1 </TD></TR><TR><TH>Normal </TH><TD>1 </TD><TD>All 1’s </TD><TD>1 </TD><TD>0 </TD><TD>0 </TD></TR></Table><P id="LinkTarget_7205">Resource Utilization and Performance </P><Sect><P><Link>Table 5–3 </Link>lists the resource utilization and performance information for the ALTFP_SQRT megafunction. The information was derived using the Quartus II software version 10.0. </P><P>Table 5–3. ALTFP_SQRT Resource Utilization and Performance for the Stratix Series of Devices </P></Sect><Table><TR><TH>Device Family </TH><TH>Precision </TH><TH>Output latency </TH><TH/><TH>Logic usage </TH><TH/><TH>fMAX (MHz)</TH></TR><TR><TD>Adaptive Look-Up Tables (ALUTs) </TD><TD>Dedicated Login Registers (DLRs) </TD><TD>Adaptive Logic Modules (ALMs) </TD></TR><TR><TH>Stratix III </TH><TD>Single </TD><TD>28 </TD><TD>526 </TD><TD>942 </TD><TD>536 </TD><TD>396 </TD></TR><TR><TD>Double </TD><TD>57 </TD><TD>2,311 </TD><TD>3,815 </TD><TD>2,311 </TD><TD>283 </TD></TR><TR><TH>Stratix IV </TH><TD>Single </TD><TD>28 </TD><TD>502 </TD><TD>932 </TD><TD>528 </TD><TD>472 </TD></TR><TR><TD>Double </TD><TD>57 </TD><TD>2,177 </TD><TD>3,725 </TD><TD>2,202 </TD><TD>366 </TD></TR></Table><P id="LinkTarget_7206">Design Example: Square Root of Single-Precision Format Numbers </P><Sect><P>This design example uses the ALTFP_SQRT megafunction to compute the square root of single-precision format numbers. This example uses the MegaWizard Plug-In Manager in the Quartus II software. </P></Sect><P id="LinkTarget_7207">Design Files </P><Sect><P>The following files are related to the ALTFP_SQRT megafunction: </P><L><LI><LI_Label>■ </LI_Label><LI_Title>altfp_sqrt_DesignExample.zip (Quartus II design files) </LI_Title></LI><LI><LI_Label>■ </LI_Label><LI_Title>altfp_sqrt_ex_msim.zip (ModelSim-Altera files) </LI_Title></LI></L></Sect><P id="LinkTarget_7208">Understanding the Simulation Results </P><Sect><P><Link>Figure 5–2</Link> and <Link>Figure 5–3</Link> show the expected simulation results in the ModelSim-Altera software. </P></Sect><P>1 	The simulation waveform in this design example is not shown in its entirety. Run the design example files in the ModelSim-Altera software to see the complete simulation waveforms. </P><Sect/><P>Figure 5–2. ModelSim Simulation Waveform (Input Data) </P><Figure><ImageData src="images/math_ip_altera_megafunctions_img_17.jpg"/></Figure><P>Figure 5–3. ModelSim Simulation Waveform (Output Data) </P><Figure><ImageData src="images/math_ip_altera_megafunctions_img_18.jpg"/></Figure><Sect><P>96000 ns 105000 ns </P><P>This design example implements a floating-point square root function for single-precision format numbers with all the exception output ports instantiated. The output ports include overflow, zero, and nan. </P><P>The output latency is 28 clock cycles. Every square root computation generates the output result 28 clock cycles later. </P><P><Link>Table 5–4</Link> lists the inputs and corresponding outputs obtained from the simulation in <Link>Figure 5–2 on page 5–4</Link> and <Link>Figure 5–3</Link>. </P><P>Table 5–4. Summary of Input Values and Corresponding Outputs (Part 1 of 2) </P></Sect><Table><TR><TD>Time </TD><TD>Event </TD></TR><TR><TD>0 ns, start-up </TD><TD>Output value: All values seen on the output port before the 28th clock cycle are merely due to the behavior of the system during start-up and should be disregarded. </TD></TR><TR><TD>2 000 ns </TD><TD>data[] value: 2D0B 496Ah The data input is a normal number. </TD></TR><TR><TD>84 000 ns </TD><TD>Output value: 363C D4EBh The square root computation of a normal input results in a normal output. </TD></TR><TR><TD>14 000 ns </TD><TD>data[] value: 0000 0000h </TD></TR><TR><TD>96 000 ns </TD><TD>Output value: 0000 0000h Exception handling ports: zero asserts The square root computation of zero results in a zero. </TD></TR></Table><Sect><P>Table 5–4. Summary of Input Values and Corresponding Outputs (Part 2 of 2) </P></Sect><Table><TR><TH>Time </TH><TH>Event </TH></TR><TR><TD>23 000 ns </TD><TD>data[] value: 7F80 0000h The input is infinity. </TD></TR><TR><TD>105 000 ns </TD><TD>Output value: 7F80 0000h Exception handling ports: overflow asserts </TD></TR></Table><P id="LinkTarget_7209">Specifications </P><Sect><P>This section describes the component declarations, ports, and parameters of the ALTFP_SQRT megafunction. The ports and parameters are available to customize the ALTFP_SQRT megafunction according to your application. </P></Sect><P id="LinkTarget_7210">VHDL Component Declaration </P><Sect><P>The following VHDL component declaration is located in the VHDL Design File (.vhd) altera_mf_components.vhd in the &lt;Quartus II installation directory&gt;\libraries\vhdl\altera_mf directory. </P></Sect><P>component altfp_sqrt
</P><P>     generic (
     intended_device_family  :     string := &quot;unused&quot;;
     exception_handling  :     string := &quot;YES&quot;;
     pipeline    :     natural := 28;
     rounding    :     string := &quot;TO_NEAREST&quot;;
     width_exp   :     natural := 8;
     width_man   :     natural := 23;
     lpm_hint    :     string := &quot;UNUSED&quot;;
     lpm_type    :     string := &quot;altfp_sqrt"
</P><Sect><P> );
</P></Sect><P>     port(
     aclr  :    in std_logic := '0';
     clk_en :       in std_logic := '1';
     clock  :    in std_logic;
     data  :    in std_logic_vector(width_exp+width_man+1-1 downto 0);
 nan :    out std_logic;
     overflow    :    out std_logic;
     result :       out std_logic_vector(width_exp+width_man+1-1 downto 0);
     zero  :    out std_logic
</P><Sect><P> ); 
end component; 
</P></Sect><P id="LinkTarget_7211">VHDL LIBRARY-USE Declaration </P><Sect><P>The VHDL LIBRARY-USE declaration is not required if you use the VHDL Component Declaration. </P><P>LIBRARY altera_mf; 
</P><P>USE altera_mf_altera_mf_components.all; 
</P></Sect><Sect/><P id="LinkTarget_7212">Ports and Parameters </P><Sect><P><Link>Table 5–5</Link> lists the input ports of the ALTFP_SQRT megafunction. </P></Sect><P>Table 5–5. ALTFP_SQRT Megafunction Input Ports </P><Table><TR><TH>Port Name </TH><TH>Required </TH><TH>Description </TH></TR><TR><TD>clock </TD><TD>Yes </TD><TD>Clock input to the megafunction. </TD></TR><TR><TD>clk_en </TD><TD>No </TD><TD>Clock enable that allows square root operations when the port is asserted high. When the port is asserted low, no operation occurs and the outputs remain unchanged. </TD></TR><TR><TD>aclr </TD><TD>No </TD><TD>Asynchronous clear. When the aclr port is asserted high, the function is asynchronously reset. </TD></TR><TR><TD>data[] </TD><TD>Yes </TD><TD>Floating-point input data. The MSB is the sign, the next MSBs are the exponent, and the LSBs are the mantissa. This input port size is the total width of sign bit, exponent bits, and mantissa bits. </TD></TR></Table><Sect><P><Link>Table 5–6</Link> lists the output ports of the ALTFP_SQRT megafunction. </P></Sect><P>Table 5–6. ALTFP_SQRT Megafunction Output Ports </P><Table><TR><TH>Port Name </TH><TH>Required </TH><TH>Description </TH></TR><TR><TD>result[] </TD><TD>Yes </TD><TD>Square root output port for the floating-point result. The MSB is the sign, the next MSBs are the exponent, and the LSBs are the mantissa. The size of this port is the total width of the sign bit, exponent bits, and mantissa bits. </TD></TR><TR><TD>overflow </TD><TD>Yes </TD><TD>Overflow port. Asserted when the result of the square root (after rounding) exceeds or reaches infinity. Infinity is defined as a number in which the exponent exceeds 2WIDTH_EXP -1. </TD></TR><TR><TD>zero </TD><TD>Yes </TD><TD>Zero port. Asserted when the value of the result[] port is 0. </TD></TR><TR><TD>nan </TD><TD>Yes </TD><TD>NaN port. Asserted when an invalid square root occurs, such as negative numbers or NaN inputs. </TD></TR></Table><Sect><P><Link>Table 5–7</Link> lists the parameters of the ALTFP_SQRT megafunction. </P></Sect><P>Table 5–7. ALTFP_SQRT Megafunction Parameters (Part 1 of 2) </P><Table><TR><TH>Parameter Name </TH><TH>Type </TH><TH>Required </TH><TH>Description </TH></TR><TR><TD>WIDTH_EXP </TD><TD>Integer </TD><TD>Yes </TD><TD>Specifies the precision of the exponent. If this parameter is not specified, the default is 8. The bias of the exponent is always set to 2(WIDTH_EXP -1) -1, that is, 127 for the single-precision format and 1023 for the double-precision format. The value of the WIDTH_EXP parameter must be 8for the single-precision format, 11 for the double-precision format, and a minimum of 11for the single-extended precision format. The value of the WIDTH_EXP parameter must be less than the value of the WIDTH_MAN parameter, and the sum of the WIDTH_EXP and WIDTH_MAN parameters must be less than 64. </TD></TR><TR><TD>WIDTH_MAN </TD><TD>Integer </TD><TD>Yes </TD><TD>Specifies the value of the mantissa. If this parameter is not specified, the default is 23. When the WIDTH_EXP parameter is 8 and the floating-point format is single-precision, the WIDTH_MAN parameter value must be 23. Otherwise, the value of the WIDTH_MAN parameter must be a minimum of 31. The value of the WIDTH_MAN parameter must be greater than the value of the WIDTH_EXP parameter. The sum of the WIDTH_EXP and WIDTH_MAN parameters must be less than 64. </TD></TR></Table><Sect/><P>Table 5–7. ALTFP_SQRT Megafunction Parameters (Part 2 of 2) </P><Table><TR><TH>Parameter Name </TH><TH>Type </TH><TH>Required </TH><TH>Description </TH></TR><TR><TD>ROUNDING </TD><TD>String </TD><TD>Yes </TD><TD>Specifies the rounding mode. The default value is TO_NEAREST. Other rounding modes are not supported. </TD></TR><TR><TD>PIPELINE </TD><TD>Integer </TD><TD>Yes </TD><TD>Specifies the number of clock cycles for the square root results of the result[] port. Values are WIDTH_MAN+ 5and ((WIDTH_MAN+ 5/2)+2) as specified by truncating the radix point. </TD></TR></Table><Figure><ImageData src="images/math_ip_altera_megafunctions_img_19.jpg"/></Figure></Sect><Sect><Sect><H2 id="LinkTarget_7213">6. ALTFP_EXP 
</H2><P><Link>Figure 6–1</Link> shows the ports for the ALTFP_EXP megafunction. </P><P>Figure 6–1. ALTFP_EXP Ports </P><Figure><ImageData src="images/math_ip_altera_megafunctions_img_20.jpg"/>data[] clk_en clock inst ALTFP_EXP result[] underflow zero nan underflow aclr </Figure><P id="LinkTarget_7214">Features </P><P>The ALTFP_EXP megafunction offers the following features: </P><L><LI><LI_Label>■ 	</LI_Label><LI_Title>Exponential value of a given input. </LI_Title></LI><LI><LI_Label>■ 	</LI_Label><LI_Title>Optional exception handling output ports such as zero, overflow, underflow, and nan. </LI_Title></LI></L></Sect><P id="LinkTarget_7215">Output Latency </P><Sect><P>The output latency options for the ALTFP_EXP megafunction differs depending on the precision selected, the width of the mantissa, or both. </P><P><Link>Table 6–1 </Link>lists the output latency options required for each precision format. </P><P>Table 6–1. Latency Options for Each Precision Format </P></Sect><Table><TR><TH>Precision </TH><TH>Mantissa Width </TH><TH>Latency (in clock cycles) </TH></TR><TR><TH>Single </TH><TD>23 </TD><TD>17 </TD></TR><TR><TH>Double </TH><TD>52 </TD><TD>25 </TD></TR><TR><TH>Single-extended </TH><TD>31 – 38 </TD><TD>22 </TD></TR><TR><TD>39 – 52 </TD><TD>25 </TD></TR></Table><Sect><P id="LinkTarget_7216">Truth Table </P><P><Link>Table 6–2 </Link>lists the truth table for the exponential operation. </P><P>Table 6–2. Truth Table for Exponential Operations </P></Sect><Table><TR><TH>DATAA[] </TH><TH>Calculation </TH><TH>RESULT[] </TH><TH>NaN </TH><TH>Overflow </TH><TH>Underflow </TH><TH>Zero </TH></TR><TR><TH>Normal </TH><TH>edata </TH><TH>Normal </TH><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD></TR><TR><TH>Normal </TH><TH>edata </TH><TH>Infinity </TH><TD>0 </TD><TD>1 </TD><TD>0 </TD><TD>0 </TD></TR><TR><TH>Normal (numbers of small magnitude) </TH><TH>edata </TH><TD>1 </TD><TD>0 </TD><TD>0 </TD><TD>1 </TD><TD>0 </TD></TR><TR><TH>Normal (negative numbers of large magnitude) </TH><TH>edata </TH><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>1 </TD><TD>0 </TD></TR><TR><TH><Link>Denormal (1) </Link></TH><TH>e0 </TH><TD>1 </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD></TR><TR><TH>Zero </TH><TH>e0 </TH><TD>1 </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD></TR><TR><TH>Infinity (+) </TH><TH>e+ </TH><TD>Infinity </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD></TR><TR><TH>Infinity (-) </TH><TH>e</TH><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>1 </TD></TR><TR><TH>NaN </TH><TH>— </TH><TD>NaN </TD><TD>1 </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD></TR></Table><Sect><P>Note to <Link>Table 6–2</Link>: </P><P>(1) Any denormal input is treated as a zero before going through the exponential process. </P></Sect><P id="LinkTarget_7217">Resource Utilization and Performance </P><Sect><P><Link>Table 6–3 </Link>lists the resource utilization and performance information for the ALTFP_EXP megafunction. The information was derived using the Quartus II software version 10.0. </P></Sect><P>Table 6–3. ALTFP_EXP Resource Utilization and Performance for the Stratix Series of Devices </P><Table><TR><TH>Device Family </TH><TH>Precision </TH><TH>Output Latency </TH><TH/><TH>Logic usage </TH><TH/><TH>fMAX (MHz)</TH></TR><TR><TD>Adaptive Look-Up </TD><TD>Dedicated Logic </TD><TD>Adaptive Logic </TD><TD/></TR><TR><TH/><TD/><TD/><TD>Tables </TD><TD>Registers </TD><TD>Modules </TD><TD>18-bit DSP </TD><TD/></TR><TR><TH/><TD/><TD/><TD>(ALUTs) </TD><TD>(DLRs) </TD><TD>(ALMs) </TD><TD/><TD/></TR><TR><TH>Stratix III </TH><TD>Single </TD><TD>17 </TD><TD>631 </TD><TD>521 </TD><TD>445 </TD><TD>19 </TD><TD>275 </TD></TR><TR><TD>Double </TD><TD>25 </TD><TD>4,138 </TD><TD>2,022 </TD><TD>2,959 </TD><TD>46 </TD><TD>257 </TD></TR><TR><TH>Stratix IV </TH><TD>Single </TD><TD>17 </TD><TD>631 </TD><TD>521 </TD><TD>448 </TD><TD>19 </TD><TD>284 </TD></TR><TR><TD>Double </TD><TD>25 </TD><TD>4,104 </TD><TD>2,007 </TD><TD>2,939 </TD><TD>46 </TD><TD>279 </TD></TR></Table><P id="LinkTarget_7218">Design Example: Exponential of Single-Precision Format Numbers </P><Sect><P>This design example uses the ALTFP_EXP megafunction to compute the exponential value of single-precision format numbers. This example uses the MegaWizard Plug-In Manager in the Quartus II software. </P></Sect><P id="LinkTarget_7219">Design Files </P><Sect><P>The following files are related to the ALTFP_EXP megafunction: </P><L><LI><LI_Label>■ </LI_Label><LI_Title>altfp_exp_DesignExample.zip (Quartus II design files) </LI_Title></LI><LI><LI_Label>■ </LI_Label><LI_Title>altfp_exp_ex_msim.zip (ModelSim-Altera files) </LI_Title></LI></L></Sect><P id="LinkTarget_7220">Understanding the Simulation Results </P><Sect><P><Link>Figure 6–2</Link> and <Link>Figure 6–3</Link> show the expected simulation results in the ModelSim-Altera software. </P></Sect><P>1 	The simulation waveform in this design example is not shown in its entirety. Run the design example files in the ModelSim-Altera software to see the complete simulation waveforms. </P><P>Figure 6–2. ModelSim Simulation Waveform (Input Data) </P><Figure><ImageData src="images/math_ip_altera_megafunctions_img_21.jpg"/></Figure><P>Figure 6–3. ModelSim Simulation Waveform (Output Data) </P><Figure><ImageData src="images/math_ip_altera_megafunctions_img_22.jpg"/><Caption><P>82.5 ns 112.5 ns 142.5 ns 172.5 ns 202.5 ns </P></Caption></Figure><Sect><P>This design example implements a floating-point exponential for the single-precision format numbers. The optional input ports (clk_en and aclr) and all four exception handling output ports (nan, overflow, underflow, and zero) are enabled. </P><P>For single-precision format numbers, the latency is fixed at 17 clock cycles. Therefore, every exponential operation outputs the results 17 clock cycles later. </P><P><Link>Table 6–4</Link> lists the inputs and corresponding outputs obtained from the simulation in <Link>Figure 6–2 on page 6–3</Link> and <Link>Figure 6–3 on page 6–3</Link>. </P><P>Table 6–4. Summary of Input Values and Corresponding Outputs </P></Sect><Table><TR><TD>Time </TD><TD>Event </TD></TR><TR><TD>0 ns, start-up </TD><TD>data[] value: 1A03 568Ch Output value: An undefined value is seen on the result[] port, which is ignored. All values seen on the output port before the 17th clock cycle are merely due to the behavior of the system during start-up and should be disregarded. </TD></TR><TR><TD>82.5 ns </TD><TD>Output value: 3F80 0000h As the input value of 1A03568Ch is a very small number, it is seen as a value that is approaching zero, and the result approaches 1 (which is represented by 3F800000). Exponential operations carried out on numbers of very small magnitudes result in a 1 and assert the underflow flag. Exception handling ports: underflow asserts </TD></TR><TR><TD>30 ns </TD><TD>data[] value: F3FC DEFFh This is a normal negative value of a very large magnitude. </TD></TR><TR><TD>112.5 ns </TD><TD>Output value: 0000 0000h The outcome of exponential operations on negative numbers of very large magnitudes approaches zero. Exception handling ports: underflow remains asserted </TD></TR><TR><TD>60 ns </TD><TD>data[] value: 7F80 0000h This is a positive infinite value. </TD></TR><TR><TD>142.5 ns </TD><TD>Output value: 7F80 0000h The operation on positive infinite values results in infinity. Exception handling ports: underflow deasserts, overflow asserts </TD></TR><TR><TD>90 ns </TD><TD>data[] value: 7FC0 0000h This is a NaN. </TD></TR><TR><TD>172.5 ns </TD><TD>Output value: 7FC0 0000h The exponential of a NaN results in a NaN. Exception handling ports: nan asserts </TD></TR><TR><TD>120 ns </TD><TD>data[] value: C1D4 49BAh This is a normal value. </TD></TR><TR><TD>202.5 ns </TD><TD>Output value: 2C52 5981h The result is a normal value. Exception handling ports: nan deasserts </TD></TR></Table><Sect/><P id="LinkTarget_7221">Specifications </P><Sect><P>This section describes the component declarations, ports, and parameters of the ALTFP_EXP megafunction. The ports and parameters are available to customize the ALTFP_EXP megafunction according to your application. </P></Sect><P id="LinkTarget_7222">VHDL Component Declaration </P><Sect><P>The following VHDL component declaration is located in the VHDL Design File (.vhd) altera_mf_components.vhd in the &lt;Quartus II installation directory&gt;\libraries\vhdl\altera_mf directory. </P></Sect><P>component altfp_exp 
</P><P>generic (
   intended_device_family : string := &quot;unused&quot;;
   pipeline : natural := 0;
   rounding : string := &quot;TO_NEAREST&quot;;
   width_exp : natural := 8;
   width_man : natural := 23;
   lpm_hint : string := &quot;UNUSED&quot;;
   lpm_type : string := &quot;altfp_exp" 
</P><Sect><P>); 
</P></Sect><P>port(
   aclr : in std_logic := '0';
   clk_en : in std_logic := '1';
   clock : in std_logic;
   data : in std_logic_vector(width_exp+width_man+1-1 downto 0);
   nan : out std_logic;
   overflow : out std_logic;
   result : out std_logic_vector(width_exp+width_man+1-1 downto 0);
   underflow : out std_logic;
   zero : out std_logic 
</P><Sect><P>); 
end component; 
</P></Sect><P id="LinkTarget_7223">VHDL LIBRARY-USE Declaration </P><Sect><P>The VHDL LIBRARY-USE declaration is not required if you use the VHDL Component Declaration. </P><P>LIBRARY altera_mf; 
</P><P>USE altera_mf_altera_mf_components.all; 
</P></Sect><Sect/><P id="LinkTarget_7224">Ports and Parameters </P><Sect><P><Link>Table 6–5</Link> lists the input ports of the ALTFP_EXP megafunction. </P></Sect><P>Table 6–5. ALTFP_EXP Megafunction Input Ports </P><Table><TR><TH>Port Name </TH><TH>Required </TH><TH>Description </TH></TR><TR><TD>aclr </TD><TD>No </TD><TD>Asynchronous clear. When the aclr port is asserted high the function is asynchronously reset. </TD></TR><TR><TD>clk_en </TD><TD>No </TD><TD>Clock enable. When the clk_en port is asserted high, an exponential value operation takes place. When this signal is asserted low, no operation occurs and the outputs remain unchanged. </TD></TR><TR><TD>clock </TD><TD>Yes </TD><TD>Clock input to the megafunction </TD></TR><TR><TD>data[] </TD><TD>Yes </TD><TD>Floating-point input data. The MSB is the sign, the next MSBs are the exponent, and the LSBs are the mantissa. This input port size is the total width of the sign bit, exponent bits, and mantissa bits. </TD></TR></Table><Sect><P><Link>Table 6–6</Link> lists the output ports of the ALTFP_EXP megafunction. </P></Sect><P>Table 6–6. ALTFP_EXP Megafunction Output Ports </P><Table><TR><TH>Port Name </TH><TH>Required </TH><TH>Description </TH></TR><TR><TD>result[] </TD><TD>Yes </TD><TD>The floating-point exponential result of the value at data[]. The MSB is the sign, the next MSBs are the exponent, and the LSBs are the mantissa. The size of this port is the total width of the sign bit, exponent bits, and mantissa bits. </TD></TR><TR><TD>overflow </TD><TD>No </TD><TD>Overflow exception output. Asserted when the result of the operation (after rounding) is infinite. </TD></TR><TR><TD>underflow </TD><TD>No </TD><TD>Underflow exception output. Asserted when the result of the exponential approaches 1 (from numbers of very small magnitude), or when the result approaches 0(from negative numbers of very large magnitudes). </TD></TR><TR><TD>zero </TD><TD>No </TD><TD>Zero exception output. Asserted when the value in the result[] port is zero. </TD></TR><TR><TD>nan </TD><TD>No </TD><TD>NaN exception output. Asserted when an invalid operation occurs. Any operation involving NaN also asserts the nan port. </TD></TR></Table><Sect><P><Link>Table 6–7</Link> lists the parameters of the ALTFP_EXP megafunction. </P></Sect><P>Table 6–7. ALTFP_EXP Megafunction Parameters </P><Table><TR><TH>Parameter Name </TH><TH>Type </TH><TH>Required </TH><TH>Description </TH></TR><TR><TD>WIDTH_EXP </TD><TD>Integer </TD><TD>Yes </TD><TD>Specifies the precision of the exponent. If this parameter is not specified, the default is 8. The bias of the exponent is always set to 2(WIDTH_EXP -1) -1, that is, 127 for the single-precision format and 1023 for the double-precision format. The value of the WIDTH_EXP parameter must be 8 for the single-precision format, 11 for the double-precision format, and a minimum of 11 for the single-extended precision format. The value of the WIDTH_EXP parameter must be less than the value of the WIDTH_MAN parameter, and the sum of the WIDTH_EXP and WIDTH_MAN parameters must be less than 64. </TD></TR><TR><TD>WIDTH_MAN </TD><TD>Integer </TD><TD>Yes </TD><TD>Specifies the value of the mantissa. If this parameter is not specified, the default is 23. When the WIDTH_EXP parameter is 8 and the floating-point format is single-precision, the WIDTH_MAN parameter value must be 23. Otherwise, the value of the WIDTH_MAN parameter must be a minimum of 31. The value of the WIDTH_MAN parameter must be greater than the value of the WIDTH_EXP parameter. The sum of the WIDTH_EXP and WIDTH_MAN parameters must be less than 64. </TD></TR><TR><TD>PIPELINE </TD><TD>Integer </TD><TD>Yes </TD><TD>Specifies the amount of latency, expressed in clock cycles, used in the ALTFP_EXP megafunction. Acceptable pipeline values are 17, 22, and 25 cycles of latency. Create the ALTFP_EXP megafunction with the MegaWizard Plug-In Manager to calculate the value for this parameter. </TD></TR><TR><TD>ROUNDING </TD><TD>String </TD><TD>Yes </TD><TD>Specifies the rounding mode. The default value is TO_NEAREST. Other rounding modes are not supported. </TD></TR></Table><Figure><ImageData src="images/math_ip_altera_megafunctions_img_23.jpg"/></Figure></Sect><Sect><Sect><H2 id="LinkTarget_7225">7. ALTFP_INV 
</H2><P><Link>Figure 7–1</Link> shows the ports for the ALTFP_INV megafunction. </P><P>Figure 7–1. ALTFP_INV Ports </P><Figure><ImageData src="images/math_ip_altera_megafunctions_img_24.jpg"/>data[] clk_en clock inst ALTFP_INV result[] underflow zero nan division_by_zero aclr </Figure><P id="LinkTarget_7226">Features </P><P>The ALTFP_INV megafunction offers the following features: </P><L><LI><LI_Label>■ 	</LI_Label><LI_Title>Inverse value of a given input. </LI_Title></LI><LI><LI_Label>■ 	</LI_Label><LI_Title>Optional exception handling output ports such as zero, division_by_zero, underflow, and nan. </LI_Title></LI></L></Sect><P id="LinkTarget_7227">Output Latency </P><Sect><P>The output latency options for the ALTFP_INV megafunction differs depending on the precision selected, the width of the mantissa, or both. </P><P><Link>Table 7–1 </Link>lists the output latency options required for each precision format. </P><P>Table 7–1. Latency Options for Each Precision Format </P></Sect><Table><TR><TH>Precision </TH><TH>Mantissa Width </TH><TH>Latency (in clock cycles) </TH></TR><TR><TH>Single </TH><TD>23 </TD><TD>20 </TD></TR><TR><TH>Double </TH><TD>52 </TD><TD>27 </TD></TR><TR><TH>Single Extended </TH><TD>31 – 39 </TD><TD>20 </TD></TR><TR><TD>40 – 52 </TD><TD>27 </TD></TR></Table><Sect><P id="LinkTarget_7228">Truth Table </P><P><Link>Table 7–2 </Link>lists the truth table for the inverse operation. </P><P>Table 7–2. Truth Table for Inverse Operations </P></Sect><Table><TR><TH>DATA[] </TH><TH>SIGN BIT </TH><TH>RESULT[] </TH><TH>Underflow </TH><TH>Zero </TH><TH>Division_by_zero </TH><TH>NaN </TH></TR><TR><TH>Normal </TH><TD>0/1 </TD><TD>Normal </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD></TR><TR><TH>Normal </TH><TD>0/1 </TD><TD><Link>Denormal (1) </Link></TD><TD>1 </TD><TD>1 </TD><TD>0 </TD><TD>0 </TD></TR><TR><TH>Normal </TH><TD>0/1 </TD><TD>Infinity </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD></TR><TR><TH>Normal </TH><TD>0/1 </TD><TD>Zero </TD><TD>1 </TD><TD>1 </TD><TD>0 </TD><TD>0 </TD></TR><TR><TH><Link>Denormal (2) </Link></TH><TD>0/1 </TD><TD>Infinity </TD><TD>0 </TD><TD>0 </TD><TD>1 </TD><TD>0 </TD></TR><TR><TH>Zero </TH><TD>0/1 </TD><TD>Infinity </TD><TD>0 </TD><TD>0 </TD><TD>1 </TD><TD>0 </TD></TR><TR><TH>Infinity </TH><TD>0/1 </TD><TD>Zero </TD><TD>0 </TD><TD>1 </TD><TD>0 </TD><TD>0 </TD></TR><TR><TH>NaN </TH><TD>X </TD><TD>NaN </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>1 </TD></TR></Table><Sect><P>Notes to <Link>Table 7–2</Link>: </P><L><LI><LI_Label>(1) </LI_Label><LI_Title>Any calculated or computed denormal output is replaced by a zero and asserts the zero and underflow flags. </LI_Title></LI><LI><LI_Label>(2) </LI_Label><LI_Title>Any denormal input is treated as a zero before going through the inverse process. </LI_Title></LI></L></Sect><P id="LinkTarget_7229">Resource Utilization and Performance </P><Sect><P><Link>Table 7–3 </Link>lists the resource utilization and performance information for the ALTFP_INV megafunction. The information was derived using the Quartus II software version 10.0. </P></Sect><P>Table 7–3. ALTFP_INV Resource Utilization and Performance for the Stratix Series of Devices </P><Table><TR><TH>Device Family </TH><TH>Precision </TH><TH>Output Latency </TH><TH/><TH>Logic usage </TH><TH/><TH>fMAX (MHz)</TH></TR><TR><TD>Adaptive Look-Up Tables (ALUTs) </TD><TD>Dedicated Logic Registers (DLRs) </TD><TD>Adaptive Logic Modules (ALMs) </TD><TD>18-Bit DSP </TD></TR><TR><TH>Stratix III </TH><TD>Single </TD><TD>20 </TD><TD>413 </TD><TD>640 </TD><TD>376 </TD><TD>16 </TD><TD>427 </TD></TR><TR><TD>Double </TD><TD>27 </TD><TD>1,049 </TD><TD>1,574 </TD><TD>990 </TD><TD>48 </TD><TD>187 </TD></TR><TR><TH>Stratix IV </TH><TD>Single </TD><TD>20 </TD><TD>401 </TD><TD>616 </TD><TD>373 </TD><TD>16 </TD><TD>412 </TD></TR><TR><TD>Double </TD><TD>27 </TD><TD>939 </TD><TD>1,386 </TD><TD>912 </TD><TD>48 </TD><TD>203 </TD></TR></Table><P id="LinkTarget_7230">Design Example: Inverse of Single-Precision Format Numbers </P><Sect><P>This design example uses the ALTFP_INV megafunction to compute the inverse of single-precision format numbers. This example uses the MegaWizard Plug-In Manager in the Quartus II software. </P></Sect><P id="LinkTarget_7231">Design Files </P><Sect><P>The following files are related to the ALTFP_INV megafunction: </P><L><LI><LI_Label>■ </LI_Label><LI_Title>altfp_inv_DesignExample.zip (Quartus II design files) </LI_Title></LI><LI><LI_Label>■ </LI_Label><LI_Title>altfp_inv_ex_msim.zip (ModelSim-Altera files) </LI_Title></LI></L></Sect><P id="LinkTarget_7232">Understanding the Simulation Results </P><Sect><P><Link>Figure 7–2</Link> and <Link>Figure 7–3</Link> show the expected simulation results in the ModelSim-Altera software. </P></Sect><P>1 	The simulation waveform in this design example is not shown in its entirety. Run the design example files in the ModelSim-Altera software to see the complete simulation waveforms. </P><P>Figure 7–2. ModelSim Simulation Waveform (Input Data) </P><Figure><ImageData src="images/math_ip_altera_megafunctions_img_25.jpg"/></Figure><P>Figure 7–3. ModelSim Simulation Waveform (Output Data) </P><Figure><ImageData src="images/math_ip_altera_megafunctions_img_26.jpg"/></Figure><Sect><P>97.5 ns 107.5 ns </P></Sect><Sect><P>This design example implements a floating-point inverse for single-precision format numbers. The optional input ports (clk_en and aclr) and all four exception handling output ports (division_by_zero, nan, zero, and underflow) are enabled. </P><P>The latency is fixed at 20 clock cycles; therefore, every inverse operation outputs results 20 clock cycles later. </P><P><Link>Table 7–4</Link> lists the inputs and corresponding outputs obtained from the simulation in <Link>Figure 7–2 on page 7–3</Link> and <Link>Figure 7–3 on page 7–3</Link>. </P><P>Table 7–4. Summary of Input Values and Corresponding Outputs </P></Sect><Table><TR><TD>Time </TD><TD>Event </TD></TR><TR><TD>0 ns, start-up </TD><TD>data[] value: 34A2 E42Fh Output value: An undefined value is seen on the result[] port, which is ignored. All values seen on the output port before the 20th clock cycle are merely due to the behavior of the system during start-up and should be disregarded. </TD></TR><TR><TD>97.5 ns </TD><TD>Output value: 4A49 2A2Fh Exception handling ports: division_by_zero deasserts The inverse of a normal number results in a normal value. </TD></TR><TR><TD>10 ns </TD><TD>data[] value: 7F80 0000h This is an infinity value. </TD></TR><TR><TD>107.5 ns </TD><TD>Output value: 0000 0000h Exception handling ports: zero asserts The inverse of an infinity value produces a zero. </TD></TR><TR><TD>60 ns </TD><TD>data[] value: 7FC0 0000h This is a NaN. </TD></TR><TR><TD>157.5 ns </TD><TD>Output value: 7FC0 0000h Exception handling ports: nan asserts The inverse of a NaN results in a NaN </TD></TR><TR><TD>70 ns </TD><TD>data[] value: 0000 1000h This is a denormal number. </TD></TR><TR><TD>167.5 ns </TD><TD>Output value: 7F80 0000h Exception handling ports: nan deasserts, division_by_zero asserts Denormal numbers are forced-zero values, therefore, the inverse of a zero results in infinity. </TD></TR></Table><Sect/><P id="LinkTarget_7233">Specifications </P><Sect><P>This section describes the component declarations, ports, and parameters of the ALTFP_INV megafunction. The ports and parameters are available to customize the ALTFP_INV megafunction according to your application. </P></Sect><P id="LinkTarget_7234">VHDL Component Declaration </P><Sect><P>The following VHDL component declaration is located in the VHDL Design File (.vhd) altera_mf_components.vhd in the &lt;Quartus II installation directory&gt;\libraries\vhdl\altera_mf directory. </P></Sect><P>component altfp_inv 
</P><P>generic (
   intended_device_family : string := &quot;unused&quot;;
   pipeline : natural := 20;
   rounding : string := &quot;TO_NEAREST&quot;;
   width_exp : natural := 8;
   width_man : natural := 23;
   lpm_hint : string := &quot;UNUSED&quot;;
   lpm_type : string := &quot;altfp_inv" 
</P><Sect><P>); 
</P></Sect><P>port(
   aclr : in std_logic := '0';
   clk_en : in std_logic := '1';
   clock : in std_logic;
   data : in std_logic_vector(width_exp+width_man+1-1 downto 0);
   division_by_zero : out std_logic;
   nan : out std_logic;
   result : out std_logic_vector(width_exp+width_man+1-1 downto 0);
   underflow : out std_logic;
   zero : out std_logic 
</P><Sect><P>); 
end component; 
</P></Sect><P id="LinkTarget_7235">VHDL LIBRARY-USE Declaration </P><Sect><P>The VHDL LIBRARY-USE declaration is not required if you use the VHDL Component Declaration. </P><P>LIBRARY altera_mf; 
</P><P>USE altera_mf_altera_mf_components.all; 
</P></Sect><Sect/><P id="LinkTarget_7236">Ports and Parameters </P><Sect><P><Link>Table 7–5</Link> lists the input ports of the ALTFP_INV megafunction. </P></Sect><P>Table 7–5. ALTFP_INV Megafunction Input Ports </P><Table><TR><TH>Port Name </TH><TH>Required </TH><TH>Description </TH></TR><TR><TD>aclr </TD><TD>No </TD><TD>Asynchronous clear. When the aclr port is asserted high, the function is asynchronously cleared. </TD></TR><TR><TD>clk_en </TD><TD>No </TD><TD>Clock enable. When the clk_en port is asserted high, an inversion value operation takes place. When signal is asserted low, no operation occurs and the outputs remain unchanged. </TD></TR><TR><TD>clock </TD><TD>Yes </TD><TD>Clock input to the megafunction. </TD></TR><TR><TD>data[] </TD><TD>Yes </TD><TD>Floating-point input data. The MSB is the sign, the next MSBs are the exponent, and the LSBs are the mantissa. This input port size is the total width of the sign bit, exponent bits, and mantissa bits. </TD></TR></Table><Sect><P><Link>Table 7–6</Link> lists the output ports of the ALTFP_INV megafunction. </P></Sect><P>Table 7–6. ALTFP_INV Megafunction Output Ports </P><Table><TR><TH>Port Name </TH><TH>Required </TH><TH>Description </TH></TR><TR><TD>result[] </TD><TD>Yes </TD><TD>The floating-point inverse result of the value at the data[]input port. The MSB is the sign, the next MSBs are the exponent, and the LSBs are the mantissa. The size of this port is the total width of the sign bit, exponent bits, and mantissa bits. </TD></TR><TR><TD>underflow </TD><TD>No </TD><TD>Underflow exception output. Asserted when the result of the inversion (after rounding) is a denormalized number. </TD></TR><TR><TD>zero </TD><TD>No </TD><TD>Zero exception output. Asserted when the value at the result[] port is a zero. </TD></TR><TR><TD>division_by_zero </TD><TD>No </TD><TD>Division-by-zero exception output. Asserted when the denominator input is a zero. </TD></TR><TR><TD>nan </TD><TD>No </TD><TD>NaN exception output. Asserted when an invalid inversion occurs, such as the inversion of NaN. In this case, a NaN value is output to the result[] port. Any operation involving NaN also asserts the nan port. </TD></TR></Table><Sect><P><Link>Table 7–7</Link> lists the parameters of the ALTFP_INV megafunction. </P></Sect><P>Table 7–7. ALTFP_INV Megafunction Parameters </P><Table><TR><TH>Parameter Name </TH><TH>Type </TH><TH>Required </TH><TH>Description </TH></TR><TR><TD>WIDTH_EXP </TD><TD>Integer </TD><TD>Yes </TD><TD>Specifies the precision of the exponent. If this parameter is not specified, the default is 8. The bias of the exponent is always set to 2(WIDTH_EXP -1) -1, that is, 127 for the single-precision format and 1023 for the double-precision format. The value of the WIDTH_EXP parameter must be 8for the single-precision format, 11 for the double-precision format, and a minimum of 11 for the single-extended precision format. The value of the WIDTH_EXP parameter must be less than the value of the WIDTH_MAN parameter, and the sum of the WIDTH_EXP and WIDTH_MAN parameters must be less than 64. </TD></TR><TR><TD>WIDTH_MAN </TD><TD>Integer </TD><TD>Yes </TD><TD>Specifies the value of the mantissa. If this parameter is not specified, the default is 23. When the WIDTH_EXP parameter is 8 and the floating-point format is single-precision, the WIDTH_MAN parameter value must be 23. Otherwise, the value of the WIDTH_MAN parameter must be a minimum of 31. The value of the WIDTH_MAN parameter must be greater than the value of the WIDTH_EXP parameter. The sum of the WIDTH_EXP and WIDTH_MAN parameters must be less than 64. </TD></TR><TR><TD>PIPELINE </TD><TD>Integer </TD><TD>Yes </TD><TD>Specifies the amount of latency in clock cycles used in the ALTFP_INV megafunction. Create the ALTFP_INV megafunction with the MegaWizard Plug-In Manager to calculate the value for this parameter. </TD></TR><TR><TD>ROUNDING </TD><TD>String </TD><TD>No </TD><TD>Specifies the rounding mode. The default value is TO_NEAREST. Other rounding modes are not supported. </TD></TR></Table><Figure><ImageData src="images/math_ip_altera_megafunctions_img_27.jpg"/></Figure></Sect><Sect><Sect><H2 id="LinkTarget_7237">8. ALTFP_INV_SQRT 
</H2><P><Link>Figure 8–1</Link> shows the ports for the ALTFP_INV_SQRT megafunction. </P><P>Figure 8–1. ALTFP_INV_SQRT Ports </P><Figure><ImageData src="images/math_ip_altera_megafunctions_img_28.jpg"/>data[] clk_en clock inst ALTFP_INV_SQRT result[] zero nan division_by_zero aclr </Figure><P id="LinkTarget_7238">Features </P><P>The ALTFP_INV_SQRT megafunction offers the following features: </P><L><LI><LI_Label>■ 	</LI_Label><LI_Title>Inverse square root value of a given input. </LI_Title></LI><LI><LI_Label>■ 	</LI_Label><LI_Title>Optional exception handling output ports such as zero, division_by_zero, and nan. </LI_Title></LI></L></Sect><P id="LinkTarget_7239">Output Latency </P><Sect><P>The output latency options for the ALTFP_INV_SQRT megafunction differs depending on the precision selected, the width of the mantissa, or both. </P><P><Link>Table 8–1 </Link>lists the output latency options required for each precision format. </P><P>Table 8–1. Latency Options for Each Precision Format </P></Sect><Table><TR><TH>Precision </TH><TH>Mantissa Width </TH><TH>Latency (in clock cycles) </TH></TR><TR><TH>Single </TH><TD>23 </TD><TD>26 </TD></TR><TR><TH>Double </TH><TD>52 </TD><TD>36 </TD></TR><TR><TH>Single-Extended </TH><TD>31– 39 </TD><TD>26 </TD></TR><TR><TD>40 – 52 </TD><TD>36 </TD></TR></Table><Sect><P id="LinkTarget_7240">Truth Table </P><P><Link>Table 8–2 </Link>lists the truth table for the inverse square root operation. </P><P>Table 8–2. Truth Table for Inverse Square Root Operations </P></Sect><Table><TR><TH>DATA[] </TH><TH>SIGN BIT </TH><TH>RESULT[] </TH><TH>Zero </TH><TH>Division_by_zero </TH><TH>NaN </TH></TR><TR><TH>Normal </TH><TD>0 </TD><TD>Normal </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD></TR><TR><TH>Normal </TH><TD>1 </TD><TD>NaN </TD><TD>0 </TD><TD>0 </TD><TD>1 </TD></TR><TR><TH><Link>Denormal (1)</Link></TH><TD> 0/1 </TD><TD>Infinity </TD><TD>0 </TD><TD>1 </TD><TD>0 </TD></TR><TR><TH>Zero </TH><TD>0/1 </TD><TD>Infinity </TD><TD>0 </TD><TD>1 </TD><TD>0 </TD></TR><TR><TH>Infinity </TH><TD>0/1 </TD><TD>Zero </TD><TD>1 </TD><TD>0 </TD><TD>0 </TD></TR><TR><TH>NaN </TH><TD>X </TD><TD>NaN </TD><TD>0 </TD><TD>0 </TD><TD>1 </TD></TR></Table><Sect><P>Note to <Link>Table 8–2</Link>: </P><P>(1) Any denormal input is treated as a zero before going through the inverse process. </P></Sect><P id="LinkTarget_7241">Resource Utilization and Performance </P><Sect><P><Link>Table 8–3 </Link>lists the resource utilization and performance information for the ALTFP_INV_SQRT megafunction. The information was derived using the Quartus II software version 10.0. </P></Sect><P>Table 8–3. ALTFP_INV_SQRT Resource Utilization and Performance for the Stratix Series of Devices </P><Table><TR><TH>Device Family </TH><TH>Precision </TH><TH>Output Latency </TH><TH/><TH>Logic usage </TH><TH/><TH>fMAX (MHz)</TH></TR><TR><TD>Adaptive Look-up Tables (ALUTs) </TD><TD>Dedicated Logic Registers (DLRs) </TD><TD>Adaptive Logic Modules (ALMs) </TD><TD>18-Bit DSP </TD></TR><TR><TH>Stratix III </TH><TD>Single </TD><TD>26 </TD><TD>510 </TD><TD>674 </TD><TD>439 </TD><TD>22 </TD><TD>428 </TD></TR><TR><TD>Double </TD><TD>36 </TD><TD>1,345 </TD><TD>1,866 </TD><TD>1,215 </TD><TD>78 </TD><TD>193 </TD></TR><TR><TH>Stratix IV </TH><TD>Single </TD><TD>26 </TD><TD>502 </TD><TD>658 </TD><TD>430 </TD><TD>22 </TD><TD>413 </TD></TR><TR><TD>Double </TD><TD>36 </TD><TD>1,324 </TD><TD>1,855 </TD><TD>1,209 </TD><TD>78 </TD><TD>209 </TD></TR></Table><P id="LinkTarget_7242">Design Example: Inverse Square Root of Single-Precision Format Numbers </P><Sect><P>This design example uses the ALTFP_INV_SQRT megafunction to compute the inverse square root of single-precision format numbers. This example uses the MegaWizard Plug-In Manager in the Quartus II software. </P></Sect><P id="LinkTarget_7243">Design Files </P><Sect><P>The following files are related to the ALTFP_INV_SQRT megafunction: </P><L><LI><LI_Label>■ </LI_Label><LI_Title>altfp_inv_sqrt_DesignExample.zip (Quartus II design files) </LI_Title></LI><LI><LI_Label>■ </LI_Label><LI_Title>altfp_inv_sqrt_ex_msim.zip (ModelSim-Altera files) </LI_Title></LI></L></Sect><P id="LinkTarget_7244">Understanding the Simulation Results </P><Sect><P><Link>Figure 8–2</Link> and <Link>Figure 8–3</Link> show the expected simulation results in the ModelSim-Altera software. </P></Sect><P>1 	The simulation waveform in this design example is not shown in its entirety. Run the design example files in the ModelSim-Altera software to see the complete simulation waveforms. </P><P>Figure 8–2. ModelSim Simulation Waveform (Input Data) </P><Figure><ImageData src="images/math_ip_altera_megafunctions_img_29.jpg"/></Figure><P>Figure 8–3. ModelSim Simulation Waveform (Output Data) </P><Figure><ImageData src="images/math_ip_altera_megafunctions_img_30.jpg"/></Figure><Sect><P>127.5 ns 137.5 ns 147.5 ns 	177.5 ns </P></Sect><Sect><P>This design example implements a floating-point inverse square root for single-precision format numbers. The optional input ports (clk_en and aclr) and all three exception handling output ports (division_by_zero, nan, and zero) are enabled. </P><P>The latency is fixed at 26 clock cycles. Therefore, every inverse square root operation outputs the results 26 clock cycles later. </P><P><Link>Table 8–4</Link> lists the inputs and corresponding outputs obtained from the simulation in <Link>Figure 8–2 on page 8–3</Link> and <Link>Figure 8–3 on page 8–3</Link>. </P><P>Table 8–4. Summary of Input Values and Corresponding Outputs </P></Sect><Table><TR><TD>Time </TD><TD>Event </TD></TR><TR><TD>0 ns, start-up </TD><TD>data[] value: 05AE 470Bh Output value: An undefined value is seen on the result[] port, which can be ignored. All values seen on the output port before the 26th clock cycle are merely due to the behavior of the system during start-up and should be disregarded. </TD></TR><TR><TD>127.5 ns </TD><TD>Output value: 5C5B 64CEh The inverse square root of a normal number results in a normal value. </TD></TR><TR><TD>10 ns </TD><TD>data[] value: E8A7 E93Dh This is a negative normal value. </TD></TR><TR><TD>137.5 ns </TD><TD>Output value: FFC0 0000h Exception handling ports: nan asserts The inverse square root of a negative value produces a NaN. </TD></TR><TR><TD>20 ns </TD><TD>data[] value: 0000 0004h The is a denormal value. </TD></TR><TR><TD>147.5 ns </TD><TD>Output value: 7F80 0000h Denormal numbers are forced-zero values, therefore the inverse square root of zero results in infinity. Exception handling ports: nan deasserts, division_by_zero asserts </TD></TR><TR><TD>50 ns </TD><TD>data[] value: 7F80 0000h This is an infinity value. </TD></TR><TR><TD>177.5 ns </TD><TD>Output value: 0000 0000h The inverse square root of an infinity value produces a zero. Exception handling ports: zero asserts </TD></TR></Table><Sect/><P id="LinkTarget_7245">Specifications </P><Sect><P>This section describes the component declarations, ports, and parameters of the ALTFP_INV_SQRT megafunction. The ports and parameters are available to customize the ALTFP_INV_SQRT megafunction according to your application. </P></Sect><P id="LinkTarget_7246">VHDL Component Declaration </P><Sect><P>The following VHDL component declaration is located in the VHDL Design File (.vhd) altera_mf_components.vhd in the &lt;Quartus II installation directory&gt;\libraries\vhdl\altera_mf directory. </P></Sect><P>component altfp_inv_sqrt 
</P><P>generic (
   intended_device_family : string := &quot;unused&quot;;
   pipeline : natural := 26;
   rounding : string := &quot;TO_NEAREST&quot;;
   width_exp : natural := 8;
   width_man : natural := 23;
   lpm_hint : string := &quot;UNUSED&quot;;
   lpm_type : string := &quot;altfp_inv_sqrt" 
</P><Sect><P>); 
</P></Sect><P>port(
   aclr : in std_logic := '0';
   clk_en : in std_logic := '1';
   clock : in std_logic;
   data : in std_logic_vector(width_exp+width_man+1-1 downto 0);
   division_by_zero : out std_logic;
   nan : out std_logic;
   result : out std_logic_vector(width_exp+width_man+1-1 downto 0);
   zero : out std_logic 
</P><Sect><P>); 
end component; 
</P></Sect><P id="LinkTarget_7247">VHDL LIBRARY-USE Declaration </P><Sect><P>The VHDL LIBRARY-USE declaration is not required if you use the VHDL Component Declaration. </P><P>LIBRARY altera_mf; 
</P><P>USE altera_mf_altera_mf_components.all; 
</P></Sect><Sect/><P id="LinkTarget_7248">Ports and Parameters </P><Sect><P><Link>Table 8–5</Link> lists the input ports of the ALTFP_INV_SQRT megafunction. </P></Sect><P>Table 8–5. ALTFP_INV_SQRT Megafunction Input Ports </P><Table><TR><TH>Port Name </TH><TH>Required </TH><TH>Description </TH></TR><TR><TD>aclr </TD><TD>No </TD><TD>Asynchronous clear. When the aclr port is asserted high, the function is asynchronously cleared. </TD></TR><TR><TD>clk_en </TD><TD>No </TD><TD>Clock enable. When the clk_en port is asserted high, an inversion value operation takes place. When signal is asserted low, no operation occurs and the outputs remain unchanged. </TD></TR><TR><TD>clock </TD><TD>Yes </TD><TD>Clock input to the megafunction. </TD></TR><TR><TD>data[] </TD><TD>Yes </TD><TD>Floating-point input data. The MSB is the sign bit, the next MSBs are the exponent, and the LSBs are the mantissa. This input port size is the total width of the sign bit, exponent bits, and mantissa bits. </TD></TR></Table><Sect><P><Link>Table 8–6</Link> lists the output ports of the ALTFP_INV_SQRT megafunction. </P></Sect><P>Table 8–6. ALTFP_INV_SQRT Megafunction Output Ports </P><Table><TR><TH>Port Name </TH><TH>Required </TH><TH>Description </TH></TR><TR><TD>result[] </TD><TD>Yes </TD><TD>The floating-point inverse result of the value at the data[]input port. The MSB is the sign bit, the next MSBs are the exponent, and the LSBs are the mantissa. The size of this port is the total width of the sign bit, exponent bits, and mantissa bits. </TD></TR><TR><TD>zero </TD><TD>No </TD><TD>Zero exception output. Asserted when the value at the result[] port is a zero. </TD></TR><TR><TD>division_by_zero </TD><TD>No </TD><TD>Division-by-zero exception output. Asserted when the denominator input is a zero. </TD></TR><TR><TD>nan </TD><TD>No </TD><TD>NaN exception output. Asserted when an invalid inversion of square root occurs, such as the square root of a negative number. In this case, a NaN value is output to the result[] output port. Any operation involving a NaN will also produce a NaN. </TD></TR></Table><Sect><P><Link>Table 8–7</Link> lists the parameters of the ALTFP_INV_SQRT megafunction. </P></Sect><P>Table 8–7. ALTFP_INV_SQRT Megafunction Parameters (Part 1 of 2) </P><Table><TR><TH>Parameter Name </TH><TH>Type </TH><TH>Required </TH><TH>Description </TH></TR><TR><TD>WIDTH_EXP </TD><TD>Integer </TD><TD>Yes </TD><TD>Specifies the precision of the exponent. If this parameter is not specified, the default is 8. The bias of the exponent is always set to 2(WIDTH_EXP -1) -1, that is, 127 for the single-precision format and 1023 for the double-precision format. The value of the WIDTH_EXP parameter must be 8for the single-precision format, 11 for the double-precision format, and a minimum of 11 for the single-extended precision format. The value of the WIDTH_EXP parameter must be less than the value of the WIDTH_MAN parameter, and the sum of the WIDTH_EXP and WIDTH_MAN parameters must be less than 64. </TD></TR><TR><TD>WIDTH_MAN </TD><TD>Integer </TD><TD>Yes </TD><TD>Specifies the value of the mantissa. If this parameter is not specified, the default is 23. When the WIDTH_EXP parameter is 8 and the floating-point format is single-precision, the WIDTH_MAN parameter value must be 23. Otherwise, the value of the WIDTH_MAN parameter must be a minimum of 31. The value of the WIDTH_MAN parameter must be greater than the value of the WIDTH_EXP parameter. The sum of the WIDTH_EXP and WIDTH_MAN parameters must be less than 64. </TD></TR></Table><Sect/><P>Table 8–7. ALTFP_INV_SQRT Megafunction Parameters (Part 2 of 2) </P><Table><TR><TH>Parameter Name </TH><TH>Type </TH><TH>Required </TH><TH>Description </TH></TR><TR><TD>PIPELINE </TD><TD>Integer </TD><TD>Yes </TD><TD>Specifies the amount of latency, expressed in clock cycles, used in the ALTFP_INV_SQRT megafunction. Create the ALTFP_INV_SQRT megafunction with the MegaWizard Plug-In Manager to calculate the value for this parameter. </TD></TR><TR><TD>ROUNDING </TD><TD>String </TD><TD>No </TD><TD>Specifies the rounding mode. The default value is TO_NEAREST. Other rounding modes are not supported. </TD></TR></Table><Figure><ImageData src="images/math_ip_altera_megafunctions_img_31.jpg"/></Figure></Sect><Sect><Sect><H2 id="LinkTarget_7249">9. ALTFP_LOG 
</H2><P><Link>Figure 9–1</Link> shows the ports for the ALTFP_LOG megafunction. </P><P>Figure 9–1. ALTFP_LOG Ports </P><Figure><ImageData src="images/math_ip_altera_megafunctions_img_32.jpg"/>data[] clk_en clock inst ALTFP_LOG result[] zero nan aclr </Figure><P id="LinkTarget_7250">Features </P><P>The ALTFP_LOG megafunction offers the following features: </P><L><LI><LI_Label>■ </LI_Label><LI_Title>Natural logarithm functions. </LI_Title></LI><LI><LI_Label>■ </LI_Label><LI_Title>Optional exception handling output ports such as zeroand nan. </LI_Title></LI></L></Sect><P id="LinkTarget_7251">Output Latency </P><Sect><P>The output latency options for the ALTFP_LOG megafunction differs depending on the precision selected, the width of the mantissa, or both. </P><P><Link>Table 9–1 </Link>lists the output latency options required for each precision format. </P><P>Table 9–1. Latency Options for Each Precision Format </P></Sect><Table><TR><TH>Precision </TH><TH>Mantissa Width </TH><TH>Latency (in clock cycles) </TH></TR><TR><TH>Single </TH><TD>23 </TD><TD>21 </TD></TR><TR><TH>Double </TH><TD>52 </TD><TD>34 </TD></TR><TR><TH/><TD>31–36 </TD><TD>25 </TD></TR><TR><TH>Single Extended </TH><TD>37–42 </TD><TD>28 </TD></TR><TR><TD>43–48 </TD><TD>31 </TD></TR><TR><TD>49–52 </TD><TD>34 </TD></TR></Table><Sect><P id="LinkTarget_7252">Truth Table </P><P><Link>Table 9–2 </Link>lists the truth table for the natural logarithm operation. </P><P>Table 9–2. Truth Table for Natural Logarithm Operations </P></Sect><Table><TR><TH>DATA[] </TH><TH>SIGN BIT </TH><TH>RESULT[] </TH><TH>Zero </TH><TH>NaN </TH></TR><TR><TH>Normal </TH><TD>0 </TD><TD>Normal </TD><TD>0 </TD><TD>0 </TD></TR><TR><TH>Normal </TH><TD>1 </TD><TD><Link>NaN (1) </Link></TD><TD>0 </TD><TD>1 </TD></TR><TR><TH><Link>1 (2)</Link></TH><TD> 0 </TD><TD>Zero </TD><TD>1 </TD><TD>0 </TD></TR><TR><TH><Link>Denormal (3) </Link></TH><TD>0 </TD><TD>Negative Infinity </TD><TD>0 </TD><TD>0 </TD></TR><TR><TH><Link>Zero (4) </Link></TH><TD>0/1 </TD><TD>Negative Infinity </TD><TD>0 </TD><TD>0 </TD></TR><TR><TH>Infinity </TH><TD>0 </TD><TD>Positive Infinity </TD><TD>1 </TD><TD>0 </TD></TR><TR><TH>NaN </TH><TD>X </TD><TD>NaN </TD><TD>0 </TD><TD>1 </TD></TR></Table><Sect><P>Notes to <Link>Table 9–2</Link>: </P><L><LI><LI_Label>(1) 	</LI_Label><LI_Title>The natural logarithm of a negative value is invalid. Therefore, the output produced is a NaN. </LI_Title></LI><LI><LI_Label>(2) 	</LI_Label><LI_Title>The “1” in this case is equivalent to In 1. </LI_Title></LI><LI><LI_Label>(3) 	</LI_Label><LI_Title>The value of positive denormalized numbers is a value that approximates zero, and the output produced is a negative infinity number. </LI_Title></LI><LI><LI_Label>(4) 	</LI_Label><LI_Title>The zero in this case represents zero special case of the IEEE standard. It is not equivalent to In 0, but instead approximates to it. </LI_Title></LI></L></Sect><P id="LinkTarget_7253">Resource Utilization and Performance </P><Sect><P><Link>Table 9–3 </Link>lists the resource utilization and performance information for the ALTFP_LOG megafunction. The information was derived using the Quartus II software version 10.0. </P></Sect><P>Table 9–3. ALTFP_LOG Resource Utilization and Performance for the Stratix Series of Devices </P><Table><TR><TH>Device Family </TH><TH>Precision </TH><TH>Output Latency </TH><TH/><TH>Logic usage </TH><TH/><TH>fMAX (MHz)</TH></TR><TR><TD>Adaptive Look-Up Tables (ALUTs) </TD><TD>Dedicated Logic Registers (DLRs) </TD><TD>Adaptive Logic Modules (ALMs) </TD><TD>18-Bit DSP </TD></TR><TR><TH>Stratix III </TH><TD>Single </TD><TD>21 </TD><TD>1,983 </TD><TD>1,904 </TD><TD>1,387 </TD><TD>8 </TD><TD>338 </TD></TR><TR><TD>Double </TD><TD>34 </TD><TD>5,475 </TD><TD>6,049 </TD><TD>4,171 </TD><TD>64 </TD><TD>160 </TD></TR><TR><TH>Stratix IV </TH><TD>Single </TD><TD>21 </TD><TD>1,950 </TD><TD>1,864 </TD><TD>1,378 </TD><TD>8 </TD><TD>385 </TD></TR><TR><TD>Double </TD><TD>34 </TD><TD>5,451 </TD><TD>6,031 </TD><TD>4,151 </TD><TD>64 </TD><TD>211 </TD></TR></Table><P id="LinkTarget_7254">Design Example: Natural Logarithm of Single-Precision Format Numbers </P><Sect><P>This design example uses the ALTFP_LOG megafunction to compute the natural logarithm of single-precision format numbers. This example uses the MegaWizard Plug-In Manager in the Quartus II software. </P></Sect><P id="LinkTarget_7255">Design Files </P><Sect><P>The following file is related to the ALTFP_LOG megafunction: </P><L><LI><LI_Label>■ </LI_Label><LI_Title>altfp_log_DesignExample.zip (Quartus II design files) </LI_Title></LI><LI><LI_Label>■ </LI_Label><LI_Title>altfp_log_ex_msim.zip (ModelSim-Altera files) </LI_Title></LI></L></Sect><P id="LinkTarget_7256">Understanding the Simulation Results </P><Sect><P><Link>Figure 9–2</Link> and <Link>Figure 9–3</Link> show the expected simulation results in the ModelSim-Altera software. </P></Sect><P>1 	The simulation waveform in this design example is not shown in its entirety. Run the design example files in the ModelSim-Altera software to see the complete simulation waveforms. </P><P>Figure 9–2. ModelSim Simulation Waveform (Input Data) </P><Figure><ImageData src="images/math_ip_altera_megafunctions_img_33.jpg"/></Figure><P>Figure 9–3. ModelSim Simulation Waveform (Output Data) </P><Sect><P>This design example includes the input of special cases to show the exception handling of the megafunction, such as the smallest valid input and the input value of “1”. </P><P>In this example, the output delay is set to 21 clock cycles. Therefore, the result is only shown at the output port after the 21st clock cycle at 102.5 ns. </P><P><Link>Table 9–4</Link> lists the inputs and corresponding outputs obtained from the simulation in <Link>Figure 9–2 on page 9–3</Link> and <Link>Figure 9–3 on page 9–3</Link>. </P><P>Table 9–4. Summary of Input Values and Corresponding Outputs </P></Sect><Table><TR><TD>Time </TD><TD>Event </TD></TR><TR><TD>0 ns, start-up </TD><TD>data[] value: 0000 0000h Output value: An undefined value is seen on the result[] port, which is ignored. All values seen on the output port before the 21st clock cycle are merely due to the behavior of the system during start-up and should be disregarded. </TD></TR><TR><TD>102.5 ns </TD><TD>Output value: FF80 0000h The natural logarithm of zero is negative infinity. </TD></TR><TR><TD>5ns </TD><TD>data[] value: 8000 0000h This is a negative number. </TD></TR><TR><TD>107.5 ns </TD><TD>Output value: FFC0 0000h Exception handling ports: nan asserts The natural logarithm of a negative value is invalid. Therefore, the output produced is a NaN. </TD></TR><TR><TD>30 ns </TD><TD>data[] value: 0040 0000h The is a denormal value. </TD></TR><TR><TD>132.5 ns </TD><TD>Output value: FF80 0000h As denormal numbers are not supported, the input is forced to zero before going through the logarithm function. The natural logarithm of zero is negative infinity. </TD></TR><TR><TD>45 ns </TD><TD>data[] value: 0080 0000h This is the smallest valid input. All the input bits are 0 except the LSB of the exponent field. </TD></TR><TR><TD>147.5 ns </TD><TD>Output value: C2AE AC50h </TD></TR><TR><TD>60 ns </TD><TD>data[]value: 3F80 0000h The input value 3F80 0000h is equivalent to the actual value, 1.0 × 20 = 1. </TD></TR><TR><TD>152.5 ns </TD><TD>Output value: 0000 0000h Exception handling ports: zero asserts Since In 1 results in zero, it produces an output of zero. </TD></TR></Table><Sect/><P id="LinkTarget_7257">Specifications </P><Sect><P>This section describes the component declarations, ports, and parameters of the ALTFP_LOG megafunction. The ports and parameters are available to customize the ALTFP_LOG megafunction according to your application. </P></Sect><P id="LinkTarget_7258">VHDL Component Declaration </P><Sect><P>The following VHDL component declaration is located in the VHDL Design File (.vhd) altera_mf_components.vhd in the &lt;Quartus II installation directory&gt;\libraries\vhdl\altera_mf directory. </P></Sect><P>component altfp_log 
</P><P>generic (
   intended_device_family : string := &quot;unused&quot;;
   pipeline : natural := 21;
   width_exp : natural := 8;
   width_man : natural := 23;
   lpm_hint : string := &quot;UNUSED&quot;;
   lpm_type : string := &quot;altfp_log" 
</P><Sect><P>); 
</P></Sect><P>port(
   aclr : in std_logic := '0';
   clk_en : in std_logic := '1';
   clock : in std_logic;
   data : in std_logic_vector(width_exp+width_man+1-1 downto 0);
   nan : out std_logic;
   result : out std_logic_vector(width_exp+width_man+1-1 downto 0);
   zero : out std_logic 
</P><Sect><P>); 
end component; 
</P></Sect><P id="LinkTarget_7259">VHDL LIBRARY-USE Declaration </P><Sect><P>The VHDL LIBRARY-USE declaration is not required if you use the VHDL Component Declaration. </P><P>LIBRARY altera_mf; 
</P><P>USE altera_mf_altera_mf_components.all; 
</P></Sect><Sect/><P id="LinkTarget_7260">Ports and Parameters </P><Sect><P><Link>Table 9–5</Link> lists the input ports of the ALTFP_LOG megafunction. </P></Sect><P>Table 9–5. ALTFP_LOG Megafunction Input Ports </P><Table><TR><TH>Port Name </TH><TH>Required </TH><TH>Description </TH></TR><TR><TD>aclr </TD><TD>No </TD><TD>Asynchronous clear. When the aclr port is asserted high, the function is asynchronously cleared. </TD></TR><TR><TD>clk_en </TD><TD>No </TD><TD>Clock enable. When the clk_en port is asserted high, a natural logarithm operation takes place. When signal is asserted low, no operation occurs and the outputs remain unchanged. Deasserting clk_en halts operation until it is asserted again. Assert the clk_en signal for the number of clock cycles equivalent to the required output latency (PIPELINE parameter value) for the results to be shown at the output. </TD></TR><TR><TD>clock </TD><TD>Yes </TD><TD>Clock input to the megafunction. </TD></TR><TR><TD>data[] </TD><TD>Yes </TD><TD>Floating-point input data. The MSB is the sign bit, the next MSBs are the exponent, and the LSBs are the mantissa. This input port size is the total width of the sign bit, exponent bits, and mantissa bits. For single precision, the width is fixed to 32 bits. For double precision, the width is fixed to 64 bits. For single extended precision, you can choose a width in the range from 43 to 64 bits. </TD></TR></Table><Sect><P><Link>Table 9–6</Link> lists the output ports of the ALTFP_LOG megafunction. </P></Sect><P>Table 9–6. ALTFP_LOG Megafunction Output Ports </P><Table><TR><TH>Port Name </TH><TH>Required </TH><TH>Description </TH></TR><TR><TD>result[] </TD><TD>Yes </TD><TD>The natural logarithm of the value on input data. The natural logarithm of the data[]input port, shown in floating-point format. The widths of the result[] output port and data[] input port are the same. </TD></TR><TR><TD>zero </TD><TD>No </TD><TD>Zero exception output. Asserted when the exponent and mantissa of the output port are zero. This occurs when the actual input value is 1 because ln 1= 0. </TD></TR><TR><TD>nan </TD><TD>No </TD><TD>NaN exception output. Asserted when the exponent and mantissa of the output port are all 1’s and non-zero, respectively. This occurs when the input is a negative number or NaN. </TD></TR></Table><Sect><P><Link>Table 9–7</Link> describes the parameters of the ALTFP_LOG megafunction. </P></Sect><P>Table 9–7. ALTFP_LOG Megafunction Parameters </P><Table><TR><TH>Parameter Name </TH><TH>Type </TH><TH>Required </TH><TH>Description </TH></TR><TR><TD>WIDTH_EXP </TD><TD>Integer </TD><TD>Yes </TD><TD>Specifies the precision of the exponent. If this parameter is not specified, the default is 8. The bias of the exponent is always set to 2(WIDTH_EXP -1) -1, that is, 127 for the single-precision format and 1023 for the double-precision format. The value of the WIDTH_EXP parameter must be 8for the single-precision format, 11 for the double-precision format, and a minimum of 11 for the single-extended precision format. The value of the WIDTH_EXP parameter must be less than the value of the WIDTH_MAN parameter, and the sum of the WIDTH_EXP and WIDTH_MAN parameters must be less than 64. </TD></TR><TR><TD>WIDTH_MAN </TD><TD>Integer </TD><TD>Yes </TD><TD>Specifies the precision of the mantissa. If this parameter is not specified, the default is 23. The value of WIDTH_MAN must be 23 for the single-precision format, and 52 for the double-precision format. For the single-extended precision format, the valid value ranges from 31 to 52. The value of WIDTH_MAN must be greater than the value of WIDTH_EXP, and the sum of WIDTH_EXP and WIDTH_MAN must be less than 64. </TD></TR><TR><TD>PIPELINE </TD><TD>Integer </TD><TD>Yes </TD><TD>Specifies the amount of latency in clock cycles used in the ALTFP_LOG megafunction. Create the ALTFP_LOG megafunction with the MegaWizard Plug-In Manager to calculate the value for this parameter. </TD></TR></Table><Figure><ImageData src="images/math_ip_altera_megafunctions_img_34.jpg"/></Figure><Sect><P id="LinkTarget_7261">10. ALTFP_ATAN 
</P><P><Link>Figure 10–1</Link> shows the ports for the ALTFP_ATAN megafunction. </P><P>Figure 10–1. ALTFP_ATAN Ports </P><Figure><ImageData src="images/math_ip_altera_megafunctions_img_35.jpg"/>data[31..0] aclr ALTFP_ATAN result[31..0] clk_en clock </Figure><P id="LinkTarget_7262">Features </P><P>The ALTFP_ATAN megafunction offers the following features: </P><L><LI><LI_Label>■ 	</LI_Label><LI_Title>Arctangent value of a given angle, in unit radian. </LI_Title></LI><LI><LI_Label>■ 	</LI_Label><LI_Title>Support for single-precision floating point format. </LI_Title></LI><LI><LI_Label>■ 	</LI_Label><LI_Title>Support for optional input ports such as asynchronous clear (aclr) and clock enable (clk_en) ports. </LI_Title></LI></L></Sect><P id="LinkTarget_7263">Output Latency </P><Sect><P>The output latency option for the ALTFP_ATAN megafunction have a fixed latency level for single-precision format. </P><P><Link>Table 10–1</Link> lists the output latency option required for single precision format. </P></Sect><P>Table 10–1. Latency Option </P><Table><TR><TH>Trigonometric Function </TH><TH>Precision </TH><TH>Mantissa Width </TH><TH>Latency (in clock cycles) </TH></TR><TR><TD>Arctangent </TD><TD>Single </TD><TD>23 </TD><TD>36 </TD></TR></Table><Sect/><P id="LinkTarget_7264">Resource Utilization and Performance </P><Sect><P><Link>Table 10–2</Link> lists the resource utilization and performance information for the ALTFP_ATAN megafunction. The information was derived using the Quartus II software version 11.0. </P></Sect><P>Table 10–2. ALTFP_ATAN Resource Utilization and Performance </P><Table><TR><TH>Device Family </TH><TH>Function </TH><TH>Precision </TH><TH>Output Latency </TH><TH/><TH>Logic usage </TH><TH/><TH>fMAX (MHz)</TH></TR><TR><TD>Adaptive Look-Up Tables (ALUTs) </TD><TD>Dedicated Logic Registers (DLRs) </TD><TD>Adaptive Logic Modules (ALMs) </TD><TD>18-Bit DSP </TD></TR><TR><TH>Stratix V </TH><TD>ArcTangent </TD><TD>Single </TD><TD>36 </TD><TD>2,454 </TD><TD>1,010 </TD><TD>1,303 </TD><TD>27 </TD><TD>255.49 </TD></TR></Table><P id="LinkTarget_7265">Specifications </P><Sect><P>This section describes the component declarations, ports, and parameters of the ALTFP_ATAN megafunction. The ports and parameters are available to customize the ALTFP_ATAN megafunction according to your application. </P></Sect><P id="LinkTarget_7266">VHDL Component Declaration </P><Sect><P>The following VHDL component declaration is located in the VHDL Design File (.vhd) altera_mf_components.vhd in the &lt;Quartus II installation directory&gt;\libraries\vhdl\altera_mf directory. </P></Sect><P>component altfp_atan 
</P><P>generic ( 
intended_device_family:string := &quot;unused&quot;; 
pipeline:natural := 36; 
rounding:string := &quot;TO_NEAREST&quot;; 
width_exp:natural := 8; 
width_man:natural := 23; 
lpm_hint:string := &quot;UNUSED&quot;; 
lpm_type:string := &quot;altfp_atan" 
</P><Sect><P>); 
</P></Sect><P>port( 
aclr: in std_logic := '0'; 
clk_en:in std_logic := '0'; 
clock: in std_logic := '0'; 
data: in std_logic_vector(width_exp+width_man+1-1 downto 0) := (others =&gt; '0'); 
result:out std_logic_vector(width_exp+width_man+1-1 downto 0) 
</P><Sect><P>); 
end component; 
</P></Sect><P id="LinkTarget_7267">VHDL LIBRARY-USE Declaration </P><Sect><P>The VHDL LIBRARY-USE declaration is not required if you use the VHDL Component Declaration. </P><P>LIBRARY altera_mf; 
</P><P>USE altera_mf_altera_mf_components.all; 
</P></Sect><Sect/><P id="LinkTarget_7268">Ports and Parameters </P><Sect><P><Link>Table 10–3</Link> lists the input ports of the ALTFP_ATAN megafunction. </P></Sect><P>Table 10–3. ALTFP_ATAN Megafunction Input Ports </P><Table><TR><TH>Port Name </TH><TH>Required </TH><TH>Description </TH></TR><TR><TD>aclr </TD><TD>No </TD><TD>Asynchronous clear. When the aclr port is asserted high, the function is asynchronously cleared. </TD></TR><TR><TD>clk_en </TD><TD>No </TD><TD>Clock enable. When the clk_en port is asserted high, division takes place. When the signal is deasserted, no operation occurs and the outputs remain unchanged. </TD></TR><TR><TD>clock </TD><TD>Yes </TD><TD>Clock input to the megafunction. </TD></TR><TR><TD>data[] </TD><TD>Yes </TD><TD>Floating-point input data. The MSB is the sign bit, the next MSBs are the exponent, and the LSBs are the mantissa. This input port size is the total width of the sign bit, exponent bits, and mantissa bits. </TD></TR></Table><Sect><P><Link>Table 10–4</Link> lists the output ports of the ALTFP_ATAN megafunction. </P></Sect><P>Table 10–4. ALTFP_ATAN Megafunction Output Ports </P><Table><TR><TH>Port Name </TH><TH>Required </TH><TH>Description </TH></TR><TR><TD>result[] </TD><TD>Yes </TD><TD>The result of the trigonometric function in floating-point format. The widths of the result[] output port and data[] input port are the same. </TD></TR></Table><Sect><P><Link>Table 10–5</Link> lists the parameters of the ALTFP_ATAN megafunction. </P></Sect><P>Table 10–5. ALTFP_ATAN Megafunction Parameters </P><Table><TR><TH>Parameter Name </TH><TH>Type </TH><TH>Required </TH><TH>Description </TH></TR><TR><TD>WIDTH_EXP </TD><TD>Integer </TD><TD>Yes </TD><TD>Specifies the precision of the exponent. The bias of the exponent is always set to 2(WIDTH_EXP-1) -1 (that is, 127 for single-precision format). The value of WIDTH_EXP must be 8for single-precision format. The default value for WIDTH_EXP is 8. </TD></TR><TR><TD>WIDTH_MAN </TD><TD>Integer </TD><TD>Yes </TD><TD>Specifies the precision of the mantissa. The value of WIDTH_MAN must be 23 when WIDTH_EXP is 8. The default value for WIDTH_MAN is 23. </TD></TR><TR><TD>PIPELINE </TD><TD>Integer </TD><TD>Yes </TD><TD><Link>The number of pipeline is fixed for the mantissa width and some internal parameter. For the correct settings, refer to Table 10–1 on page 10–1. </Link></TD></TR><TR><TD>ROUNDING </TD><TD>Integer </TD><TD>No </TD><TD>Specifies the rounding mode. The default value is TO_NEAREST. Other rounding modes are not supported. </TD></TR></Table><Figure><ImageData src="images/math_ip_altera_megafunctions_img_36.jpg"/></Figure><Sect><P id="LinkTarget_7269">11. ALTFP_SINCOS 
</P><P><Link>Figure 11–1</Link> shows the ports for the ALTFP_SINCOS megafunction. </P><P>Figure 11–1. ALTFP_SINCOS Ports </P><Figure><ImageData src="images/math_ip_altera_megafunctions_img_37.jpg"/>data[31..0] aclr ALTFP_SINCOS result[31..0] clk_en clock </Figure><P id="LinkTarget_7270">Features </P><P>The ALTFP_SINCOS megafunction offers the following features: </P><L><LI><LI_Label>■ 	</LI_Label><LI_Title>Implements sine and cosine calculations. </LI_Title></LI><LI><LI_Label>■ 	</LI_Label><LI_Title>Support for single-precision floating point format. </LI_Title></LI><LI><LI_Label>■ 	</LI_Label><LI_Title>Support for optional input ports such as asynchronous clear (aclr) and clock enable (clk_en) ports. </LI_Title></LI></L></Sect><P id="LinkTarget_7271">Output Latency </P><Sect><P>The output latency options for the ALTFP_SINCOS megafunction have a fixed latency level for sine and cosine functions. </P><P><Link>Table 11–1</Link> lists the output latency options required for each precision format. </P></Sect><P>Table 11–1. Latency Options for Each Precision Format </P><Table><TR><TH>Trigonometric Function </TH><TH>Precision </TH><TH>Mantissa Width </TH><TH>Latency (in clock cycles) </TH></TR><TR><TD>Sine </TD><TD>Single </TD><TD>23 </TD><TD>36 </TD></TR><TR><TD>Cosine </TD><TD>Single</TD><TD> 23 </TD><TD>35 </TD></TR></Table><Sect/><P id="LinkTarget_7272">Resource Utilization and Performance </P><Sect><P><Link>Table 11–2</Link> lists the resource utilization and performance information for the ALTFP_SINCOS megafunction. The information was derived using the Quartus II software version 10.1. </P></Sect><P>Table 11–2. ALTFP_SINCOS Resource Utilization and Performance </P><Table><TR><TH>Device Family </TH><TH>Function </TH><TH>Precision </TH><TH>Output Latency </TH><TH/><TH>Logic usage </TH><TH/><TH/><TH>fMAX (MHz)</TH></TR><TR><TD> Adaptive Look-Up Tables (ALUTs) </TD><TD>Dedicated Logic Registers (DLRs) </TD><TD/><TD>Adaptive Logic Modules (ALMs) </TD><TD>18-Bit DSP </TD></TR><TR><TH>Stratix IV </TH><TD>Sine </TD><TD>Single </TD><TD>36 </TD><TD>2,859 </TD><TD>2,190 </TD><TD/><TD>1,830 </TD><TD>16 </TD><TD>292.96 </TD></TR><TR><TD>Cosine </TD><TD>Single </TD><TD>35 </TD><TD>2,753 </TD><TD>2,041 </TD><TD/><TD>1,745 </TD><TD>16 </TD><TD>258.26 </TD></TR></Table><P id="LinkTarget_7273">Specifications </P><Sect><P>This section describes the component declarations, ports, and parameters of the ALTFP_SINCOS megafunction. The ports and parameters are available to customize the ALTFP_SINCOS megafunction according to your application. </P></Sect><P id="LinkTarget_7274">VHDL Component Declaration </P><Sect><P>The following VHDL component declaration is located in the VHDL Design File (.vhd) altera_mf_components.vhd in the &lt;Quartus II installation directory&gt;\libraries\vhdl\altera_mf directory. </P></Sect><P>component altfp_sincos 
</P><P>generic ( 
cordic_depth:natural := 0; 
cordic_width:natural := 0; 
intended_device_family:string := &quot;unused&quot;; 
indexpoint:natural := 0; 
operation:string; 
pipeline:natural := 20; 
rounding:string := &quot;TO_NEAREST&quot;; 
width_exp:natural := 8; 
width_man:natural := 23; 
lpm_hint:string := &quot;UNUSED&quot;; 
lpm_type:string := &quot;altfp_sincos" 
</P><Sect><P>); 
</P></Sect><P>port( 
aclr: in std_logic := '0'; 
clk_en:in std_logic := '1'; 
clock: in std_logic; 
data: in std_logic_vector(width_exp+width_man+1-1 downto 0); 
nan: out std_logic; 
result:out std_logic_vector(width_exp+width_man+1-1 downto 0); 
zero: out std_logic 
</P><Sect><P>); 
end component; 
</P></Sect><Sect/><P id="LinkTarget_7275">VHDL LIBRARY-USE Declaration </P><Sect><P>The VHDL LIBRARY-USE declaration is not required if you use the VHDL Component Declaration. </P><P>LIBRARY altera_mf; 
USE altera_mf_altera_mf_components.all; 
</P></Sect><P id="LinkTarget_7276">Ports and Parameters </P><Sect><P><Link>Table 11–3</Link> lists the input ports of the ALTFP_SINCOS megafunction. </P></Sect><P>Table 11–3. ALTFP_SINCOS Megafunction Input Ports </P><Table><TR><TH>Port Name </TH><TH>Required </TH><TH>Description </TH></TR><TR><TD>aclr </TD><TD>No </TD><TD>Asynchronous clear. When the aclr port is asserted high, the function is asynchronously cleared. </TD></TR><TR><TD>clk_en </TD><TD>No </TD><TD>Clock enable. When the clk_en port is asserted high, sine or cosine operation takes place. When the signal is asserted low, no operation occurs and the outputs remain unchanged. </TD></TR><TR><TD>clock </TD><TD>Yes </TD><TD>Clock input to the megafunction. </TD></TR><TR><TD>data[] </TD><TD>Yes </TD><TD>Floating-point input data. The MSB is the sign bit, the next MSBs are the exponent, and the LSBs are the mantissa. This input port size is the total width of the sign bit, exponent bits, and mantissa bits. </TD></TR></Table><Sect><P><Link>Table 11–4</Link> lists the output ports of the ALTFP_SINCOS megafunction. </P></Sect><P>Table 11–4. ALTFP_SINCOS Megafunction Output Ports </P><Table><TR><TH>Port Name </TH><TH>Required </TH><TH>Description </TH></TR><TR><TD>result[] </TD><TD>Yes </TD><TD>The trigonemetric of the data[]input port in floating-point format. The widths of the result[] output port and data[] input port are the same. </TD></TR></Table><Sect><P><Link>Table 11–5</Link> lists the parameters of the ALTFP_SINCOS megafunction. </P></Sect><P>Table 11–5. ALTFP_SINCOS Megafunction Parameters </P><Table><TR><TH>Parameter Name </TH><TH>Type </TH><TH>Required </TH><TH>Description </TH></TR><TR><TD>WIDTH_EXP </TD><TD>Integer </TD><TD>Yes </TD><TD>Specifies the precision of the exponent. The bias of the exponent is always set to 2(WIDTH_EXP-1) -1 (that is, 127 for single-precision format). The value of WIDTH_EXP must be 8 for single-precision format and must be less than WIDTH_MAN. The available value for WIDTH_EXP is 8. </TD></TR><TR><TD>WIDTH_MAN </TD><TD>Integer </TD><TD>Yes </TD><TD>Specifies the precision of the mantissa. The value of WIDTH_MAN must be 23 when WIDTH_EXP is 8. Otherwise, WIDTH_MAN must be a minimum of 31. The value of WIDTH_MAN must be greater than WIDTH_EXP. The available value for WIDTH_MAN is 23. </TD></TR><TR><TD>PIPELINE </TD><TD>Integer </TD><TD>Yes </TD><TD><Link>The number of pipeline is fixed for the mantissa width and some internal parameter. For the correct settings, refer to Table 11–1 on page 11–1. </Link></TD></TR></Table><Figure><ImageData src="images/math_ip_altera_megafunctions_img_38.jpg"/></Figure><Sect><Sect><H2 id="LinkTarget_7277">12. ALTFP_ABS 
</H2><P><Link>Figure 12–1</Link> shows the ports for the ALTFP_ABS megafunction. </P><P>Figure 12–1. ALTFP_ABS Ports </P><Figure><ImageData src="images/math_ip_altera_megafunctions_img_39.jpg"/>data[] overflow_in nan_in division_by_zero_in zero_in underflow_in clk_en clock inst ALTFP_ABS result[] overflow nan underflow zero division_by_zero aclr </Figure><P id="LinkTarget_7278">Features </P><P>The ALTFP_ABS megafunction offers the following features: </P><L><LI><LI_Label>■ 	</LI_Label><LI_Title>Absolute value of a given input. </LI_Title></LI><LI><LI_Label>■ 	</LI_Label><LI_Title>Optional exception handling output ports such as zero, division_by_zero, overflow, underflow, and nan. </LI_Title></LI><LI><LI_Label>■ 	</LI_Label><LI_Title>Carry-through exception ports from other floating-point modules that act as inputs to the ALTFP_ABS megafunction. </LI_Title></LI></L></Sect><P id="LinkTarget_7279">Output Latency </P><Sect><P>The output latency options for the ALTFP_ADD_SUB megafunction are the same for all three precision formats—single, double, and single-extended. The options available are zero without pipeline, and 1 clock cycle. </P></Sect><Sect/><P id="LinkTarget_7280">Resource Utilization and Performance </P><Sect><P><Link>Table 12–1</Link> lists the resource utilization and performance information for the ALTFP_ABS megafunction. The information was derived using the Quartus II software version 10.0. </P><P>Table 12–1. ALTFP_ABS Resource Utilization and Performance for the Stratix III Device Family </P></Sect><Table><TR><TH>Precision </TH><TH>Output Latency </TH><TH/><TH>Logic usage </TH><TH/><TH>fMAX (MHz)</TH></TR><TR><TD> Adaptive Look-Up Tables (ALUTs) </TD><TD>Dedicated Logic Registers (DLRs) </TD><TD>18-Bit DSP </TD><TD>Memory </TD></TR><TR><TH>Single </TH><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>The fMAX of this megafunction depends on the speed of the selected device </TD></TR><TR><TD>1 </TD><TD>0 </TD><TD>36 </TD><TD>0 </TD><TD>0 </TD></TR><TR><TH>Double </TH><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD></TR><TR><TD>1 </TD><TD>0 </TD><TD>68 </TD><TD>0 </TD><TD>0 </TD></TR></Table><P id="LinkTarget_7281">Design Example: Absolute Value of Multiplication Results </P><Sect><P>This design example uses the ALTFP_ABS megafunction to compute the absolute value of the multiplication result of single-precision format numbers. This example incorporates the ALTFP_MULT megafunction and uses the MegaWizard Plug-In Manager in the Quartus II software. </P></Sect><P id="LinkTarget_7282">Design Files </P><Sect><P>The following files are related to the ALTFP_ABS megafunction: </P><L><LI><LI_Label>■ </LI_Label><LI_Title>altfp_mult_abs_DesignExample.zip (Quartus II design files) </LI_Title></LI><LI><LI_Label>■ </LI_Label><LI_Title>altfp_mult_abs_ex_msim.zip (ModelSim-Altera files) </LI_Title></LI></L></Sect><P id="LinkTarget_7283">Understanding the Simulation Results </P><Sect><P><Link>Table 12–2 on page 12–3</Link> shows the expected simulation results in the ModelSim-Altera software. </P></Sect><P>1 	The simulation waveform in this design example is not shown in its entirety. Run the design example files in the ModelSim-Altera software to see the complete simulation waveforms. </P><P>Table 12–2. ALTFP_ABS Simulation Waveform </P><Figure><ImageData src="images/math_ip_altera_megafunctions_img_40.jpg"/></Figure><Sect><P>22.5 ns 42.5 ns </P><P>This design example produces a floating-point absolute value function for the multiplication results of single-precision format numbers. All the optional input ports (clk_en and aclr) and optional output ports (overflow, underflow, zero, division_by_zero, and nan) are enabled. </P><P>In this example, the latency of the multiplier is set to five clock cycles, while none is being set for the absolute value function. Thus, the absolute value result only appears at the result[] port five cycles after the input values are captured on the input ports. </P><P>The dataa[] and datab[] values in the simulation waveform above portray the two input values that are being fed to the multiplier. The value in the result[] port depicts the multiplication result that has gone through the absolute value operation. </P><P><Link>Table 12–3</Link> lists the inputs and corresponding outputs obtained from the simulation in <Link>Table 12–2</Link>. </P><P>Table 12–3. Summary of Input Values and Corresponding Outputs (Part 1 of 2) </P></Sect><Table><TR><TD>Time </TD><TD>Event </TD></TR><TR><TD>0 ns, start-up </TD><TD>dataa[] value: C080 0000h datab[] value: 4000 0000h Output value: All values seen on the output port before the 5th clock cycle are merely due to the behavior of the system during start-up and should be disregarded. </TD></TR><TR><TD>22.5 ns </TD><TD>Output value: 4100 0000h The multiplication of a negative number with a positive number results in a negative number. The absolute value of the result is reflected on the result[] port. </TD></TR></Table><Sect><P>Table 12–3. Summary of Input Values and Corresponding Outputs (Part 2 of 2) </P></Sect><Table><TR><TD>Time </TD><TD>Event </TD></TR><TR><TD>20 ns </TD><TD>dataa[] value: 579D F479h datab[] value: 7F80 0000h The value of dataa[] is normal while the value of datab[] is infinity. </TD></TR><TR><TD>42.5 ns </TD><TD>Output value: 7F80 0000h Exception handling ports: overflow asserts The multiplication of a normal value with infinity results in infinity and sets the overflow port in the multiplier. The absolute value of the output is infinity and the overflow port is also set as this assertion of the port is being carried through from the corresponding overflow port in the multiplier. </TD></TR></Table><P id="LinkTarget_7284">Specifications </P><Sect><P>This section describes the component declarations, ports, and parameters of the ALTFP_ABS megafunction. The ports and parameters are available to customize the ALTFP_ABS megafunction according to your application. </P></Sect><P id="LinkTarget_7285">VHDL Component Declaration </P><Sect><P>The following VHDL component declaration is located in the VHDL Design File (.vhd) altera_mf_components.vhd in the &lt;Quartus II installation directory&gt;\libraries\vhdl\altera_mf directory. </P></Sect><P>component altfp_abs 
</P><P>generic (
   intended_device_family : string := &quot;unused&quot;;
   pipeline : natural := 0;
   width_exp : natural := 8;
   width_man : natural := 23;
   lpm_hint : string := &quot;UNUSED&quot;;
   lpm_type : string := &quot;altfp_abs" 
</P><Sect><P>); 
</P></Sect><P>port(
   aclr : in std_logic := '0';
   clk_en : in std_logic := '1';
   clock : in std_logic := '0';
   data : in std_logic_vector(width_exp+width_man+1-1 downto 0);
   division_by_zero : out std_logic;
   division_by_zero_in : in std_logic := '0';
   nan : out std_logic;
   nan_in : in std_logic := '0';
   overflow : out std_logic;
   overflow_in : in std_logic := '0';
   result : out std_logic_vector(width_exp+width_man+1-1 downto 0);
   underflow : out std_logic;
   underflow_in : in std_logic := '0';
   zero : out std_logic;
   zero_in : in std_logic := '0' 
</P><Sect><P>); 
end component; 
</P></Sect><Sect/><P id="LinkTarget_7286">VHDL LIBRARY-USE Declaration </P><Sect><P>The VHDL LIBRARY-USE declaration is not required if you use the VHDL Component Declaration. </P><P>LIBRARY altera_mf; 
USE altera_mf_altera_mf_components.all; 
</P></Sect><P id="LinkTarget_7287">Ports and Parameters </P><Sect><P><Link>Table 12–4</Link> lists the input ports of the ALTFP_ABS megafunction. </P></Sect><P>Table 12–4. ALTFP_ABS Megafunction Input Ports </P><Table><TR><TH>Port Name </TH><TH>Required </TH><TH>Description </TH></TR><TR><TD>aclr </TD><TD>No </TD><TD>Asynchronous clear. When the aclr port is asserted high, the function is asynchronously cleared. </TD></TR><TR><TD>clk_en </TD><TD>No </TD><TD>Clock enable. When the clk_en port is asserted high, an absolute value operation takes place. When the signal is asserted low, no operation occurs and the outputs remain unchanged. </TD></TR><TR><TD>clock </TD><TD>Yes </TD><TD>Clock input to the megafunction. </TD></TR><TR><TD>data[] </TD><TD>Yes </TD><TD>Floating-point input data. The MSB is the sign bit, the next MSBs are the exponent, and the LSBs are the mantissa. This input port size is the total width of sign bit, exponent bits, and mantissa bits. </TD></TR><TR><TD>zero_in </TD><TD>No </TD><TD>Zero exception input. Carry-through exception input port from other floating-point modules. </TD></TR><TR><TD>nan_in </TD><TD>No </TD><TD>NaN exception input. Carry-through exception input port from other floating-point modules. </TD></TR><TR><TD>overflow_in </TD><TD>No </TD><TD>Overflow exception input. Carry-through exception input port from other floating-point modules. </TD></TR><TR><TD>underflow_in </TD><TD>No </TD><TD>Underflow exception input. Carry-through exception input port from other floating-point modules. </TD></TR><TR><TD>division_by_zero_in </TD><TD>No </TD><TD>Division-by-zero exception input. Carry-through exception input port from other floating-point modules. </TD></TR></Table><Sect><P><Link>Table 12–5</Link> lists the output ports of the ALTFP_ABS megafunction. </P></Sect><P>Table 12–5. ALTFP_ABS Megafunction Output Ports (Part 1 of 2) </P><Table><TR><TH>Port Name </TH><TH>Required </TH><TH>Description </TH></TR><TR><TD>result[] </TD><TD>Yes </TD><TD>The absolute value result of the input data. The size of this port corresponds to the size of the input data[] port. </TD></TR><TR><TD>zero </TD><TD>No </TD><TD>Zero exception output carried from the input. Asserted if the corresponding carry-through port from the input is asserted. </TD></TR><TR><TD>nan </TD><TD>No </TD><TD>NaN output carried from the input. Asserted if the corresponding carry-through port from the input is asserted. </TD></TR><TR><TD>overflow </TD><TD>No </TD><TD>Overflow exception output carried from the input. Asserted if the corresponding carry-through port from the input is asserted. </TD></TR></Table><Sect/><P>Table 12–5. ALTFP_ABS Megafunction Output Ports (Part 2 of 2) </P><Table><TR><TH>Port Name </TH><TH>Required </TH><TH>Description </TH></TR><TR><TD>underflow </TD><TD>No </TD><TD>Underflow exception output carried from the input. Asserted if the corresponding carry-through port from the input is asserted. </TD></TR><TR><TD>division_by_zero </TD><TD>No </TD><TD>Division-by-zero exception output carried from the input. Asserted if the corresponding carry-through port from the input is asserted. </TD></TR></Table><Sect><P><Link>Table 12–6</Link> lists the parameters of the ALTFP_ABS megafunction. </P></Sect><P>Table 12–6. ALTFP_ABS Megafunction Parameters </P><Table><TR><TH>Port Name </TH><TH>Type </TH><TH>Required </TH><TH>Description </TH></TR><TR><TD>WIDTH_EXP </TD><TD>Integer </TD><TD>Yes </TD><TD>Specifies the precision of the exponent. If this parameter is not specified, the default is 8. The bias of the exponent is always set to 2(WIDTH_EXP - 1) -1, that is, 127 for the single-precision format and 1023 for the double-precision format. The value of WIDTH_EXP must be 8for the single-precision format, 11 for the double-precision format, and a minimum of 11 for the single-extended precision format. The value of WIDTH_EXP must be less than the value of WIDTH_MAN, and the sum of WIDTH_EXP and WIDTH_MAN must be less than 64. </TD></TR><TR><TD>WIDTH_MAN </TD><TD>Integer </TD><TD>Yes </TD><TD>Specifies the precision of the mantissa. If this parameter is not specified, the default is 23. When WIDTH_EXP is 8 and the floating-point format is single-precision, the WIDTH_MANvalue must be 23. Otherwise, the value of WIDTH_MAN must be a minimum of 31. The value of WIDTH_MAN must be greater than the value of WIDTH_EXP, and the sum of WIDTH_EXP and WIDTH_MAN must be less than 64. </TD></TR><TR><TD>PIPELINE </TD><TD>Integer </TD><TD>Yes </TD><TD>Specifies the amount of latency, expressed in clock cycles, used in the ALTFP_ABS megafunction. Create the ALTFP_ABS megafunction with the MegaWizard Plug-In Manager to calculate the value for this parameter. </TD></TR></Table><Figure><ImageData src="images/math_ip_altera_megafunctions_img_41.jpg"/></Figure></Sect><Sect><Sect><H2 id="LinkTarget_7288">13. ALTFP_COMPARE 
</H2><P><Link>Figure 13–1</Link> shows the ports for the ALTFP_COMPARE megafunction. </P><P>Figure 13–1. ALTFP_COMPARE Ports </P><Figure><ImageData src="images/math_ip_altera_megafunctions_img_42.jpg"/>dataa[] clk_en clock inst ALTFP_COMPARE aebanebagbagebalbunordered aclr datab[] aleb</Figure><P id="LinkTarget_7289">Features </P><P>The ALTFP_COMPARE megafunction offers the following features: </P><L><LI><LI_Label>■ </LI_Label><LI_Title>Comparison functions between two inputs. </LI_Title></LI><L><LI><LI_Label>■ </LI_Label><LI_Title>Seven status output ports: </LI_Title></LI><L><LI><LI_Label>■ </LI_Label><LI_Title>aeb (input A is equal to input B). </LI_Title></LI><LI><LI_Label>■ </LI_Label><LI_Title>aneb (input A is not equal to input B). </LI_Title></LI><LI><LI_Label>■ </LI_Label><LI_Title>agb (input A is greater than input B). </LI_Title></LI><LI><LI_Label>■ </LI_Label><LI_Title>ageb (input A is greater than or equal to input B). </LI_Title></LI><LI><LI_Label>■ </LI_Label><LI_Title>alb (input A is less than input B). </LI_Title></LI><LI><LI_Label>■ </LI_Label><LI_Title>aleb (input A is less than or equal to input B). </LI_Title></LI><LI><LI_Label>■ </LI_Label><LI_Title>unordered (used as an output to flag if one or both input ports are NaN). </LI_Title></LI></L></L></L></Sect><P id="LinkTarget_7290">Output Latency </P><Sect><P>The output latency options for the ALTFP_COMPARE megafunction are the same for all three precision formats—single, double, and single-extended. The options available are 1, 2, and 3 clock cycles. </P></Sect><Sect/><P id="LinkTarget_7291">Resource Utilization and Performance </P><Sect><P><Link>Table 13–1</Link> lists the resource utilization and performance information for the ALTFP_COMPARE megafunction. The information was derived using the Quartus II software version 10.0. </P></Sect><P>Table 13–1. ALTFP_COMPARE Resource Utilization and Performance for the Stratix Series of Devices </P><Table><TR><TH>Device Family </TH><TH>Precision </TH><TH>Output Latency </TH><TH/><TH>Logic usage </TH><TH/><TH>fMAX (MHz)</TH></TR><TR><TD>Adaptive Look-Up Tables (ALUTs) </TD><TD>Dedicated Logic Registers (DLRs) </TD><TD>Adaptive Look-Up Modules (ALMs) </TD></TR><TR><TH>Stratix III </TH><TD>single </TD><TD>3 </TD><TD>68 </TD><TD>33 </TD><TD>49 </TD><TD>764 </TD></TR><TR><TD>double </TD><TD>3 </TD><TD>121 </TD><TD>47 </TD><TD>84 </TD><TD>708 </TD></TR><TR><TH>Stratix IV </TH><TD>single </TD><TD>3 </TD><TD>68 </TD><TD>33 </TD><TD>47 </TD><TD>794 </TD></TR><TR><TD>double </TD><TD>3 </TD><TD>121 </TD><TD>47 </TD><TD>87 </TD><TD>680 </TD></TR></Table><P id="LinkTarget_7292">Design Example: Comparison of Single-precision Format Numbers </P><Sect><P>This design example uses the ALTFP_COMPARE megafunction to implement the comparison of single-precision format numbers using the MegaWizard Plug-In Manager in the Quartus II software. </P></Sect><P id="LinkTarget_7293">Design Files </P><Sect><P>The following files are related to the ALTFP_COMPARE megafunction: </P><L><LI><LI_Label>■ </LI_Label><LI_Title>altfp_compare_DesignExample.zip (Quartus II design files) </LI_Title></LI><LI><LI_Label>■ </LI_Label><LI_Title>altfp_compare_ex_msim.zip (ModelSim-Altera files) </LI_Title></LI></L></Sect><P id="LinkTarget_7294">Understanding the Simulation Results </P><Sect><P><Link>Figure 13–2</Link> shows the expected simulation results in the ModelSim-Altera software. </P></Sect><P>1 	The simulation waveform in this design example is not shown in its entirety. Run the design example files in the ModelSim-Altera software to see the complete simulation waveforms. </P><P>Figure 13–2. ALTFP_COMPARE Simulation Waveform </P><Figure><ImageData src="images/math_ip_altera_megafunctions_img_43.jpg"/></Figure><Sect><P>This design example implements a floating-point comparator for single-precision numbers. Both optional input ports (clk_en and aclr) and all seven output ports (ageb, aeb, agb, aneb, alb, aleb, and unordered) are enabled. </P><P>The chosen output latency is 3. Therefore, the comparison operation generates the output result 3 clock cycles later. </P><P><Link>Table 13–2</Link> lists the inputs and corresponding outputs obtained from the simulation in <Link>Figure 13–2</Link>. </P><P>Table 13–2. Summary of Input Values and Corresponding Outputs </P></Sect><Table><TR><TD>Time </TD><TD>Event </TD></TR><TR><TD>0 ns, start-up </TD><TD>dataa[] value: 619B CE11h datab[] value: 9106 CA22h Output value: An undefined value is seen on the result[] port, which is ignored. All values seen on the output port before the 3rd clock cycle are merely due to the behavior of the system during start-up and should be disregarded. </TD></TR><TR><TD>25 ns </TD><TD>Output ports: ageb, aneb, and agb assert </TD></TR><TR><TD>350 ns </TD><TD>dataa[] value: 0060 0000h datab[] value: 0070 0000h Both input values are denormal numbers. </TD></TR><TR><TD>375 ns </TD><TD>Output ports: aeb, ageb, and aleb assert Denormal inputs are not supported and are forced to zero before comparison takes place, which results in the dataa[] value being equal to datab[]. </TD></TR><TR><TD>460 ns </TD><TD>The aclr signal is set for 1 clock cycle. </TD></TR><TR><TD>495.5 ns </TD><TD>The comparisons of subsequent data inputs are performed 3 clock cycles after the aclr signal deasserts. </TD></TR></Table><Sect/><P id="LinkTarget_7295">Specifications </P><Sect><P>This section describes the component declarations, ports, and parameters of the ALTFP_COMPARE megafunction. The ports and parameters are available to customize the ALTFP_COMPARE megafunction according to your application. </P></Sect><P id="LinkTarget_7296">VHDL Component Declaration </P><Sect><P>The VHDL component declaration is located in the VHDL Design File (.vhd) altera_mf_components.vhd in the &lt;Quartus II installation directory&gt;\libraries\vhdl\altera_mf directory. </P></Sect><P id="LinkTarget_7297">VHDL LIBRARY-USE Declaration </P><Sect><P>The VHDL LIBRARY-USE declaration is not required if you use the VHDL Component Declaration. </P><P>LIBRARY altera_mf; 
</P><P>USE altera_mf_altera_mf_components.all; 
</P></Sect><P id="LinkTarget_7298">Ports and Parameters </P><Sect><P><Link>Table 13–3</Link> lists the input ports of the ALTFP_COMPARE megafunction. </P></Sect><P>Table 13–3. ALTFP_COMPARE Megafunction Input Ports </P><Table><TR><TH>Port Name </TH><TH>Required </TH><TH>Description </TH></TR><TR><TD>aclr </TD><TD>No </TD><TD>Asynchronous clear. The source is asynchronously reset when asserted high. </TD></TR><TR><TD>clk_en </TD><TD>No </TD><TD>Clock enable. When this port is asserted high, a compare operation takes place. When signal is asserted low, no operation occurs and the outputs remain unchanged. </TD></TR><TR><TD>clock </TD><TD>Yes </TD><TD>Clock input to the megafunction. </TD></TR><TR><TD>dataa[] </TD><TD>Yes </TD><TD>Data input. The MSB is the sign bit, the next MSBs are the exponent, and the LSBs are the mantissa. This input port size is the total width of sign bit, exponent bits, and mantissa bits. </TD></TR><TR><TD>datab[] </TD><TD>Yes </TD><TD>Data input. The MSB is the sign bit, the next MSBs are the exponent, and the LSBs are the mantissa. This input port size is the total width of sign bit, exponent bits, and mantissa bits. </TD></TR></Table><Sect><P><Link>Table 13–4</Link> lists the output ports of the ALTFP_COMPARE megafunction. </P></Sect><P>Table 13–4. ALTFP_COMPARE Megafunction Output Ports </P><Table><TR><TH>Port Name </TH><TH>Required </TH><TH>Description </TH></TR><TR><TD>aeb </TD><TD>Yes </TD><TD>Output port for the comparator. Asserted if the value of the dataa[] port equals the value of the datab[]port. </TD></TR><TR><TD>agb </TD><TD>Yes </TD><TD>Output port for the comparator. Asserted if the value of the dataa[] port is greater than the value of the datab[]port. </TD></TR><TR><TD>ageb </TD><TD>Yes </TD><TD>Output port for the comparator. Asserted if the value of the dataa[] port is greater than or equal to the value of the datab[] port. </TD></TR><TR><TD>alb </TD><TD>Yes </TD><TD>Output port for the comparator. Asserted if the value of the dataa[] port is less than the value of the datab[] port. </TD></TR><TR><TD>aleb </TD><TD>Yes </TD><TD>Output port for the comparator. Asserted if the value of the dataa[] port is less than or equal to the value of the datab[] port. </TD></TR><TR><TD>aneb </TD><TD>Yes </TD><TD>Output port for the comparator. Asserted if the value of the dataa[] port is not equal to the value of the datab[] port. </TD></TR><TR><TD>unordered </TD><TD>Yes </TD><TD>Output port for the comparator. Asserted when either the dataa[]port and the datab[] port is set to NaN, or if both the dataa[] port and the datab[] port are set to NaN. </TD></TR></Table><Sect><P><Link>Table 13–5</Link> lists the parameters of the ALTFP_COMPARE megafunction. </P></Sect><P>Table 13–5. ALTFP_COMPARE Megafunction Parameters </P><Table><TR><TH>Port Name </TH><TH>Type </TH><TH>Required </TH><TH>Description </TH></TR><TR><TD>WIDTH_EXP </TD><TD>Integer </TD><TD>Yes </TD><TD>Specifies the precision of the exponent. If this parameter is not specified, the default is 8. The bias of the exponent is always set to 2(WIDTH_EXP - 1) -1, that is, 127 for the single-precision format and 1023 for the double-precision format. The value of WIDTH_EXP must be 8 for the single-precision format, 11 for the double-precision format, and a minimum of 11 for the single-extended precision format. The value of WIDTH_EXP must be less than the value of WIDTH_MAN, and the sum of WIDTH_EXP and WIDTH_MAN must be less than 64. </TD></TR><TR><TD>WIDTH_MAN </TD><TD>Integer </TD><TD>Yes </TD><TD>Specifies the precision of the mantissa. If this parameter is not specified, the default is 23. When WIDTH_EXP is 8 and the floating-point format is single-precision, the WIDTH_MAN value must be 23. Otherwise, the value of WIDTH_MAN must be a minimum of 31. The value of WIDTH_MAN must be greater than the value of WIDTH_EXP, and the sum of WIDTH_EXP and WIDTH_MAN must be less than 64. </TD></TR><TR><TD>PIPELINE </TD><TD>Integer </TD><TD>Yes </TD><TD>Specifies the latency in clock cycles used in the ALTFP_COMPARE megafunction. The pipeline values are 1, 2, and 3 latency in clock cycles. </TD></TR></Table><Figure><ImageData src="images/math_ip_altera_megafunctions_img_44.jpg"/></Figure></Sect><Sect><Sect><H2 id="LinkTarget_7299">14. ALTFP_CONVERT 
</H2><P><Link>Figure 14–1</Link> shows the ports for the ALTFP_CONVERT megafunction. </P><P>Figure 14–1. ALTFP_CONVERT Ports </P><Figure><ImageData src="images/math_ip_altera_megafunctions_img_45.jpg"/>dataa[] clock clk_en inst ALTFP_CONVERT result[] overflow nan underflow aclr </Figure><P id="LinkTarget_7300">Features </P><P>The ALTFP_CONVERT megafunction offers the following features: </P><L><L><LI><LI_Label>■ 	</LI_Label><LI_Title>Conversion functions for the following formats: </LI_Title></LI><L><LI><LI_Label>■ 	</LI_Label><LI_Title>Integer-to-Float. </LI_Title></LI><LI><LI_Label>■ 	</LI_Label><LI_Title>Float-to-Integer. </LI_Title></LI><LI><LI_Label>■ 	</LI_Label><LI_Title>Float-to-Float. </LI_Title></LI><LI><LI_Label>■ 	</LI_Label><LI_Title>Fixed-to-Float. </LI_Title></LI><LI><LI_Label>■ 	</LI_Label><LI_Title>Float-to-Fixed. </LI_Title></LI></L></L><LI><LI_Label>■ 	</LI_Label><LI_Title>Support for signed and unsigned integers. </LI_Title></LI><LI><LI_Label>■ 	</LI_Label><LI_Title>Optional exception handling output ports such as overflow, underflow, and nan. <Link>Table 14–1</Link> lists the conversion operations supported by each exception port. </LI_Title></LI></L><P>Table 14–1. Supported Operations and Exception Ports </P></Sect><Table><TR><TD>Operation </TD><TD>Supported Exception Ports </TD></TR><TR><TD>Integer-to-Float </TD><TD>Not supported </TD></TR><TR><TD>Float-to-Integer </TD><TD>overflow, underflow, and nan </TD></TR><TR><TD>Float-to-Float </TD><TD>overflow, underflow, and nan </TD></TR><TR><TD>Fixed-to-Float </TD><TD>Not supported </TD></TR><TR><TD>Float-to-Fixed </TD><TD>overflow, underflow, and nan </TD></TR></Table><Sect/><P id="LinkTarget_7301">Conversion Operations </P><Sect><P>The following sections describes the features of each conversion operation. </P></Sect><P id="LinkTarget_7302">Integer-to-Float Conversion </P><Sect><L><LI><LI_Label>■ 	</LI_Label><LI_Title>Converts integers to the IEEE-754 standard floating-point representation. </LI_Title></LI><LI><LI_Label>■ 	</LI_Label><LI_Title>Supports conversions of signed integers to floating-point numbers in single, double, and single-extended precision formats. </LI_Title></LI></L></Sect><P id="LinkTarget_7303">Float-to-Integer Conversion </P><Sect><L><LI><LI_Label>■ 	</LI_Label><LI_Title>Converts IEEE-754 standard floating-point representations to the integer-bit format. </LI_Title></LI><LI><LI_Label>■ 	</LI_Label><LI_Title>Supports conversions of signed integers to floating-point numbers in single, double, and single-extended precision formats. </LI_Title></LI></L></Sect><P id="LinkTarget_7304">Float-to-Float Conversion </P><Sect><L><LI><LI_Label>■ 	</LI_Label><LI_Title>Converts between IEEE-754 standard floating-point representations. </LI_Title></LI><LI><LI_Label>■ 	</LI_Label><LI_Title>Supports conversions of signed integers to floating-point numbers in single, double, and single-extended precision formats. </LI_Title></LI><L><LI><LI_Label>■ 	</LI_Label><LI_Title>This operation offers the following modes: </LI_Title></LI><L><LI><LI_Label>■ 	</LI_Label><LI_Title>Single-precision format to single-extended precision format or double-precision format. </LI_Title></LI><LI><LI_Label>■ 	</LI_Label><LI_Title>Double-precision format to single-precision format or single-extended precision format. </LI_Title></LI><LI><LI_Label>■ 	</LI_Label><LI_Title>Single-extended precision format to single-precision or double-precision format. </LI_Title></LI></L></L></L></Sect><P id="LinkTarget_7305">Fixed-to-Float Conversion </P><Sect><L><LI><LI_Label>■ 	</LI_Label><LI_Title>Converts fixed-point format data to the IEEE-754 standard floating-point representation. </LI_Title></LI><LI><LI_Label>■ 	</LI_Label><LI_Title>Supports conversions of fixed-point format data to floating-point numbers in single, double, and single-extended precision formats. </LI_Title></LI></L></Sect><P id="LinkTarget_7306">Float-to-Fixed Conversion </P><Sect><L><LI><LI_Label>■ 	</LI_Label><LI_Title>Converts IEEE-754 standard floating-point representations to the fixed-point format. </LI_Title></LI><LI><LI_Label>■ 	</LI_Label><LI_Title>Supports conversion of floating-point numbers in single, double, and single-extended precision formats. </LI_Title></LI></L></Sect><Sect/><P id="LinkTarget_7307">Output Latency </P><Sect><P>The output latency options for the all the conversion operations in the ALTFP_CONVERT megafunction are fixed, except for the Float-to-Float operation. </P><P><Link>Table 14–2</Link> lists the output latency options required for each operation. </P><P>Table 14–2. Latency Options for Each Operation </P></Sect><Table><TR><TH>Operation </TH><TH>Latency (in clock cycles) </TH></TR><TR><TH>Integer-to-Float </TH><TD>6 </TD></TR><TR><TH>Float-to-Integer </TH><TD>6 </TD></TR><TR><TH>Float-to-Float </TH><TD>Conversion from: </TD><TD/></TR><TR><TD>Single-precision format </TD><TD>2 </TD></TR><TR><TD>Double-precision format </TD><TD>3 </TD></TR><TR><TD>Single-extended precision format </TD><TD>3 </TD></TR><TR><TH>Fixed-to-Float </TH><TD>6 </TD></TR><TR><TH>Float-to-Fixed </TH><TD>6 </TD></TR></Table><P id="LinkTarget_7308">Resource Utilization and Performance </P><Sect><P><Link>Table 14–3</Link> lists the resource utilization and performance information for the ALTFP_CONVERT megafunction. The information was derived using the Quartus II software version 10.0. </P></Sect><P>Table 14–3. ALTFP_CONVERT Resource Utilization and Performance for the Stratix III Device Family (Part 1 of 2) </P><Table><TR><TH>Operation </TH><TH>Format </TH><TH>Pipeline </TH><TH/><TH>Logic usage </TH><TH/><TH>fMAX (MHz)</TH></TR><TR><TH> Adaptive Look-Up Tables (ALUTs) </TH><TH>Dedicated Logic Registers (DLRs) </TH><TH>Adaptive Logic Modules (ALMs) </TH></TR><TR><TH>Integer to-Float </TH><TH>32-bit integer to single-precision </TH><TD>6 </TD><TD>182 </TD><TD>238 </TD><TD>157 </TD><TD>515 </TD></TR><TR><TH>32-bit integer to double-precision </TH><TD>6 </TD><TD>150 </TD><TD>139 </TD><TD>123 </TD><TD>510 </TD></TR><TR><TH>64-bit integer to single-precision </TH><TD>6 </TD><TD>385 </TD><TD>371 </TD><TD>296 </TD><TD>336 </TD></TR><TR><TH>64-bit integer to single-precision </TH><TD>6 </TD><TD>393 </TD><TD>461 </TD><TD>344 </TD><TD>336 </TD></TR><TR><TH>Float-to-Integer </TH><TH>Single-precision to 32-bit integer </TH><TD>6 </TD><TD>256 </TD><TD>255 </TD><TD>176 </TD><TD>455 </TD></TR><TR><TH>Single-precision to 64-bit integer </TH><TD>6 </TD><TD>417 </TD><TD>361 </TD><TD>257 </TD><TD>311 </TD></TR><TR><TH>Double-precision to 32-bit integer </TH><TD>6 </TD><TD>406 </TD><TD>387 </TD><TD>273 </TD><TD>409 </TD></TR><TR><TH>Double-precision to 64-bit integer </TH><TD>6 </TD><TD>535 </TD><TD>480 </TD><TD>362 </TD><TD>309 </TD></TR></Table><Sect/><P>Table 14–3. ALTFP_CONVERT Resource Utilization and Performance for the Stratix III Device Family (Part 2 of 2) </P><Table><TR><TH>Float-to-Float </TH><TH>Single-precision to double-precision </TH><TH>2 </TH><TH>44 </TH><TH>73 </TH><TH>40 </TH><TH>868 </TH></TR><TR><TH>Double-precision to single-precision </TH><TD>3 </TD><TD>103 </TD><TD>140 </TD><TD>89 </TD><TD>520 </TD></TR><TR><TH>Fixed-to-Float </TH><TH>16.16 fixed-point to double-precision </TH><TD>6 </TD><TD>182 </TD><TD>238 </TD><TD>155 </TD><TD>519 </TD></TR><TR><TH>16.16 fixed-point to double-precision </TH><TD>6 </TD><TD>150 </TD><TD>139 </TD><TD>122 </TD><TD>513 </TD></TR><TR><TH>32.32 fixed-point to single-precision </TH><TD>6 </TD><TD>384 </TD><TD>371 </TD><TD>296 </TD><TD>334 </TD></TR><TR><TH>32.32 fixed-point to single-precision </TH><TD>6 </TD><TD>393 </TD><TD>461 </TD><TD>336 </TD><TD>333 </TD></TR><TR><TH>Float-to-Fixed </TH><TH>Single-precision to 16.16 fixed-point </TH><TD>6 </TD><TD>319 </TD><TD>261 </TD><TD>210 </TD><TD>438 </TD></TR><TR><TH>Single-precision to 32.32 fixed-point </TH><TD>6 </TD><TD>469 </TD><TD>367 </TD><TD>288 </TD><TD>315 </TD></TR><TR><TH>Double-precision to 16.16 fixed-point </TH><TD>6 </TD><TD>579 </TD><TD>393 </TD><TD>402 </TD><TD>365 </TD></TR><TR><TH>Double-precision to 32.32 fixed-point </TH><TD>6 </TD><TD>695 </TD><TD>486 </TD><TD>474 </TD><TD>306 </TD></TR></Table><P id="LinkTarget_7309">Design Example: Convert Double-Precision Floating-Point Format Numbers to 64-bit Integers </P><Sect><P>This design example uses the ALTFP_CONVERT megafunction to convert double-precision floating-point format numbers to 64-bit integers. This design example uses the MegaWizard Plug-In Manager in the Quartus II software. </P></Sect><P id="LinkTarget_7310">Design Files </P><Sect><P>The following files are related to the ALTFP_CONVERT megafunction: </P><L><LI><LI_Label>■ </LI_Label><LI_Title>altfp_convert_DesignExample.zip (Quartus II design files) </LI_Title></LI><LI><LI_Label>■ </LI_Label><LI_Title>altfp_convert_float2int_msim.zip (ModelSim-Altera files) </LI_Title></LI></L></Sect><P id="LinkTarget_7311">Understanding the Simulation Results </P><Sect><P><Link>Figure 14–2</Link> shows the expected simulation results in the ModelSim-Altera software. </P></Sect><P>1 	The simulation waveform in this design example is not shown in its entirety. Run the design example files in the ModelSim-Altera software to see the complete simulation waveforms. </P><P>Figure 14–2. ALTFP_CONVERT Simulation Waveform </P><Figure><ImageData src="images/math_ip_altera_megafunctions_img_46.jpg"/></Figure><Sect><P>205 ns 	355 ns </P><P>This design example implements a float-to-integer converter for converting double-precision floating-point format numbers to 64-bit integers. In this operation, the optional exception ports of overflow, underflow, and nan are available apart from the result[] port. </P><P>The latency for the float-to-integer operation is six clock cycles. Therefore, each conversion generates the output result six clock cycles after receiving the input value. </P></Sect><Sect><P><Link>Table 14–4</Link> lists the inputs and corresponding outputs obtained from the simulation in <Link>Figure 14–2 on page 14–5</Link>. </P><P>Table 14–4. Summary of Input Values and Corresponding Outputs </P></Sect><Table><TR><TD>Time </TD><TD>Event </TD></TR><TR><TD>0 ns, start-up </TD><TD>dataa[] value: C394 AD22 761B 9EE5h Output value: The result[] port displays 0 regardless of what the input value is. This value seen on the output port before the 6th clock cycle is merely due to the behavior of the system during start-up and should be disregarded. </TD></TR><TR><TD>55 ns </TD><TD>Output value: FAD4 B762 7918 46C0h </TD></TR><TR><TD>150 ns </TD><TD>dataa[] value: 000F 0000 5555 1111h This value is a denormal number. </TD></TR><TR><TD>205 ns </TD><TD>Denormal inputs are not supported and are forced to zero before conversion takes place. </TD></TR><TR><TD>300 ns </TD><TD>dataa[] value: 5706 40CF OEC6 1176h </TD></TR><TR><TD>355 ns </TD><TD>Output value: 7FFF FFFF FFFF FFFFh Exception handling ports: overflow asserts. The overflow flag is triggered because the width of the resulting integer is more than the maximum width allowed, and the value seen on the result[] port is the standard value used to represent a positive overflow number. </TD></TR><TR><TD>350 ns </TD><TD>dataa[] value: C728 3147 8444 1F75h </TD></TR><TR><TD>405 ns </TD><TD>Output value: 8000 0000 0000 0000h Exception handling ports: overflow remains asserted. This is a standard value to represent a negative overflow number. </TD></TR><TR><TD>400 ns </TD><TD>dataa[] value: 145A 257C 895A B309h </TD></TR><TR><TD>455 ns </TD><TD>Output value: 0000 0000h Exception handling ports: underflow asserts. The input value triggers the underflowport because the exponent of the input value is less than the exponent bias of 1023. </TD></TR><TR><TD>500 ns </TD><TD>dataa[] value: FFFF 0000 DDDD 5555h This value is a NaN. </TD></TR><TR><TD>555 ns </TD><TD>Output value: 0000 0000h Exception handling ports: nan asserts. </TD></TR></Table><Sect/><P id="LinkTarget_7312">Specifications </P><Sect><P>This section describes the component declarations, ports, and parameters of the ALTFP_CONVERT megafunction. The ports and parameters are available to customize the ALTFP_CONVERT megafunction according to your application. </P></Sect><P id="LinkTarget_7313">VHDL Component Declaration </P><Sect><P>The following VHDL component declaration is located in the VHDL Design File (.vhd) altera_mf_components.vhd in the &lt;Quartus II installation directory&gt;\libraries\vhdl\altera_mf directory. </P></Sect><P>component altfp_convert
     generic (
</P><Table><TR><TH/><TH>     intended_device_family  </TH><TH>: </TH><TH>     string := &quot;unused&quot;;</TH></TR><TR><TD/><TD>     operation   </TD><TD>: </TD><TD>    string := &quot;INT2FLOAT&quot;;</TD></TR><TR><TD/><TD>     rounding    </TD><TD>: </TD><TD>    string := &quot;TO_NEAREST&quot;;</TD></TR><TR><TD/><TD>     width_data  </TD><TD>: </TD><TD>    natural := 32;</TD></TR><TR><TD/><TD>     width_exp_input :   </TD><TD>    natural := 8;</TD></TR><TR><TD/><TD>     width_exp_output    </TD><TD>: </TD><TD>    natural := 8;</TD></TR><TR><TD/><TD>     width_int   </TD><TD>: </TD><TD>    natural := 32;</TD></TR><TR><TD/><TD>     width_man_input :   </TD><TD>    natural := 23;</TD></TR><TR><TD/><TD>     width_man_output    </TD><TD>: </TD><TD>    natural := 23;</TD></TR><TR><TD/><TD>     width_result</TD><TD> : </TD><TD>    natural := 32;</TD></TR><TR><TD/><TD>     lpm_hint    </TD><TD>: </TD><TD>    string := &quot;UNUSED&quot;;</TD></TR><TR><TD/><TD>     lpm_type    </TD><TD>: </TD><TD>    string := &quot;altfp_convert&quot;</TD></TR><TR><TD> );</TD><TD/></TR><TR><TD>     port(</TD><TD/></TR><TR><TD/><TD>     aclr  </TD><TD>: </TD><TD>    in std_logic := '0';</TD></TR><TR><TD/><TD>     clk_en  </TD><TD>: </TD><TD>    in std_logic := '1';</TD></TR><TR><TD/><TD>     clock  </TD><TD>: </TD><TD>    in std_logic;</TD></TR><TR><TD/><TD>     dataa  </TD><TD>: </TD><TD>    in std_logic_vector(width_data-1 downto 0);</TD></TR><TR><TD/><TD> nan</TD><TD> : </TD><TD>    out std_logic;</TD></TR><TR><TD/><TD>     overflow    </TD><TD>: </TD><TD>    out std_logic;</TD></TR><TR><TD/><TD>     result  </TD><TD>: </TD><TD>    out std_logic_vector(width_result-1 downto 0);</TD></TR><TR><TD/><TD>     underflow   </TD><TD>: </TD><TD>    out std_logic</TD></TR><TR><TD> ); </TD><TD/></TR><TR><TD>end component; </TD><TD/></TR></Table><P id="LinkTarget_7314">VHDL LIBRARY-USE Declaration </P><Sect><P>The VHDL LIBRARY-USE declaration is not required if you use the VHDL Component Declaration. </P><P>LIBRARY altera_mf; 
USE altera_mf_altera_mf_components.all; 
</P></Sect><Sect/><P id="LinkTarget_7315">Ports and Parameters </P><Sect><P><Link>Table 14–5</Link> lists the input ports of the ALTFP_CONVERT megafunction. </P></Sect><P>Table 14–5. ALTFP_CONVERT Megafunction Input Ports </P><Table><TR><TH>Port Name </TH><TH>Required </TH><TH>Description </TH></TR><TR><TD>clock </TD><TD>Yes </TD><TD>The clock input to the ALTFP_CONVERT megafunction. </TD></TR><TR><TD>clk_en </TD><TD>No </TD><TD>Clock enable that allows conversions to take place when asserted high. When asserted low, no operation occurs and the outputs are unchanged. </TD></TR><TR><TD>aclr </TD><TD>No </TD><TD>Asynchronous clear. The source is asynchronously reset when the aclr signal is asserted high. </TD></TR><TR><TD>dataa[] </TD><TD>Yes </TD><TD>Data input. The size of this input port depends on the WIDTH_DATA parameter value. If the operation mode value is INT2FLOATor FIXED2FLOAT, the data on the input bus is an integer. If the operation mode value is FLOAT2INT or FLOAT2FIXED, the input bus is the IEEE floating-point representation. In the single-precision format, the input bus width value is 32. In the double-precision format, the input bus width value is 64. In the single-extended precision format, the input bus range is from 43 to 64. If the operation mode value is FLOAT2FLOAT, the input bus value is the IEEE floating-point representation. In the single-precision format, the input bus width value is 32. In the double-precision format, the input bus width value is 64. In the single-extended precision format, the input bus range is from 43 to 64. </TD></TR></Table><Sect><P><Link>Table 14–6</Link> describes the output ports of the ALTFP_CONVERT megafunction. </P></Sect><P>Table 14–6. ALTFP_CONVERT Megafunction Output Ports (Part 1 of 2) </P><Table><TR><TH>Port Name </TH><TH>Required </TH><TH>Description </TH></TR><TR><TD>result[] </TD><TD>Yes </TD><TD>Output for the floating-point converter. The size of this output port depends on the WIDTH_RESULT parameter value. If the operation mode value is FLOAT2INT or FLOAT2FIXED, the output bus is an IEEE floating-point representation. If the operation mode is FLOAT2INT, the output bus is an integer representation. If the selected precision is the single-precision format, the output bus width value is 32. If the selected precision is the double-precision format, the output bus width value is 64. If the selected precision is the single-extended precision format, the input bus range is from 43 to 64. If the operation mode value is FLOAT2FLOAT, the output bus is an IEEE floating-point representation. If the selected precision is the single-precision format, the output bus is in the 64-bit double-precision format. If the selected precision is the double-precision format, the output bus is in the 32-bit single-precision format. If the selected precision is the single-extended precision format, the output bus ranges from 43 to 64. </TD></TR><TR><TD>overflow </TD><TD>No </TD><TD>Optional overflow exception output. This port is available only when the operation mode values are FLOAT2FIXED, FLOAT2INT, or FLOAT2FLOAT. Asserted when the result of the conversion (after rounding), exceeds the maximum width of the result[] port, or when the dataa[] input is infinity. </TD></TR></Table><Sect/><P>Table 14–6. ALTFP_CONVERT Megafunction Output Ports (Part 2 of 2) </P><Table><Caption><P>Chapter 14: ALTFP_CONVERT 14–9 </P></Caption><TR><TH>Port Name </TH><TH>Required </TH><TH>Description </TH></TR><TR><TD>underflow </TD><TD>No </TD><TD>Optional underflow exception output. This port is available only when the operation mode values are FLOAT2FIXED, FLOAT2INT, or FLOAT2FLOAT. Asserted when the result of the conversion, after rounding, is fractional. In FLOAT2INT operations, this port is asserted when the exponent value of the floating-point input is smaller than the exponent bias. In FLOAT2FLOAT operations, this port is asserted when the floating-point input has a value smaller than the lowest exponent limit of the target floating-point format. </TD></TR><TR><TD>nan </TD><TD>No </TD><TD>Optional NaN exception output. This port is available only when the operation mode values are FLOAT2INT, FLOAT2FLOAT, or FLOAT2FIXED. Asserted when the input port is a NaN representation. If the operation mode value is FLOAT2INTor FLOAT2FIXED, the result[]port is set to zero. If the operation mode value is FLOAT2FLOAT, the result[] port is set to a NaN representation. </TD></TR></Table><Sect><P><Link>Table 14–7</Link> lists the parameters of the ALTFP_CONVERT megafunction. </P></Sect><P>Table 14–7. ALTFP_CONVERT Megafunction Parameters (Part 1 of 3) </P><Table><TR><TH>Port Name </TH><TH>Type </TH><TH>Required </TH><TH>Description </TH></TR><TR><TD>WIDTH_EXP_INPUT </TD><TD>Integer </TD><TD>Yes </TD><TD>Specifies the precision of the exponent. If this parameter is not specified, the default is 8. The bias of the exponent is always set to 2(WIDTH_EXP - 1) -1, that is, 127 for the single-precision format and 1023 for the double-precision format. The value of WIDTH_EXP_INPUT must be 8 for the single-precision format, 11 for the double-precision format, and a minimum of 11 for the single-extended precision format. The value of WIDTH_EXP_INPUT must be less than the value of WIDTH_MAN_INPUT, and the sum of WIDTH_EXP_INPUT and WIDTH_MAN_INPUT must be less than 64. These settings apply only to the FLOAT2FIXED, FLOAT2INT, and FLOAT2FLOAT operation modes. </TD></TR><TR><TD>WIDTH_MAN_INPUT </TD><TD>Integer </TD><TD>Yes </TD><TD>Specifies the precision of the mantissa. If this parameter is not specified, the default is 23. When WIDTH_EXP_INPUT is 8 and the floating-point format is single-precision, the WIDTH_MAN_INPUT value must be 23. Otherwise, the value of WIDTH_MAN_INPUTmust be a minimum of 31. The value of WIDTH_MAN_INPUT must be greater than the value of WIDTH_EXP_INPUT, and the sum of WIDTH_EXP_INPUT and WIDTH_MAN_INPUT must be less than 64. These settings apply only to the FLOAT2FIXED, FLOAT2INT, and FLOAT2FLOAT operation modes. </TD></TR><TR><TD>WIDTH_INT </TD><TD>Integer </TD><TD>Yes </TD><TD>Specifies the integer width. If the operation is FIXED2FLOATor INT2FLOAT, this parameter defines the integer width on the input side. If the operation is FLOAT2INTor FLOAT2FIXED, this parameter defines the result width on the output side. The available settings are 32 bits, 64 bits or n bits. For n bits settings, the range is from 4 bits to 64 bits. </TD></TR></Table><Sect/><P>Table 14–7. ALTFP_CONVERT Megafunction Parameters (Part 2 of 3) Table 14–7. ALTFP_CONVERT Megafunction Parameters (Part 3 of 3) </P><Table><TR><TH>Port Name </TH><TH>Type </TH><TH>Required </TH><TH>Description </TH></TR><TR><TD>WIDTH_DATA </TD><TD>Integer </TD><TD>Yes </TD><TD>Specifies the input data width. If the operation is INT2FLOAT, the WIDTH_DATA is also WIDTH_INT. If the operation is FIXED2FLOAT, the data width value is WIDTH_INT + fractional width. If the operation is FLOAT2FIXED, FLOAT2INT or FLOAT2FLOAT, the data width value is WIDTH_EXP_INPUT + WIDTH_MAN_INPUT + 1. The available settings are 32 bits, 64 bits or n bits. For n bits settings, the range is from 4 bits to 64 bits. </TD></TR><TR><TD>WIDTH_EXP_OUTPUT </TD><TD>Integer </TD><TD>Yes </TD><TD>Specifies the precision of the exponent. If this parameter is not specified, the default is 8. The bias of the exponent is always set to 2(WIDTH_EXP - 1) -1, that is, 127 for the single-precision format and 1023 for the double-precision format. The value of WIDTH_EXP_OUTPUT must be 8for the single-precision format, 11 for the double-precision format, and a minimum of 11 for the single-extended precision format. The value of WIDTH_EXP_OUTPUT must be less than the value of WIDTH_MAN_OUTPUT, and the sum of WIDTH_EXP_OUTPUT and WIDTH_MAN_OUTPUT must be less than 64. These settings apply only to the FLOAT2FIXED, FLOAT2INT, and FLOAT2FLOAT operation modes. </TD></TR><TR><TD>WIDTH_MAN_OUTPUT </TD><TD>Integer </TD><TD>Yes </TD><TD>Specifies the precision of the mantissa. If this parameter is not specified, the default is 23. When WIDTH_EXP_OUTPUT is 8 and the floating point format is single-precision, the WIDTH_MAN_OUTPUT value must be 23. Otherwise, the value of WIDTH_MAN_OUTPUT must be a minimum of 31. The value of WIDTH_MAN_OUTPUT must be greater than the value of WIDTH_EXP_OUTPUT, and the sum of WIDTH_EXP_OUTPUT and WIDTH_MAN_OUTPUT must be less than 64. These settings apply only to the FLOAT2FIXED, FLOAT2INT, and FLOAT2FLOAT operation modes. </TD></TR><TR><TD>WIDTH_RESULT </TD><TD>Integer </TD><TD>Yes </TD><TD>Specifies the width of the output result. In an INT2FLOAT, FLOAT2FLOAT, or FIXED2FLOAT operation, the result width is WIDTH_EXP_OUTPUT+ WIDTH_MAN_OUTPUT+ 1. In a FLOAT2INT operation, the result width is the value of the WIDTH_INT parameter. In a FLOAT2FIXED operation, this parameter is the result width. The available settings are 32 bits, 64 bits or n bits. For n bits settings, the range is from 4 bits to 64 bits. </TD></TR></Table><Sect/><Table><Caption><P>Chapter 14: ALTFP_CONVERT 14–11 </P></Caption><TR><TH>Port Name </TH><TH>Type </TH><TH>Required </TH><TH>Description </TH></TR><TR><TD>ROUNDING </TD><TD>Integer </TD><TD>Yes </TD><TD>Specifies the rounding mode. The default value is TO_NEAREST. Other modes are not supported. </TD></TR><TR><TD>OPERATION </TD><TD>Integer </TD><TD>Yes </TD><TD>Specifies the operating mode. Values are INT2FLOAT, FLOAT2INT, FLOAT2FLOAT, FLOAT2FIXED, and FIXED2FLOAT. If this parameter is not specified, the default value is INT2FLOAT. When set to INT2FLOAT, the conversion of an integer input to an IEEE floating-point representation output takes place. When set to FLOAT2INT, the conversion of an IEEE floating-point representation input to an integer output takes place. When set to FLOAT2FLOAT, the conversion between IEEE floating-point representations input and output takes place. When set to FIXED2FLOAT, the conversion of a fixed point input to an IEEE floating-point representation output takes place. When set to FLOAT2FIXED, the IEEE floating-point input conversion to fixed point representation output takes place. </TD></TR></Table><Figure><ImageData src="images/math_ip_altera_megafunctions_img_47.jpg"/></Figure></Sect><Sect><Sect><H2 id="LinkTarget_7316">15. ALTFP_MATRIX_INV 
</H2><P><Link>Figure 15–1</Link> shows the ports for the ALTFP_MATRIX_INV megafunction. </P><P>Figure 15–1. ALTFP_MATRIX_INV Ports </P><P>ALTFP_MATRIX_INV datain dataout[] load busy sysclk outvalid enable done reset </P><P>inst </P><P id="LinkTarget_7317">Features </P><P>The ALTFP_MATRIX_INV megafunction offers the following features: </P><L><LI><LI_Label>■ </LI_Label><LI_Title>Inversion of a matrix. </LI_Title></LI><LI><LI_Label>■ </LI_Label><LI_Title>Support for floating-point format in single precision. </LI_Title></LI><LI><LI_Label>■ </LI_Label><LI_Title>Support for VHDL and Verilog HDL languages. </LI_Title></LI><LI><LI_Label>■ </LI_Label><LI_Title>Support for matrix sizes up to 64 × 64. </LI_Title></LI><LI><LI_Label>■ </LI_Label><LI_Title>Use of control signal, load. </LI_Title></LI><LI><LI_Label>■ </LI_Label><LI_Title>Use of handshaking signals: busy, outvalid, and done. </LI_Title></LI></L></Sect><P id="LinkTarget_7318">Output Latency </P><Sect><P>The ALTFP_MATRIX_INV megafunction does not have a fixed output latency. Instead, it uses handshaking signals to interface with external circuitry. </P></Sect><P>15–2 Chapter 15: ALTFP_MATRIX_INV </P><P>Resource Utilization and Performance </P><P>Resource Utilization and Performance </P><Sect><P><Link>Table 15–1</Link> and <Link>Table 15–2</Link> list the resource utilization and performance information for the ALTFP_MATRIX_INV megafunction. The information was derived using the Quartus II software version 10.0 </P><P>Table 15–1. ALTFP_MATRIX_INV Resource Utilization and Performance for the Stratix III Device Family </P><Table><TR><TH>Precision </TH><TH>Matrix Size </TH><TH>Blocks </TH><TH/><TH>Logic usage </TH><TH/><TH>Latency </TH><TH>Throughput (kb/s) </TH><TH>Giga Floating-Point Operations per Second (GFLOPS) </TH><TH>fMAX (MHz) </TH></TR><TR><TH>Adaptive Logic Modules (ALMs) </TH><TH>DSP Usage (18 x 18 DSPs) </TH><TH>M9K </TH><TH>M144K </TH><TH>Memory (Bits) </TH></TR><TR><TH/><TD>8 × 8 </TD><TD>2 </TD><TD>6,160 </TD><TD>63 </TD><TD>39 </TD><TD>— </TD><TD>53,736 </TD><TD>2,501 </TD><TD>3,987 </TD><TD>14.33 </TD><TD>312 </TD></TR><TR><TH>Single </TH><TD>16 × 16 </TD><TD>4 </TD><TD>9,923 </TD><TD>95 </TD><TD>64 </TD><TD>— </TD><TD>138,051 </TD><TD>11,057 </TD><TD>855 </TD><TD>27.76 </TD><TD>295 </TD></TR><TR><TD>32 × 32 </TD><TD>8 </TD><TD>17,980 </TD><TD>159 </TD><TD>150 </TD><TD>— </TD><TD>699,164 </TD><TD>52,625 </TD><TD>165 </TD><TD>51.58 </TD><TD>271 </TD></TR><TR><TD>64 × 64 </TD><TD>16 </TD><TD>34,973 </TD><TD>287 </TD><TD>151 </TD><TD>33 </TD><TD>4,770,369 </TD><TD>281,505 </TD><TD>25 </TD><TD>83.34 </TD><TD>218 </TD></TR></Table><P>Table 15–2. ALTFP_MATRIX_INV Resource Utilization and Performance for the Stratix IV Device Family </P><Table><TR><TH>Precision </TH><TH>Matrix Size </TH><TH>Blocks </TH><TH/><TH>Logic usage </TH><TH/><TH>Latency </TH><TH>Throughput (kb/s) </TH><TH>Giga Floating-Point Operations per Second (GFLOPS) </TH><TH>fMAX (MHz) </TH></TR><TR><TH>Adaptive Logic Modules (ALMs) </TH><TH>DSP Usage (18 x 18 DSPs) </TH><TH>M9K </TH><TH>M144K </TH><TH>Memory (Bits) </TH></TR><TR><TH/><TD>8 × 8 </TD><TD>2 </TD><TD>5,538 </TD><TD>63 </TD><TD>49 </TD><TD>— </TD><TD>53,736 </TD><TD>2,501 </TD><TD>3,987 </TD><TD>15.26 </TD><TD>332 </TD></TR><TR><TH>Single </TH><TD>16 × 16 </TD><TD>4 </TD><TD>8,865 </TD><TD>95 </TD><TD>80 </TD><TD>— </TD><TD>138,051 </TD><TD>11,057 </TD><TD>855 </TD><TD>30.93 </TD><TD>329 </TD></TR><TR><TD>32 × 32 </TD><TD>8 </TD><TD>15,655 </TD><TD>159 </TD><TD>193 </TD><TD>— </TD><TD>699,164 </TD><TD>52,625 </TD><TD>165 </TD><TD>55.12 </TD><TD>290 </TD></TR><TR><TD>64 × 64 </TD><TD>16 </TD><TD>29,940 </TD><TD>287 </TD><TD>386 </TD><TD>22 </TD><TD>4,770,369 </TD><TD>281,505 </TD><TD>25 </TD><TD>83.16 </TD><TD>218 </TD></TR></Table></Sect><P id="LinkTarget_7319">Floating-Point Megafunctions User Guide May 2011 Altera Corporation </P><Sect/><P id="LinkTarget_7320">Functional Description </P><Sect><P>A matrix inversion function is composed of the following components: </P><L><LI><LI_Label>■ 	</LI_Label><LI_Title>Cholesky decomposition function. The Cholesky decomposition function generates a lower triangular matrix. </LI_Title></LI><L><LI><LI_Label>■ 	</LI_Label><LI_Title>Triangular matrix inversion function. </LI_Title></LI><LI>The triangular matrix inversion process then generates the inverse of the lower triangular using backward substitution. </LI></L><LI><LI_Label>■ 	</LI_Label><LI_Title>Matrix multiplication function. The matrix multiplier multiplies the transpose of the inverse triangular matrix with the inverse triangular matrix. </LI_Title></LI></L><P>In linear algebra, the Cholesky decomposition states that every positive definite matrix A is decomposed as A = L×LT where, L is a lower triangular matrix, and LT denotes the transpose of L. The property of invertible matrices states that (X×Y)-1 = X-1×Y-1 and the property of </P><P>transpose states that (XT )-1 = (X-1)T. Combining these two properties, the following equation represents a derivation of a matrix inversion using the Cholesky decomposition method: </P><P>A-1 = (L×LT)-1 
= (LT)-1 × L-1 
= (L-1)T × L-1 
</P><P>where a Cholesky decomposition function is needed to obtain L, a triangular matrix inversion is needed to obtain L-1, and a matrix multiplication is needed for (L-1)T × L-1. <Link>Figure 15–2</Link> shows the flow diagram of the matrix inversion. </P><P>Figure 15–2. Flow Diagram </P><P>Storage 1 Storage 2 </P><Figure><ImageData src="images/math_ip_altera_megafunctions_img_48.jpg"/>A A L L-1 L A(L ) Matrix A Cholesky Decomposition Triangular Matrix Inversion Matrix Multiplication -f X =T -1 L-1 </Figure></Sect><Sect/><P id="LinkTarget_7321">Cholesky Decomposition Function </P><Sect><P>The functions consists of two memory and two processing blocks. One of the memory blocks is the input matrix memory block and is loaded with the input matrix in a row order, one element at a time. However, during processing, this block is read in a column order, one element at a time when required. </P><P>The other memory block is the processing matrix block which consists of multiple column memories to enable an entire row to be read at once. During the loading of the input memory, the FPC datapath preprocesses the input elements to generate the first column of the resulting triangular matrix. The top element of the first column, l00, is the square root of the input matrix value a00. The rest of the first column, li0is the input value ai0 divided by l00. This preprocessing step introduces latency into the load, during which the INIT_BUSY signal is asserted. The CALCULATE signal initiates and starts processing after the INIT_BUSY signal is deasserted. </P><P><Link>Figure 15–3</Link> shows the top-level architecture of the Cholesky decomposition function, where the monolithic input memory and the column-wise processing memory, also known as the vector matrix, are shown. The gray block is the FPC datapath section. </P></Sect><P>Figure 15–3. Cholesky Decomposition Function Top-level Diagram </P><Figure><ImageData src="images/math_ip_altera_megafunctions_img_49.jpg"/></Figure><Sect><P>Although the Cholesky decomposition algorithm only operates on the lower triangular matrix, the core requires the entire matrix to be loaded, during which the processing or vector memory is initialized. </P></Sect><Sect><P>The FPC datapath is split into two sections. The first section, also known as the vector section, takes the inner product of two vectors and subtracts it from the input matrix element, aij. The second section, also known as the root section, calculates square roots and performs division by the square root. The first element is loaded into both inputs of the root section and the outcome is its own square root. The first element continues to stay latched in the left input field of the root section while all the other elements of the first column are loaded into the right input field. The resulting output is the value of the respective column element divided by the value of the first element of the Cholesky decomposition matrix. </P><P>During processing, two rows from the processing matrix are loaded. For the first element in each new column, both rows have the same index; hence contain the same values. The first row is latched into the input register of the vector section. For the rest of the column, the row index is increased, and a new aij element and triangular matrix vector, Lj is loaded. The first result out of the vector section is latched onto the left register of the root section. All results from the column, including the first result, are loaded into the right register of the root section. The root section generates the square root of the first vector result, while for the other results coming from the vector section, the number is divided by the square root of the first result. </P><P>All calculated values are written to another memory block for further processing. The first column values are output singly during preprocessing, while the values of other columns are burst out during processing. </P><P>There are only minor differences between the architectures for real and complex matrices. For the complex matrix, both the input and processing memory blocks contain complex values. Similarly, all values going into the vector section are complex numbers. The complex conjugate of the latched register is obtained by simply inverting the sign bit. As for the root section, the structure is simplified by the nature of the positive definite matrix. The diagonal value, which is the first value at the top of each column in the decomposition, is always a real number so that the result from the inverse square root calculation is always a real number. The complex multiplier in the root section is therefore a real scalar, so only two real multipliers are required. </P></Sect><P id="LinkTarget_7322">Triangular Matrix Inversion Algorithm </P><Sect><P>The triangular matrix, L, obtained from the Cholesky decomposition function is computed using the triangular matrix inversion algorithm to get its inversion. The following MatLab pseudo code shows how the inversion is carried out: </P><P>for j = n:-1:1,
  X(j,j) = 1/L(j, j);
  for k = j+1:n
</P><P> for i = j+1:n 
   X(k, j) = X(k, j) + X(k, i)*L(i, j);
</P><P> end;
  end;
  for k = j+1:n
</P><P> X(k, j) = -X(j, j)*X(k, j);
  end; 
</P></Sect><Sect><P>The pseudo code is converted into an RTL file. The result, L-1 is stored in the input matrix storage in the Cholesky decomposition function. </P></Sect><P id="LinkTarget_7323">Matrix Multiplication </P><Sect><P>The final stage of the matrix inversion process involves multiplying the transpose of the inverse triangular matrix with the inverse triangular matrix using the Altera Floating-Point Matrix Multiplier. The original version of the matrix multiplier is modified for this purpose. As there are memory blocks already available for the storage of the input matrices in the Cholesky decomposition function, the memory blocks in the matrix multiplier are redundant and can be removed. Data is instead fed directly from the results stored at the end stage of the triangular matrix inversion algorithm. </P></Sect><P id="LinkTarget_7324">Matrix Inversion Operation </P><Sect><P><Link>Figure 15–4</Link> shows the timing diagram for a matrix inversion operation. </P></Sect><P>Figure 15–4. Matrix Inversion Timing Diagram </P><Figure><ImageData src="images/math_ip_altera_megafunctions_img_50.jpg"/>sysclk enable reset load datain dataout outvalid busy done </Figure><Sect><P>Loading Stage Processing Stage Output Stage </P><P>The following sequence describes the matrix inversion operation: </P><L><LI><LI_Label>1. 	</LI_Label><LI_Title>The operation begins when the enable signal is asserted and the reset signal is deasserted. </LI_Title></LI><LI><LI_Label>2. 	</LI_Label><LI_Title>The load signal is asserted to load data from the loaddata[] port for the input matrix. As long as the load signal is high, data is loaded continuously for the input matrix. </LI_Title></LI><LI><LI_Label>3. 	</LI_Label><LI_Title>The busy signal is asserted and the done signal is deasserted for a few clock cycles after the datain[] signal is asserted. </LI_Title></LI><LI><LI_Label>4. 	</LI_Label><LI_Title>The outvalid signal is asserted multiple times to signify the availability of valid data on the dataout[] port. The number of times this signal is asserted equals the number of rows found in the output matrix. </LI_Title></LI><LI><LI_Label>5. 	</LI_Label><LI_Title>The busy and done signals are asserted when the last row of the output matrix has been burst out. This assertion signifies the end of the matrix inversion operation on the first set of data. </LI_Title></LI></L></Sect><P id="LinkTarget_7325">Design Example: Matrix Inverse of Single-Precision Format Numbers </P><Sect><P>This design example uses the ALTFP_MATRIX_INV megafunction to show the matrix inversion operation. The input matrix applied is an 8 × 8 matrix with a block size of 2. This example uses the MegaWizard Plug-In Manager in the Quartus II software. </P></Sect><P id="LinkTarget_7326">Design Files </P><Sect><P>The following files are related to the ALTFP_MATRIX_INV megafunction: </P><L><LI><LI_Label>■ </LI_Label><LI_Title>altfp_matrix_inv_DesignExample.zip (Quartus II design files) </LI_Title></LI><LI><LI_Label>■ </LI_Label><LI_Title>altfp_matrix_inv_ex_msim.zip (ModelSim-Altera files) </LI_Title></LI></L></Sect><P id="LinkTarget_7327">Understanding the Simulation Results </P><Sect><P><Link>Figure 15–5</Link> shows the expected simulation results in the ModelSim-Altera software. </P></Sect><P>1 	The simulation waveform in this design example is not shown in its entirety. Run the design example files in the ModelSim-Altera software to see the complete simulation waveforms. </P><P>Figure 15–5. ModelSim Simulation Waveform (Input Data) </P><Figure><ImageData src="images/math_ip_altera_megafunctions_img_51.jpg"/></Figure><Sect><P>This design example implements a floating-point matrix inversion to calculate the inverse value of matrices in single-precision formats. The optional input ports (enable and reset) are enabled. </P></Sect><Sect><P><Link>Table 15–3 on page 15–8 </Link>lists the inputs and corresponding outputs obtained from the simulation in <Link>Figure 15–5</Link>. The number of clock cycles obtained for each stage is based on the particular matrix size and parameter settings used in this design example. </P><P>Table 15–3. Summary of Input Values and Corresponding Outputs </P></Sect><Table><TR><TD>Time </TD><TD>Event </TD></TR><TR><TD>0 ns – 10 ns </TD><TD>Start sequence: ■ The reset signal deasserts. ■ The enable signal asserts. </TD></TR><TR><TD>19.86 ns – 340 ns </TD><TD>Matrix input data load: ■ The load signal asserts and remains high for 80 clock cycles. ■ As long as the load signal is high, data for the input matrix is loaded row by row. ■ Input data is burst in regularly, one at every clock cycle. ■ The load signal deasserts at 340 ns. The deassertion of the load signal signifies the completion of the data load operation for the matrix. </TD></TR><TR><TD>27.5 ns </TD><TD>Processing stage: ■ The busy signal asserts while the done signal deasserts. ■ The assertion of the busy signal and the deassertion of the done signal indicate that the matrix inversion core is processing the input data. ■ There are about 2500 clock cycles between the beginning of the processing stage and the first available output value. </TD></TR><TR><TD>12527.5 – 12922.5 ns </TD><TD>Output stage: ■ The outvalid signal asserts in intervals of 8 clock cycles. These series of assertions signify the availability of valid data for the output matrix on the outdata[] port. ■ The output is an 8 x 8 matrix. Data is burst out regularly, row by row. ■ At 12922.5 ns, the busy signal is asserted and the done signal is deasserted. ■ The assertion of the busy signal and the deassertion of the done signal indicate that the final output is written and a new matrix can be processed. </TD></TR></Table><P id="LinkTarget_7328">Sample Matrix Data </P><Sect><P>This section shows the random test data assigned to the input matrices and the results obtained from the matrix inversion operation. </P><P>The following two sets of results are computed: </P><L><LI><LI_Label>■ 	</LI_Label><LI_Title>PC-based results—these are results obtained from running the simulation in Matlab. </LI_Title></LI><LI><LI_Label>■ 	</LI_Label><LI_Title>FPGA-based results—these are results obtained from running the simulation in ModelSim. </LI_Title></LI></L></Sect><Sect><P><Link>Table 15–4 </Link>lists the input and output data values presented in IEEE-754 Floating-point format. </P></Sect><P>Table 15–4. Input and Output Data </P><Table><Caption><P>Chapter 15: ALTFP_MATRIX_INV 15–9 </P></Caption><TR><TH>Matrix </TH><TH/><TH/><TH>Data </TH><TH/><TH/></TR><TR><TD/><TD>40c89c6c  </TD><TD>40b16187 40e21dfb  40847306 </TD><TD>40c00d1d </TD><TD>40bbf0c4 </TD><TD>40be4fc1 40953a30 </TD></TR><TR><TD/><TD>40b16187 </TD><TD>41244acb   410e61b9  40defe3a  </TD><TD> 40f8e982 </TD><TD>40eff916 </TD><TD>410e0ff4  41121d78 </TD></TR><TR><TD/><TD>40e21dfb </TD><TD> 410e61b9 41217d87  40d7f5f4 </TD><TD>40fd78fa </TD><TD>410618c0 </TD><TD>41060327 40ff4517 </TD></TR><TR><TD>Input Matrix </TD><TD>40847306 </TD><TD>40defe3a   40d7f5f4 40b10427  </TD><TD>40b6be88  </TD><TD>40bbff4a </TD><TD>40d12685  40ca69f9 </TD></TR><TR><TD/><TD>40c00d1d </TD><TD>40f8e982  40fd78fa  40b6be88  </TD><TD>41146829  </TD><TD> 40ee188a  </TD><TD>40fa2d80  40cf065c </TD></TR><TR><TD/><TD>40bbf0c4  </TD><TD>40eff916 410618c0  40bbff4a </TD><TD> 40ee188a </TD><TD> 40ecbddf </TD><TD> 40e3aa3a 40d60773 </TD></TR><TR><TD/><TD>40be4fc1 </TD><TD>410e0ff4 41060327 40d12685 </TD><TD>40fa2d80  </TD><TD> 40e3aa3a  </TD><TD>4111ed09  40ecd83c </TD></TR><TR><TD/><TD>40953a30 </TD><TD>41121d78  40ff4517 40ca69f9  </TD><TD>40cf065c  </TD><TD>40d60773  </TD><TD> 40ecd83c 410847da </TD></TR><TR><TD/><TD>42148e03 </TD><TD>42f5794f  421b33f4  430e0587 </TD><TD>41ff0d66 </TD><TD> c2f579a3 </TD><TD>c2df1c28   c2f945bc </TD></TR><TR><TD/><TD>42f5794f </TD><TD>43d60be5  430944db  43f2dd63 </TD><TD>42da2dd0  </TD><TD> c3d1dd59 </TD><TD>c3bff960 c3d98c47 </TD></TR><TR><TD/><TD>421b33f4</TD><TD> 430944db 424b067c 43204d17 </TD><TD>421907da </TD><TD>c3107054  </TD><TD>c2fc035b   c30d24b3 </TD></TR><TR><TD>PC-based </TD><TD>430e0587 </TD><TD>43f2dd63  43204d17 440cc66b  </TD><TD> 43002bbb </TD><TD>c3f4e779  </TD><TD>c3dcd667   c3f7e3f3 </TD></TR><TR><TD>Output Matrix </TD><TD>41ff0d66 </TD><TD>42da2dd0  421907da  43002bbb </TD><TD>41f5048b </TD><TD> c2e44480  </TD><TD>c2c91e6d  c2df60c9 </TD></TR><TR><TD/><TD>c2f579a3 </TD><TD>c3d1dd59   c3107054 c3f4e779 </TD><TD>c2e44480  </TD><TD> 43d89b61 </TD><TD> 43c003b9 43d685d3 </TD></TR><TR><TD/><TD>c2df1c28 </TD><TD>c3bff960 c2fc035b    c3dcd667 </TD><TD> c2c91e6d  </TD><TD>43c003b9</TD><TD> 43ae19b0 43c37f99 </TD></TR><TR><TD/><TD>c2f945bc </TD><TD>c3d98c47   c30d24b3 c3f7e3f3  </TD><TD>c2df60c9  </TD><TD>43d685d3  </TD><TD>43c37f99  43ddb1bc </TD></TR><TR><TD/><TD>42148d06 </TD><TD>42f5773e  421b32c4   430e0484 </TD><TD>41ff0bb7 </TD><TD>c2f577f4 </TD><TD>c2df1a71  c2f943b1 </TD></TR><TR><TD/><TD>42f5773e</TD><TD> 43d609cf  430943a0 43f2db4a  </TD><TD>42da2c09   </TD><TD>c3d1db95  </TD><TD>c3bff79e c3d98a34 </TD></TR><TR><TD/><TD>421b32c4 </TD><TD>430943a0   424b0515 43204be2  </TD><TD> 421906da </TD><TD>c3106f53 </TD><TD>c2fc014f  c30d237c </TD></TR><TR><TD>FPGA-based </TD><TD>430e0484 </TD><TD>43f2db4a  43204be2   440cc563  </TD><TD>43002adf </TD><TD> c3f4e5c0 </TD><TD> c3dcd4a7   c3f7e1df </TD></TR><TR><TD>Output Matrix </TD><TD>41ff0bb7 </TD><TD>42da2c09   421906da 43002adf  </TD><TD>41f50322  </TD><TD>c2e44314  </TD><TD> c2c91cf5  c2df5f08 </TD></TR><TR><TD/><TD>c2f577f4 </TD><TD>c3d1db95   c3106f53  c3f4e5c0 </TD><TD> c2e44314 </TD><TD>43d899f3  </TD><TD>43c00242  43d68414 </TD></TR><TR><TD/><TD>c2df1a71 </TD><TD>c3bff79e c2fc014f c3dcd4a7  </TD><TD>  c2c91cf5</TD><TD> 43c00242 </TD><TD> 43ae1837 43c37dda </TD></TR><TR><TD/><TD>c2f943b1 </TD><TD> c3d98a34  c30d237c c3f7e1df  </TD><TD>c2df5f08 </TD><TD>43d68414  </TD><TD>43c37dda   43ddafad </TD></TR></Table><Sect><P>The difference between each result element of the PC-based and FPGA-based output matrices are as shown: Result differences (in decimal) 253 529  304  259  431  431   439   523 529 534  315  537  455  452   450   531 304 315  359  309  256  257   524     311 259 537  309  264  220  441   448   532 431 455  256  220  361  364   376   449 431 452  257  441  364  366   375   447 439 450  524  448  376  375   377   447 523 531  311 532   449  447  447  527 The difference between the two output matrices are due to the following reasons: </P></Sect><Sect><L><LI><LI_Label>■ 	</LI_Label><LI_Title>Method of processing—Matlab uses sequential processing while Modelsim uses parallel processing. </LI_Title></LI><LI><LI_Label>■ 	</LI_Label><LI_Title>Method of conversion—Matlab first computes in double-precision format, and then only converts the result into single-precision format. During this conversion, some units in the last place (ulp) are expected to be lost. </LI_Title></LI></L></Sect><P id="LinkTarget_7329">Specifications </P><Sect><P>This section describes the component declarations, ports, and parameters of the ALTFP_MATRIX_INV megafunction. The ports and parameters are available to customize the ALTFP_MATRIX_INV megafunction according to your application. </P></Sect><P>1 You must manually include the altfpc.v/vhd library file to your project. </P><P id="LinkTarget_7330">VHDL Component Declaration </P><Sect><P>The following VHDL component declaration is located in the VHDL Design File (.vhd) altera_mf_components.vhd in the &lt;Quartus II installation directory&gt;\libraries\vhdl\altera_mf directory. </P></Sect><P>component altfp_matrix_inv 
generic ( 
blocks : natural := 2; 
cluster : natural := 8; 
intended_device_family : string := &quot;unused&quot;; 
dimension : natural := 8; 
width_exp : natural := 8; 
width_man : natural := 23; 
lpm_hint : string := &quot;UNUSED&quot;; 
lpm_type : string := &quot;altfp_matrix_inv" 
); 
port( 
busy : out std_logic; 
datain : in std_logic_vector(width_exp+width_man+1-1 downto 0) := (others =&gt; '0'); 
dataout : out std_logic_vector(width_exp+width_man+1-1 downto 0); 
done : out std_logic; 
enable : in std_logic := '1'; 
load : in std_logic := '0'; 
outvalid : out std_logic; 
reset : in std_logic := '0'; 
sysclk : in std_logic 
); 
end component; 
</P><Sect/><P id="LinkTarget_7331">VHDL LIBRARY-USE Declaration </P><Sect><P>The VHDL LIBRARY-USE declaration is not required if you use the VHDL Component Declaration. </P><P>LIBRARY altera_mf; 
USE altera_mf_altera_mf_components.all; 
</P></Sect><P id="LinkTarget_7332">Ports and Parameters </P><Sect><P><Link>Table 15–5</Link> lists the input ports of the ALTFP_MATRIX_INV megafunction. </P></Sect><P>Table 15–5. ALTFP_MATRIX_INV Megafunction Input Ports </P><Table><TR><TH>Port Name </TH><TH>Required </TH><TH>Description </TH></TR><TR><TD>datain[] </TD><TD>Yes </TD><TD>Data input bus. A single-precision, 32-bit matrix input value. Matrices are loaded row by row. </TD></TR><TR><TD>enable </TD><TD>No </TD><TD>Clock enable. When asserted high, this signal allows calculation to take place. When this signal is deasserted low, no operation occurs and the outputs remain unchanged. </TD></TR><TR><TD>load </TD><TD>Yes </TD><TD>Control input. When asserted, the contents of the datain[]bus are loaded into the memory. </TD></TR><TR><TD>reset </TD><TD>No </TD><TD>Asynchronous reset. When asserted high, the core is asynchronously reset. </TD></TR><TR><TD>sysclk </TD><TD>Yes </TD><TD>The main system clock input port for the ALTFP_MATRIX_INV megafunction. All operations occur on the rising edge. </TD></TR></Table><Sect><P><Link>Table 15–6</Link> lists the output ports of the ALTFP_MATRIX_INV megafunction. </P></Sect><P>Table 15–6. ALTFP_MATRIX_INV Megafunction Output Ports </P><Table><TR><TH>Port Name </TH><TH>Required </TH><TH>Description </TH></TR><TR><TD>dataout[] </TD><TD>Yes </TD><TD>Data output bus. A single-precision, 32-bit matrix output bus. The result matrix is written out row by row. </TD></TR><TR><TD>busy </TD><TD>Yes </TD><TD>Handshaking signal. When asserted, the core is processing the input data. </TD></TR><TR><TD>done </TD><TD>Yes </TD><TD>Handshaking signal. When asserted, the last output has been written. </TD></TR><TR><TD>outvalid </TD><TD>Yes </TD><TD>Handshaking signal. When asserted, valid output data is available. An entire row of the result matrix is written out as a burst with a gap between each output row. </TD></TR></Table><Sect><P><Link>Table 15–7</Link> lists the parameters of the ALTFP_MATRIX_INV megafunction. </P></Sect><P>Table 15–7. ALTFP_MATRIX_INV Megafunction Parameters </P><Table><TR><TH>Port Name </TH><TH>Type </TH><TH>Required </TH><TH>Description </TH></TR><TR><TD>BLOCKS </TD><TD>Integer </TD><TD>No </TD><TD>The number of memory blocks for the double-buffered storage of matrix multiplication. The allowable range is from 2 to 16. </TD></TR><TR><TD>DIMENSION </TD><TD>Integer </TD><TD>Yes </TD><TD>The number of rows in the matrix. As the matrix is square, this is also the number of columns in the matrix. The maximum supported input dimension is 64 × 64. </TD></TR><TR><TD>WIDTH_EXP </TD><TD>Integer </TD><TD>Yes </TD><TD>Specifies the precision of the exponent. The bias of the exponent is always set to 2(WIDTH_EXP-1) -1 (that is, 127 for single-precision format). WIDTH_EXP must be 8 for single-precision format and must be less than WIDTH_MAN. The available value for WIDTH_EXP is 8. </TD></TR><TR><TD>WIDTH_MAN </TD><TD>Integer </TD><TD>Yes </TD><TD>Specifies the precision of the mantissa. WIDTH_MAN must be 23 when WIDTH_EXP is 8. Otherwise, WIDTH_MAN must be a minimum of 31. WIDTH_MAN must be greater than WIDTH_EXP. The available value for WIDTH_MAN is 23. </TD></TR></Table><Figure><ImageData src="images/math_ip_altera_megafunctions_img_52.jpg"/></Figure></Sect><Sect><Sect><H2 id="LinkTarget_7333">16. ALTFP_MATRIX_MULT 
</H2><P><Link>Figure 16–1</Link> shows the ports for the ALTFP_MATRIX_MULT megafunction. </P><P>Figure 16–1. ALTFP_MATRIX_MULT Ports </P><Figure><ImageData src="images/math_ip_altera_megafunctions_img_53.jpg"/>loaddata[] calcmatrix loadaa enable sysclk loadbbreset inst ALTFP_MATRIX_MULT outdata[] ready outvalid done </Figure><P id="LinkTarget_7334">Features </P><P>The ALTFP_MATRIX_INV megafunction offers the following features: </P><L><LI><LI_Label>■ </LI_Label><LI_Title>Multiplication of two matrices. </LI_Title></LI><LI><LI_Label>■ </LI_Label><LI_Title>Support for floating-point formats in single and double precisions. </LI_Title></LI><LI><LI_Label>■ </LI_Label><LI_Title>Support for VHDL and Verilog HDL languages. </LI_Title></LI><LI><LI_Label>■ </LI_Label><LI_Title>Support for complex numbers in single-precision format. </LI_Title></LI><LI><LI_Label>■ </LI_Label><LI_Title>Use of control signals: loadaa, loadbb, and calcmatrix. </LI_Title></LI><LI><LI_Label>■ </LI_Label><LI_Title>Use of handshaking signals: ready, outvalid, and done. </LI_Title></LI></L></Sect><P id="LinkTarget_7335">Output Latency </P><Sect><P>The ALTFP_MATRIX_MULT megafunction does not have a fixed output latency. Instead, it uses handshaking signals to interface with external circuitry. </P></Sect><P>16–2 Chapter 16: ALTFP_MATRIX_MULT </P><P>Resource Utilization and Performance </P><P>Resource Utilization and Performance </P><Sect><P><Link>Table 16–1</Link> and <Link>Table 16–2</Link> list the resource utilization and performance information for the ALTFP_MATRIX_MULT megafunction. The information was derived using the Quartus II software version 10.0. </P></Sect><P>Table 16–1. ALTFP_MATRIX_MULT Resource Utilization and Performance for the Stratix III Device Family </P><Table><TR><TH>Precision </TH><TH>MatrixAA Size </TH><TH>MatrixBB Size </TH><TH>Blocks </TH><TH>Vectorsize </TH><TH/><TH>Logic usage </TH><TH/><TH>Latency </TH><TH>Throughput (kb/s) </TH><TH>Giga Floating-Point Operations per Second (GFLOPS) </TH><TH>fMAX (MHz) </TH></TR><TR><TH>Adaptive Logic Modules (ALMs) </TH><TH>DSP Usage (18 x 18 DSPs) </TH><TH>M9K </TH><TH>M144K </TH><TH>Memory (Bits) </TH></TR><TR><TH>Single </TH><TD>8 × 8 </TD><TD>8 × 8 </TD><TD>2 </TD><TD>8 </TD><TD>3,698 </TD><TD>32 </TD><TD>22 </TD><TD>— </TD><TD>14,986 </TD><TD>209 </TD><TD>63,333 </TD><TD>6.20 </TD><TD>414 </TD></TR><TR><TD>16 × 16 </TD><TD>16 × 16 </TD><TD>2 </TD><TD>8 </TD><TD>3,992 </TD><TD>32 </TD><TD>20 </TD><TD>— </TD><TD>55,562 </TD><TD>611 </TD><TD>21,573 </TD><TD>6.18 </TD><TD>412 </TD></TR><TR><TD>32 × 32 </TD><TD>32 × 32 </TD><TD>4 </TD><TD>16 </TD><TD>7,173 </TD><TD>64 </TD><TD>61 </TD><TD>— </TD><TD>339,718 </TD><TD>2,172 </TD><TD>5,972 </TD><TD>12.57 </TD><TD>405 </TD></TR><TR><TD>64 × 64 </TD><TD>64 × 64 </TD><TD>8 </TD><TD>32 </TD><TD>13,803 </TD><TD>128 </TD><TD>41 </TD><TD>16 </TD><TD>2,382,318 </TD><TD>8,353 </TD><TD>1,454 </TD><TD>23.91 </TD><TD>380 </TD></TR><TR><TH>Double </TH><TD>8 × 8 </TD><TD>8 × 8 </TD><TD>2 </TD><TD>8 </TD><TD>9,026 </TD><TD>112 </TD><TD>34 </TD><TD>— </TD><TD>29,762 </TD><TD>213 </TD><TD>90,967 </TD><TD>4.54 </TD><TD>303 </TD></TR><TR><TD>16 × 16 </TD><TD>16 × 16 </TD><TD>2 </TD><TD>8 </TD><TD>9,234 </TD><TD>112 </TD><TD>39 </TD><TD>— </TD><TD>110,756 </TD><TD>615 </TD><TD>32,658 </TD><TD>4.71 </TD><TD>314 </TD></TR><TR><TD>32 × 32 </TD><TD>32 × 32 </TD><TD>4 </TD><TD>16 </TD><TD>18,142 </TD><TD>224 </TD><TD>109 </TD><TD>— </TD><TD>679,302 </TD><TD>2,178 </TD><TD>8,791 </TD><TD>9.27 </TD><TD>299 </TD></TR><TR><TD>64 × 64 </TD><TD>64 × 64 </TD><TD>8 </TD><TD>32 </TD><TD>35,839 </TD><TD>448 </TD><TD>77 </TD><TD>32 </TD><TD>4,765,120 </TD><TD>8,359 </TD><TD>2,176 </TD><TD>17.91 </TD><TD>284 </TD></TR><TR><TH>Single (Complex) </TH><TD>8 × 8 </TD><TD>8 × 8 </TD><TD>2 </TD><TD>8 </TD><TD>9,996 </TD><TD>128 </TD><TD>59 </TD><TD>— </TD><TD>22,666 </TD><TD>220 </TD><TD>114,411 </TD><TD>12.80 </TD><TD>413 </TD></TR><TR><TD>16 × 16 </TD><TD>16 × 16 </TD><TD>2 </TD><TD>8 </TD><TD>10,344 </TD><TD>128 </TD><TD>64 </TD><TD>— </TD><TD>79,139 </TD><TD>624 </TD><TD>39,743 </TD><TD>12.52 </TD><TD>404 </TD></TR><TR><TD>32 × 32 </TD><TD>32 × 32 </TD><TD>4 </TD><TD>16 </TD><TD>20,005 </TD><TD>256 </TD><TD>146 </TD><TD>— </TD><TD>420,519 </TD><TD>2,181 </TD><TD>10,937 </TD><TD>24.99 </TD><TD>397 </TD></TR><TR><TD>64 × 64 </TD><TD>64 × 64 </TD><TD>8 </TD><TD>32 </TD><TD>39,068 </TD><TD>512 </TD><TD>216 </TD><TD>16 </TD><TD>2,674,289 </TD><TD>8,362 </TD><TD>2,594 </TD><TD>45.68 </TD><TD>360 </TD></TR></Table><P id="LinkTarget_7336">Floating-Point Megafunctions User Guide November 2011 Altera Corporation </P><P>Resource Utilization and Performance </P><P>Table 16–2. ALTFP_MATRIX_MULT Resource Utilization and Performance for the Stratix IV Device Family </P><Table><TR><TH>Precision </TH><TH>MatrixAA Size </TH><TH>MatrixBB Size </TH><TH>Blocks </TH><TH>Vectorsize </TH><TH/><TH>Logic usage </TH><TH/><TH>Latency </TH><TH>Throughput (kb/s) </TH><TH>Giga Floating-Point Operations per Second (GFLOPS) </TH><TH>fMAX (MHz) </TH></TR><TR><TH>Adaptive Logic Modules (ALMs) </TH><TH>DSP Usage (18 x 18 DSPs) </TH><TH>M9K </TH><TH>M144K </TH><TH>Memory (Bits) </TH></TR><TR><TH>Single </TH><TD>8 × 8 </TD><TD>8 × 8 </TD><TD>2 </TD><TD>8 </TD><TD>3,367 </TD><TD>32 </TD><TD>26 </TD><TD>— </TD><TD>14,986 </TD><TD>209 </TD><TD>63,333 </TD><TD>6.30 </TD><TD>420 </TD></TR><TR><TD>16 × 16 </TD><TD>16 × 16 </TD><TD>2 </TD><TD>8 </TD><TD>3,585 </TD><TD>32 </TD><TD>27 </TD><TD>— </TD><TD>55,562 </TD><TD>611 </TD><TD>21,573 </TD><TD>6.32 </TD><TD>421 </TD></TR><TR><TD>32 × 32 </TD><TD>32 × 32 </TD><TD>4 </TD><TD>16 </TD><TD>6,301 </TD><TD>64 </TD><TD>76 </TD><TD>— </TD><TD>339,718 </TD><TD>2,172 </TD><TD>5,972 </TD><TD>13.00 </TD><TD>419 </TD></TR><TR><TD>64 × 64 </TD><TD>64 × 64 </TD><TD>8 </TD><TD>32 </TD><TD>11,822 </TD><TD>128 </TD><TD>80 </TD><TD>16 </TD><TD>2,382,318 </TD><TD>8,353 </TD><TD>1,454 </TD><TD>24.45 </TD><TD>388 </TD></TR><TR><TH>Double </TH><TD>8 × 8 </TD><TD>8 × 8 </TD><TD>2 </TD><TD>8 </TD><TD>9,026 </TD><TD>112 </TD><TD>34 </TD><TD>— </TD><TD>29,762 </TD><TD>213 </TD><TD>90,967 </TD><TD>4.54 </TD><TD>303 </TD></TR><TR><TD>16 × 16 </TD><TD>16 × 16 </TD><TD>2 </TD><TD>8 </TD><TD>9,234 </TD><TD>112 </TD><TD>39 </TD><TD>— </TD><TD>110,756 </TD><TD>615 </TD><TD>32,658 </TD><TD>4.71 </TD><TD>314 </TD></TR><TR><TD>32 × 32 </TD><TD>32 × 32 </TD><TD>4 </TD><TD>16 </TD><TD>18,142 </TD><TD>224 </TD><TD>109 </TD><TD>— </TD><TD>679,302 </TD><TD>2,178 </TD><TD>8,791 </TD><TD>9.27 </TD><TD>299 </TD></TR><TR><TD>64 × 64 </TD><TD>64 × 64 </TD><TD>8 </TD><TD>32 </TD><TD>35,839 </TD><TD>448 </TD><TD>77 </TD><TD>32 </TD><TD>4,765,120 </TD><TD>8,359 </TD><TD>2,176 </TD><TD>17.91 </TD><TD>284 </TD></TR><TR><TH>Single (Complex) </TH><TD>8 × 8 </TD><TD>8 × 8 </TD><TD>2 </TD><TD>8 </TD><TD>9,996 </TD><TD>128 </TD><TD>59 </TD><TD>— </TD><TD>22,666 </TD><TD>220 </TD><TD>114,411 </TD><TD>12.80 </TD><TD>413 </TD></TR><TR><TD>16 × 16 </TD><TD>16 × 16 </TD><TD>2 </TD><TD>8 </TD><TD>10,344 </TD><TD>128 </TD><TD>64 </TD><TD>— </TD><TD>79,139 </TD><TD>624 </TD><TD>39,743 </TD><TD>12.52 </TD><TD>404 </TD></TR><TR><TD>32 × 32 </TD><TD>32 × 32 </TD><TD>4 </TD><TD>16 </TD><TD>20,005 </TD><TD>256 </TD><TD>146 </TD><TD>— </TD><TD>420,519 </TD><TD>2,181 </TD><TD>10,937 </TD><TD>24.99 </TD><TD>397 </TD></TR><TR><TD>64 × 64 </TD><TD>64 × 64 </TD><TD>8 </TD><TD>32 </TD><TD>39,068 </TD><TD>512 </TD><TD>216 </TD><TD>16 </TD><TD>2,674,289 </TD><TD>8,362 </TD><TD>2,594 </TD><TD>45.68 </TD><TD>360 </TD></TR><Caption><P>Chapter 16: ALTFP_MATRIX_MULT 16–3 </P></Caption></Table><P>November 2011 Altera Corporation Floating-Point Megafunctions User Guide </P><Sect/><P id="LinkTarget_7337">Functional Description </P><Sect><P>The matrix multiplier in the ALTFP_MATRIX_INV megafunction multiplies two matrices: AA matrix and BB matrix. The cores for the real and complex matrices are almost identical. </P><P><Link>Figure 16–2</Link> shows the top-level view of the matrix multiplier block. The matrix multiplier block comprises the following components: </P><L><LI><LI_Label>■ </LI_Label><LI_Title>Memory blocks for the AA matrix storage </LI_Title></LI><LI><LI_Label>■ </LI_Label><LI_Title>Memory blocks for the BB matrix storage </LI_Title></LI><LI><LI_Label>■ </LI_Label><LI_Title>Local registers </LI_Title></LI><LI><LI_Label>■ </LI_Label><LI_Title>An FPC vector calculator unit </LI_Title></LI><LI><LI_Label>■ </LI_Label><LI_Title>Cache memories </LI_Title></LI><LI><LI_Label>■ </LI_Label><LI_Title>A parallel FPC adder unit </LI_Title></LI></L></Sect><P>Figure 16–2. Top-Level View of the Matrix Multiplier Block </P><Figure><ImageData src="images/math_ip_altera_megafunctions_img_54.jpg"/></Figure><Sect><P>The elements of the AA matrix are loaded from the memory blocks and stored in local registers before passed through to the FPC vector calculator along with the elements of the BB matrix from another set of memory blocks. The results obtained from multiplying these elements are written to the cache memories. When all the elements for a row are written to the cache, the parallel floating-point adder sums up the elements as the output matrix. The contents of the output matrix are then burst out on a row by row basis. </P></Sect><P id="LinkTarget_7338">AA and BB Matrix Storage </P><Sect><P>The AA and BB matrices are stored in M144K or M9K memory blocks. The Fitter tool in the Quartus II software assigns the type of memory to these matrices based on the available resources. </P><P>Each AA matrix location stores two consecutive words for the real matrix core and a single word for the complex core. Because the AA matrix is allocated with fewer memory blocks, it has less bandwidth compared to the BB matrix. You must expand the bandwidth of the AA matrix by storing multiple loads from the AA matrix in local registers. <Link>Figure 16–3 </Link>shows the logical storage of the AA and BB matrix vectors. </P><P>Figure 16–3. Logical Storage of the AA and BB Matrix Vectors</P><Table><TR><TD> A1</TD><TD> A2</TD><TD> A3</TD></TR><TR><TD> B1</TD><TD> B2</TD><TD> B3</TD></TR><TR><TD> C1</TD><TD> C2</TD><TD> C3 </TD></TR><TR><TD>D1 </TD><TD>D2 </TD><TD>D3</TD></TR></Table><Table><TR><TD> E3</TD><TD> E2 </TD><TD>E1 </TD></TR><TR><TD>F3</TD><TD> F2 </TD><TD>F1 </TD></TR><TR><TD>G3</TD><TD> G2 </TD><TD>G1</TD></TR></Table><P>For larger matrix sizes, the matrix data is split into several sections of equal widths. The number of elements in each section is also the width side. You can obtain the size of the width by dividing COLUMNSAA with VECTORSIZE. The sections in the AA matrix are known as sub-rows and the sections in the BB matrix are known as sub-columns. In <Link>Figure 16–3</Link>, the AA matrix has three sub-rows and the BB matrix has three sub-columns. </P><P>Vectors A1, A2, and A3 are the sub-rows of the first row of the AA matrix, while vectors E1, E2, and E3 are the sub-columns of the first column of the BB matrix. To load vector A1, you require multiple reads which are then held in local registers, while sub-column vectors E1, F1, and G1 are loaded from the BB matrix storage. These sub-column vectors from the BB matrix are loaded at one clock cycle per vector. </P><P>When a sub-column of the BB matrix is processed, the results are stored in the cache memory, and the AA matrix row index and BB matrix column index are increased by the VECTORSIZE value. Then, a new AA matrix sub-row and a BB matrix sub-column are loaded and processing starts. The results are once again stored in the cache memory, but in the next memory location. </P></Sect><Sect><P><Link>Figure 16–4</Link> shows the physical storage of the BB matrix. </P><P>Figure 16–4. Physical Storage of the BB Matrix </P><P>Address </P><P>0 </P><P>Vector </P><P>1</P><P>Index </P><P>2 </P><Table><TR><TD>0 </TD><TD>1 </TD><TD>2 </TD><TD>3 </TD><TD/></TR><TR><TD/><TD/><TD/><TD/><TD/></TR><TR><TD/><TD/><TD/><TD/><TD/></TR><TR><TD/><TD/><TD/><TD/><TD/></TR><TR><TD>E1 </TD><TD>E2 </TD><TD>E3 </TD><TD>E4 </TD><TD/></TR></Table><P>For a real matrix core, the number of memory blocks for the BB matrix is the same as the value of VECTORSIZE. For a complex matrix core, you need twice the number of memory blocks. These blocks are all read in parallel. The logical and physical storages for the BB matrix are different. </P><P>The entries for the BB matrix are written to the storage row by row, for example, Vector index 0/ Address 0, Vector index 0/ Address 3, Vector index 0/ Address 6, Vector index 1/ Address 0 and so on. The vectors are read in the following order: E1, F1, G1, E2 and so on, and the parallel access follows an address sequence of 0, 3, 6, 1, 4, 7, 2, 5, and 8. </P></Sect><P id="LinkTarget_7339">Cache Storage </P><Sect><P><Link>Figure 16–5</Link> shows the cache addressing scheme. </P><P>Figure 16–5. Cache Addressing Scheme </P><P>Cache Block 01 </P><P>0 Address 1 2 </P><Table><TR><TH>A1*E1 </TH></TR><TR><TH>A1*F1 </TH></TR><TR><TH>A1*G1 </TH></TR></Table><Table><TR><TH>A2*E2 </TH></TR><TR><TH>A2*F2 </TH></TR><TR><TH>A2*G2 </TH></TR></Table><P>The cache storage consists of memory blocks—one memory block for each real core and two for each complex core. There are six cache memories, which are written to sequentially but read from in parallel. </P><P>The depth of each cache memory is the same as the value of COLUMNSAA. In <Link>Figure 16–5</Link>, the cache memory has a depth of three. The number of cache memories used is determined by the number of iterations per element (COLUMNSAA/ VECTORSIZE). Any outputs from unused memories are zeroed. Cache memories are not double-buffered because the start of the memory is read before the writing of the partial vector products of the current matrix is complete. </P></Sect><Sect><P><Link>Figure 16–6</Link> shows that the first element in the result matrix is the sum of the vector products of A1*E1, A2*E2 and A3*E3. However, because of the bandwidth differences between the memory storages of the AA and BB matrices, the sequence of the vector operations is A1*E1, A1*F1, A1*G1, A2*E2, and so on. The products from these operations are stored in Cache 0/Address 0, Cache 0/Address 1, Cache 0/Address 2, and Cache 1/Address 0. </P><P>Figure 16–6. Output Element Components </P><Table><TR><TH>A1*E1+ </TH><TH>A1*F1+ </TH><TH>A1*G1+ </TH></TR><TR><TD>A2*E2+ </TD><TD>A2*F2+ </TD><TD>A2*G2+ </TD></TR><TR><TD>A3*E3 </TD><TD>A3*F3 </TD><TD>A3*G3 </TD></TR></Table><P>..... 
</P><P>......................... 
</P><P>After each cache memory is filled up, all six cache blocks are read in parallel, starting with address location 0. The contents from each cache block are then added and the results are burst out in an entire row to produce the output matrix. </P></Sect><P id="LinkTarget_7340">Matrix Multiplication Operation </P><Sect><P><Link>Figure 16–7</Link> shows the timing diagram for a single matrix multiplication operation. </P></Sect><P>Figure 16–7. Matrix Multiplication Timing Diagram </P><Figure><ImageData src="images/math_ip_altera_megafunctions_img_55.jpg"/>sysclk enable reset calcimatrix loadaa loadbb loaddata outdata outvalid ready done </Figure><Sect><P>Loading Stage Processing Stage Output Stage </P><P>The following sequence describes the matrix multiplication operation: </P><L><LI><LI_Label>1. 	</LI_Label><LI_Title>The operation begins when the enable signal asserts and the reset signal deasserts. </LI_Title></LI><LI><LI_Label>2. 	</LI_Label><LI_Title>The loadaa signal is asserted to load data from the loaddata[] port for the AA matrix. As long as the loadaa signal is high, data is loaded continuously for the AA matrix. </LI_Title></LI><LI><LI_Label>3. 	</LI_Label><LI_Title>The loadaa signal deasserts. </LI_Title></LI><LI><LI_Label>4. 	</LI_Label><LI_Title>The loadbb signal is asserted to load data from the loaddata[] port for the BB matrix. </LI_Title></LI><LI><LI_Label>5. 	</LI_Label><LI_Title>The calcmatrix signal is asserted for approximately one clock cycle. This assertion triggers the deassertion of the ready signal which indicates the start of the processing stage. </LI_Title></LI><LI><LI_Label>6. 	</LI_Label><LI_Title>The ready signal is asserted a few clock cycles later to allow data to load for a new set of matrix. </LI_Title></LI><LI><LI_Label>7. 	</LI_Label><LI_Title>The done signal deasserts. </LI_Title></LI><LI><LI_Label>8. 	</LI_Label><LI_Title>The outvalid signal is asserted multiple times to signify the availability of valid data on the outdata[] port. The number of times this signal is asserted equals the number of rows found in the output matrix. </LI_Title></LI><LI><LI_Label>9. 	</LI_Label><LI_Title>The done signal is asserted when the last row of the output matrix has been burst out. This assertion signifies the end of the matrix multiplication operation. </LI_Title></LI></L></Sect><Sect><P>For a best system performance, the cycles required to load a matrix set must be less than or equal to the number of cycles needed to multiply the matrix. This equation ensures that the core is able to process continuously without having to wait for the interface to catch up. Because the core usually takes a longer time to load than processing the matrix multiplication operation, the performance analysis are made in terms of: </P><P>System duty cycle = min(1, tprocess/tload) </P><P>The naïve number of operations is the number of elements in the result matrix multiplied by the number of operations required to calculate the element, or COLUMNSAA * 2, as the dot product calculation for every element involves a multiplication and an addition operation. For example: </P><P>tnaive = ROWSAA * COLUMNSBB * COLUMNSAA * 2 </P><P>The time to load the core is the same as the total number of elements in the two-input 
matrices, or 
tload = (COLUMNSAA * ROWSAA) + (COLUMNSAA * COLUMNSBB) 
The time to process a core depends on the following matrix size and core parameters: 
</P><L><LI><LI_Label>■ 	</LI_Label><LI_Title>There are ROWSAA rows to process. </LI_Title></LI><LI><LI_Label>■ 	</LI_Label><LI_Title>Each row consists of COLUMNSBB elements. </LI_Title></LI><LI><LI_Label>■ 	</LI_Label><LI_Title>Each element in the row requires COLUMNSAA/VECTORSIZE iterations to calculate. </LI_Title></LI><LI><LI_Label>■ </LI_Label><LI_Title>Each iteration requires VECTORSIZE/(2*BLOCKS) cycles to set up. Based on these requirements, the time to process is </LI_Title></LI></L><P>tprocess = ROWSAA * [COLUMNSBB * (COLUMNSAA/ VECTORSIZE) + (COLUMNSAA/ 
VECTORSIZE) * VECTORSIZE/(2*BLOCKS)] + LATENCYTOP + LATENCYBOT 
</P><P>or </P><P>tprocess = ROWSAA * COLUMNSAA/ VECTORSIZE * [COLUMNSBB + 
VECTORSIZE/(2*BLOCKS)] + LATENCYTOP + LATENCYBOT 
</P><P>The actual efficiency of the core is (tnaïve/VECTORSIZE * 2 * tprocess) * system duty cycle. </P></Sect><Sect><P>The following section provides examples to carry out the matrix multiplication operation. </P><P id="LinkTarget_7341">Example 1 </P><P>The AA matrix and the BB matrix have the following parameters: </P><L><LI><LI_Label>■ </LI_Label><LI_Title>COLUMNSAA = 64 </LI_Title></LI><LI><LI_Label>■ </LI_Label><LI_Title>ROWSAA = 20 </LI_Title></LI><LI><LI_Label>■ </LI_Label><LI_Title>COLUMNSBB = 15 </LI_Title></LI><LI><LI_Label>■ </LI_Label><LI_Title>VECTORSIZE = 32 </LI_Title></LI><LI><LI_Label>■ </LI_Label><LI_Title>BLOCKS = 4 tload = (64 * 20) + (64 * 15) = 2,240 clocks tprocess = 20 * (64 / 32) * [15 + 32 / (2 * 4)] + 41 + 24 = 825 clocks The system duty cycle is therefore, (825 / 2,240) = 0.37 tnaïve = 64 * 20 * 15 * 2 = 38,400 clocks Efficiency = [38,400 / (32 * 2 * 825)] * 0.37 = 27% For high performance, the matrix sizes must be closer to a square. </LI_Title></LI></L><P id="LinkTarget_7342">Example 2 </P><P>The AA matrix and the BB matrix have the following parameters: </P><L><LI><LI_Label>■ </LI_Label><LI_Title>COLUMNSAA = 192 </LI_Title></LI><LI><LI_Label>■ </LI_Label><LI_Title>ROWSAA = 192 </LI_Title></LI><LI><LI_Label>■ </LI_Label><LI_Title>COLUMNSBB = 192 </LI_Title></LI><LI><LI_Label>■ </LI_Label><LI_Title>VECTORSIZE = 96 </LI_Title></LI><LI><LI_Label>■ </LI_Label><LI_Title>BLOCKS = 24 tload = 2 * 192 * 192 = 73,728 blocks tprocess = 192 * (192 / 96) * [192 + 96 / (2 * 24)] + 51 + 24 = 74,571 clocks The system duty cycle is therefore, 74,571 / 73,728 = 1 tnaïve = 192 * 192 * 192 * 2 = 14,155,776 Efficiency = [14,155,776 / (96 * 2 * 74,571)] * 0.1 = 99% At a system speed of 250 MHz, the core has an equivalent performance of </LI_Title></LI></L><P>250 * 0.99 * 2 * 96 = 47.52 GFLOPs. </P></Sect><Sect/><P id="LinkTarget_7343">Design Example: Matrix Multiplication of Single-Precision Format Numbers </P><Sect><P>This design example uses the ALTFP_MATRIX_MULT megafunction to show the operation of a matrix multiplication. Matrix AA is a 10 × 8 matrix and matrix BB is an 8 × 12 matrix, with a vector size of 8 and a block size of 2. This example uses the MegaWizard Plug-In Manager in the Quartus II software. </P></Sect><P id="LinkTarget_7344">Design Files </P><Sect><P>The following files are related to the ALTFP_MATRIX_MULT megafunction: </P><L><LI><LI_Label>■ </LI_Label><LI_Title>altfp_matrix_mult_DesignExample.zip (Quartus II design files) </LI_Title></LI><LI><LI_Label>■ </LI_Label><LI_Title>altfp_matrix_mult_ex_msim.zip (ModelSim-Altera files) </LI_Title></LI></L></Sect><P id="LinkTarget_7345">Understanding the Simulation Results </P><Sect><P><Link>Figure 16–8</Link> shows the expected simulation results in the ModelSim-Altera software. </P></Sect><P>1 	The simulation waveform in this design example is not shown in its entirety. Run the design example files in the ModelSim-Altera software to see the complete simulation waveforms. </P><P>Figure 16–8. ModelSim Simulation Waveform </P><Figure><ImageData src="images/math_ip_altera_megafunctions_img_56.jpg"/></Figure><Sect><P>This design example implements a floating-point matrix multiplier to multiply the matrices of single-precision format numbers. The optional input ports (enable and reset) are enabled. </P></Sect><Sect><P><Link>Table 16–3</Link> lists the inputs and corresponding outputs obtained from the simulation in <Link>Figure 16–8</Link>. The number of clock cycles obtained for each stage is based on the particular matrix size and parameter settings used in this design example. </P><P>Table 16–3. Summary of Input Values and Corresponding Outputs (Part 1 of 2) </P></Sect><Table><TR><TD>Time </TD><TD>Event </TD></TR><TR><TD>0ns - 4.38ns </TD><TD>Start sequence: ■ The reset signal deasserts. ■ The enable signal asserts. </TD></TR><TR><TD>10 ns - 410 ns </TD><TD>AA matrix data load: ■ The loadaa signal asserts and remains high for 80 clock cycles. ■ As long as the loadaa signal is high, data for the AA matrix is loaded row by row. ■ Input data is burst in regularly, one at every clock cycle. ■ The loadaa signal deasserts at 410 ns. The deassertion of the loadaa signal signifies the completion of the data load operation for the AA matrix. </TD></TR><TR><TD>420 ns - 900 ns </TD><TD>BB matrix data load: ■ The loadbb signal asserts and remains high for 96 clock cycles. ■ As long as the loadbb signal is high, data for the BB matrix is loaded row by row. ■ Input data bursts in regularly, one at every clock cycle. ■ The loadbb signal deasserts at 900 ns. The deassertion of the loadbb signal signifies the completion of the data load operation for the BB matrix. </TD></TR></Table><Sect><P>Table 16–3. Summary of Input Values and Corresponding Outputs (Part 2 of 2) </P></Sect><Table><TR><TD>Time </TD><TD>Event </TD></TR><TR><TD>913.6 ns - 1197.5 ns </TD><TD>Processing stage: ■ As the ready signal is already high, the calcmatrix signal is asserted to start processing. ■ When the ready signal deasserts at 917.5ns, the calcmatrix signal is driven low. The calcmatrix signal must stay asserted for at least 1 clock cycle. ■ The done signal deasserts after the ready signal deasserts. ■ There are about 60 clock cycles between the beginning of the processing stage and the first available output value. </TD></TR><TR><TD>1212.5 ns - 1902.5 ns </TD><TD>Output stage: ■ The outvalid signal asserts in intervals of 12 clock cycles. These series of assertions signify the availability of valid data for the output matrix on the outdata[] port. ■ The output is a 10 x 12 matrix. Data is burst out regularly, row by row. ■ At 1622.5 ns, the ready signal is asserted. ■ The assertion of the ready signal indicates that the second set of matrices can be loaded into the device. ■ The done signal is asserted when the last result is output at 1902.5 ns. ■ The assertion of the done signal signifies that the final output is written and a new matrix can be processed. </TD></TR></Table><P id="LinkTarget_7346">Sample Matrix Data </P><Sect><P>This section shows the random test data assigned to the input matrices and the results obtained from the matrix multiplication operation. The AA matrix has a size of 3x8 while the BB matrix has a size of 8x4. The size of the output matrix is 3x4. </P><P>The following two sets of results are computed: </P><L><LI><LI_Label>■ 	</LI_Label><LI_Title>PC-based results—these are results obtained from running the simulation in Matlab. </LI_Title></LI><LI><LI_Label>■ 	</LI_Label><LI_Title>FPGA-based results—these are results obtained from running the simulation in ModelSim. </LI_Title></LI></L></Sect><Sect><P><Link>Table 16–4</Link> and <Link>Table 16–5 </Link>list the input and output data values presented in IEEE-754 floating-point format. </P></Sect><P>Table 16–4. Input Data </P><Table><TR><TH>Matrix </TH><TH/><TH/><TH>Data </TH><TH/><TH/></TR><TR><TD/><TD>d7b9dccb  </TD><TD>bf00bf94 d2ce148b  </TD><TD> b229d34b a9961b01   2baee57b  </TD><TD>3096e4fe </TD><TD>3e81f6c3 </TD></TR><TR><TD>AA Matrix </TD><TD>27b634ed </TD><TD>ca3d5dbd 39cbd182 </TD><TD>301f0dcc  ae0caf94   d8857477 </TD><TD>c4d01565  </TD><TD>333dde78 </TD></TR><TR><TD/><TD>c9a1d8e7  </TD><TD> 40497b4a 3d0bfbb9   </TD><TD> 3d65c2a2 c06a89bc   2b90460a  </TD><TD>d827e0f5 </TD><TD>b52648b3 </TD></TR><TR><TD>BB Matrix </TD><TD>4e88989a  379ee103  37829d4a bc2fd66b  </TD><TD>47f2bf4c  32a611d4  c6d3c2eb 3643fae1  5895695e   badcd4f4  b1aa321f  4d4772d9  </TD><TD>4a8dbc63 439f543d 3fb94cd7 d172efbf </TD><TD/><TD/></TR><TR><TD/><TD>4fe909c1 babc41e2  a95b24f4 </TD><TD>b31beb76  510d9d3a 2a8ee074  b01946a8  b6a48f75  b57e5b1a </TD><TD> c53cb578 364a842a b38e7776 </TD><TD/><TD/></TR></Table><P>Table 16–5. Output Data </P><Table><TR><TH>Matrix </TH><TH/><TH>Data </TH></TR><TR><TD>PC-based Output Matrix </TD><TD>e6c6582d  53c447c0  d8acb83f  </TD><TD>ebf08d8f 4e2fe2cd e2cdcec4  530a8962 491fce3f   cf8709ae  5622d027  d201144f  d4b35205 </TD></TR><TR><TD>FPGA-based Output Matrix </TD><TD>e6c6582e  53c447c0  d8acb83f </TD><TD>ebf08d8f 4e2fe2cc   e2cdcec4 530a8963 491fce3f  cf8709ae 5622d028  d201144f d4b35206 </TD></TR></Table><Sect><P>The difference between each result element of the PC-based and FPGA-based output matrices are as shown: Result differences (in decimal) 1 0 1 0 0 1 0 0 0 1 0 1 The difference between the two output matrices are due to the following reasons: </P><L><LI><LI_Label>■ 	</LI_Label><LI_Title>Method of processing—Matlab uses sequential processing while ModelSim-Altera software uses parallel processing. </LI_Title></LI><LI><LI_Label>■ 	</LI_Label><LI_Title>Method of conversion—Matlab first computes in double-precision format, and then only converts the result into single-precision format. During this conversion, some units in the last place (ulp) are expected to be lost. </LI_Title></LI></L></Sect><Sect/><P id="LinkTarget_7347">Specifications </P><Sect><P>This section describes the component declarations, ports, and parameters of the ALTFP_MATRIX_MULT megafunction. The ports and parameters are available to customize the ALTFP_MATRIX_MULT megafunction according to your application. </P></Sect><P>1 You must manually include the altfpc.v/vhd library file to your project. </P><P id="LinkTarget_7348">VHDL Component Declaration </P><Sect><P>The following VHDL component declaration is located in the VHDL Design File (.vhd) altera_mf_components.vhd in the &lt;Quartus II installation directory&gt;\libraries\vhdl\altera_mf directory. </P></Sect><P>component altfp_matrix_mult 
</P><P>generic (
   blocks : natural := 0;
   cluster : natural := 8;
   columnsaa : natural := 0;
   columnsbb : natural := 0;
   intended_device_family : string := &quot;unused&quot;;
   rowsaa : natural := 0;
   vectorsize : natural := 0;
   width_exp : natural := 8;
   width_man : natural := 23;
   lpm_hint : string := &quot;UNUSED&quot;;
   lpm_type : string := &quot;altfp_matrix_mult" 
</P><Sect><P>); 
</P></Sect><P>port(
   calcmatrix : in std_logic := '0';
   done : out std_logic;
   enable : in std_logic := '1';
   loadaa : in std_logic := '0';
   loadbb : in std_logic := '0';
</P><P>  loaddata : in std_logic_vector(width_exp+width_man+1-1 downto 0) := (others =&gt; '0');
   outdata : out std_logic_vector(width_exp+width_man+1-1 downto 0);
   outvalid : out std_logic;
   ready : out std_logic;
   reset : in std_logic := '0';
   sysclk : in std_logic 
</P><Sect><P>); 
end component; 
</P></Sect><Sect/><P id="LinkTarget_7349">VHDL LIBRARY-USE Declaration </P><Sect><P>The VHDL LIBRARY-USE declaration is not required if you use the VHDL Component Declaration. </P><P>LIBRARY altera_mf; 
USE altera_mf_altera_mf_components.all; 
</P></Sect><P id="LinkTarget_7350">Ports and Parameters </P><Sect><P><Link>Table 16–6</Link> lists the input ports of the ALTFP_MATRIX_MULT megafunction. </P></Sect><P>Table 16–6. ALTFP_MATRIX_MULT Megafunction Input Ports </P><Table><TR><TH>Port Name </TH><TH>Required </TH><TH>Description </TH></TR><TR><TD>sysclk </TD><TD>Yes </TD><TD>The clock input port for the ALTFP_MATRIX_MULT megafunction. </TD></TR><TR><TD>reset </TD><TD>No </TD><TD>Asynchronous reset. The ALTFP_MATRIX_MULT megafunction is asynchronously reset when the reset signal is asserted. </TD></TR><TR><TD>enable </TD><TD>No </TD><TD>Clock enable that allows calculation to take place when asserted. When this signal is deasserted, no operation occurs and the outputs remain unchanged. </TD></TR><TR><TD>calcmatrix </TD><TD>Yes </TD><TD>Control input. Asserted for at least one clock cycle to start processing of the matrices. </TD></TR><TR><TD>loadaa </TD><TD>Yes </TD><TD>Control input. When asserted, the megafunction loads the loaddata[] bus into the memory for the AA matrix. </TD></TR><TR><TD>loadbb </TD><TD>Yes </TD><TD>Control input. When asserted, the megafunction loads the loaddata[] bus into the memory for the BB matrix. </TD></TR><TR><TD>loaddata[] </TD><TD>Yes </TD><TD>Control input. 32-bit single-precision format or 64-bit double-precision format matrix input value. Matricies are loaded row by row. </TD></TR><TR><TD>loaddatareal[] </TD><TD>No </TD><TD>Data input for real values. 32-bit single-precision format, real value matrix input. Matrices are loaded row by row. This port must be declared when using the complex number mode. </TD></TR><TR><TD>loaddataimag[] </TD><TD>No </TD><TD>Data input for imaginary values. 32-bit single-precision format, imaginary value matrix input. Matrices are loaded row by row. This port must be declared when using the complex number mode. </TD></TR></Table><Sect><P><Link>Table 16–7</Link> lists the output ports of the ALTFP_MATRIX_MULT megafunction. </P></Sect><P>Table 16–7. ALTFP_MATRIX_MULT Megafunction Output Ports (Part 1 of 2) </P><Table><TR><TH>Port Name </TH><TH>Required </TH><TH>Description </TH></TR><TR><TD>outdata[] </TD><TD>Yes </TD><TD>Floating-point output result. 32-bit single-precision format or 64-bit double-precision format matrix output value. The result matrix is written out row by row. This port must be declared when using the normal number mode. </TD></TR><TR><TD>outdatareal[] </TD><TD>Yes </TD><TD>Data output for real result values. 32-bit single-precision format, real result value matrix output. Matrices are loaded row by row. This port must be declared when using the complex number mode. </TD></TR><TR><TD>outdataimag[] </TD><TD>Yes </TD><TD>Data output for real result values. 32-bit single-precision format, imaginary result value matrix output. Matrices are loaded row by row. This port must be declared when using the complex number mode. </TD></TR></Table><Sect/><P>Table 16–7. ALTFP_MATRIX_MULT Megafunction Output Ports (Part 2 of 2) </P><Table><TR><TH>Port Name </TH><TH>Required </TH><TH>Description </TH></TR><TR><TD>outvalid </TD><TD>Yes </TD><TD>Handshaking signal. When asserted, valid output data is available on the outdata[] port. An entire row of the result matrix is written out as a burst. There is a parameter-determined gap between the row outputs. </TD></TR><TR><TD>done </TD><TD>Yes </TD><TD>Handshaking signal. When asserted, the last output is written. A new matrix multiply can be started with the calcmatrix port. Deassertion of the done port follows assertion of the ready port by some fixed amount, depending on the parameters. </TD></TR><TR><TD>ready </TD><TD>Yes </TD><TD>Handshaking signal. When asserted, the core has completed reading both matrices for processing, and the loading of a new set of matrices can begin. After reset, a second pair of AA and BB matrices can be loaded, even if the readyport is low, after which the double buffer is full. Further matrix loads must wait for the ready port. </TD></TR></Table><Sect><P><Link>Table 16–8</Link> lists the parameters of the ALTFP_MATRIX_MULT megafunction. </P></Sect><P>Table 16–8. ALTFP_MATRIX_MULT Megafunction Parameters </P><Table><TR><TH>Port Name </TH><TH>Type </TH><TH>Required </TH><TH>Description </TH></TR><TR><TD>WIDTH_EXP </TD><TD>Integer </TD><TD>Yes </TD><TD>Specifies the precision of the exponent. If this parameter is not specified, the value is 8. The bias of the exponent is always set to 2(WIDTH_EXP - 1) -1, that is, 127 for the single-precision format and 1023 for the double-precision format. The value of WIDTH_EXP must be 8 for the single-precision format, 11 for the double-precision format, and a minimum of 11 for the single-extended precision format. The value of WIDTH_EXP must be less than the value of WIDTH_MAN, and the sum of WIDTH_EXP and WIDTH_MAN must be less than 64. </TD></TR><TR><TD>WIDTH_MAN </TD><TD>Integer </TD><TD>Yes </TD><TD>Specifies the precision of the mantissa. If this parameter is not specified, the default is 23. When WIDTH_EXP is 8 and the floating-point format is single-precision, the WIDTH_MAN value must be 23. Otherwise, the value of WIDTH_MAN must be a minimum of 31. The value of WIDTH_MAN must be greater than the value of WIDTH_EXP, and the sum of WIDTH_EXP and WIDTH_MAN must be less than 64. </TD></TR><TR><TD>COLUMNSAA </TD><TD>Integer </TD><TD>Yes </TD><TD>The number of columns in matrix AA, and therefore also the number of rows in matrix BB. This value must be an even multiple of 2 x BLOCKS. </TD></TR><TR><TD>ROWSAA </TD><TD>Integer </TD><TD>Yes </TD><TD>Number of rows in matrix AA. </TD></TR><TR><TD>COLUMNSBB </TD><TD>Integer </TD><TD>Yes </TD><TD>Number of columns in matrix BB. </TD></TR><TR><TD>BLOCKS </TD><TD>Integer </TD><TD>No </TD><TD>The number of M144 memory blocks for the double buffered storage of matrix AA. The allowable range is from 2to 48. </TD></TR><TR><TD>VECTORSIZE </TD><TD>String </TD><TD>No </TD><TD>The number of elements in the dot product core. The core library supports lengths of 8, 16, 32, 64, 96, and 128. </TD></TR></Table><Sect/><P id="LinkTarget_7351">Document Revision History </P><Sect><P><Link>Table 16–9</Link> lists the revision history for this user guide. </P><P>Table 16–9. Document Revision History </P></Sect><Table><TR><TH>Date </TH><TH>Document Version </TH><TH>Changes Made </TH></TR><TR><TD>November 2011 </TD><TD>6.0 </TD><TD><Link>Updated “General Features” on page 1–2. </Link></TD></TR><TR><TD>May 2011 </TD><TD>5.0 </TD><TD><Link>Added “ALTFP_ATAN” on page 10–1. </Link></TD></TR><TR><TD>January 2011 </TD><TD>4.0 </TD><TD><Link>Added “ALTFP_SINCOS” on page 11–1. </Link></TD></TR><TR><TD>July 2010 </TD><TD>3.0 </TD><TD><Link>■ Updated architecture information for the following sections: ■ ALTFP_MATRIX_MULT ■ ALTFP_MATRIX_INV. ■ Added specification information in all sections. </Link></TD></TR><TR><TD>November 2009 </TD><TD>2.0 </TD><TD><Link>■ Updated resource utilization information for the following sections: ■ ALTFP_ADD_SUB ■ ALTFP_DIV ■ ALTFP_MULT ■ ALTFP_SQRT ■ ALTFP_EXP ■ ALTFP_INV ■ ALTFP_INV_SQRT ■ ALTFP_LOG ■ ALTFP_COMPARE ■ ALTFP_CONVERT ■ ALTFP_MATRIX_MULT ■ Added the ALTFP_MATRIX_INV section. ■ Updated the Ports and Parameters section for all floating-point megafunctions. </Link></TD></TR><TR><TD>March 2009 </TD><TD>1.0 </TD><TD>Initial release. </TD></TR></Table></Sect></Sect></Part></TaggedPDF-doc>