<?xml version="1.0" encoding="UTF-8" ?><!-- Created from PDF via Acrobat SaveAsXML --><!-- Mapping Table version: 28-February-2003 --><TaggedPDF-doc><?xpacket begin='﻿' id='W5M0MpCehiHzreSzNTczkc9d'?><?xpacket begin="﻿" id="W5M0MpCehiHzreSzNTczkc9d"?>
<x:xmpmeta xmlns:x="adobe:ns:meta/" x:xmptk="Adobe XMP Core 5.2-c001 63.139439, 2010/09/27-13:37:26        ">
   <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
      <rdf:Description rdf:about=""
            xmlns:dc="http://purl.org/dc/elements/1.1/">
         <dc:format>xml</dc:format>
         <dc:creator>
            <rdf:Seq>
               <rdf:li>Tom Dillon</rdf:li>
            </rdf:Seq>
         </dc:creator>
      </rdf:Description>
      <rdf:Description rdf:about=""
            xmlns:xmp="http://ns.adobe.com/xap/1.0/">
         <xmp:CreateDate>2005-10-18T10:52:10-05:00</xmp:CreateDate>
         <xmp:CreatorTool>Writer</xmp:CreatorTool>
      </rdf:Description>
      <rdf:Description rdf:about=""
            xmlns:pdf="http://ns.adobe.com/pdf/1.3/">
         <pdf:Producer>OpenOffice.org 2.0</pdf:Producer>
      </rdf:Description>
   </rdf:RDF>
</x:xmpmeta>
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                           
<?xpacket end="w"?><?xpacket end='r'?><bookmark-tree><bookmark title="1 General Description"><destination structID="LinkTarget_148"/></bookmark><bookmark title="2 IEEE 754 Description"><destination structID="LinkTarget_149"/><bookmark title="2.1 Storage Layout"><destination structID="LinkTarget_150"/><bookmark title="2.1.1 The Sign Bit"><destination structID="LinkTarget_151"/></bookmark><bookmark title="2.1.2 The Exponent"><destination structID="LinkTarget_152"/></bookmark><bookmark title="2.1.3 The Mantissa"><destination structID="LinkTarget_153"/></bookmark></bookmark><bookmark title="2.2 Ranges of Floating-Point Numbers"><destination structID="LinkTarget_154"/></bookmark><bookmark title="2.3 Special Cases"><destination structID="LinkTarget_155"/><bookmark title="2.3.1 Zero"><destination structID="LinkTarget_156"/></bookmark><bookmark title="2.3.2 Infinity"><destination structID="LinkTarget_157"/></bookmark><bookmark title="2.3.3 Indeterminate"><destination structID="LinkTarget_158"/></bookmark><bookmark title="2.3.4 Not A Number"><destination structID="LinkTarget_159"/></bookmark></bookmark><bookmark title="2.4 Special Operations"><destination structID="LinkTarget_160"/></bookmark></bookmark><bookmark title="3 Module Descriptions"><destination structID="LinkTarget_161"/><bookmark title="3.1 Common Information"><destination structID="LinkTarget_162"/><bookmark title="3.1.1 Number Format"><destination structID="LinkTarget_163"/></bookmark><bookmark title="3.1.2 Special Case Status"><destination structID="LinkTarget_164"/></bookmark><bookmark title="3.1.3 Performance"><destination structID="LinkTarget_165"/></bookmark><bookmark title="3.1.4 SYNC_IN/SYNC_OUT"><destination structID="LinkTarget_166"/></bookmark><bookmark title="3.1.5 I/O Timing"><destination structID="LinkTarget_167"/></bookmark></bookmark><bookmark title="3.2 FpAdd/FpSub"><destination structID="LinkTarget_168"/><bookmark title="3.2.1 FpAdd Ports"><destination structID="LinkTarget_169"/></bookmark><bookmark title="3.2.2 Special Case Logic"><destination structID="LinkTarget_170"/></bookmark></bookmark><bookmark title="3.3 FpMult"><destination structID="LinkTarget_171"/><bookmark title="3.3.1 FpMult Ports"><destination structID="LinkTarget_172"/></bookmark><bookmark title="3.3.2 Special Case Logic"><destination structID="LinkTarget_173"/></bookmark></bookmark><bookmark title="3.4 FpDiv"><destination structID="LinkTarget_174"/><bookmark title="3.4.1 FpDiv Ports"><destination structID="LinkTarget_175"/></bookmark><bookmark title="3.4.2 Special Case Logic"><destination structID="LinkTarget_176"/></bookmark></bookmark><bookmark title="3.5 Int2Fp"><destination structID="LinkTarget_177"/><bookmark title="3.5.1 Int2Fp Ports"><destination structID="LinkTarget_178"/></bookmark><bookmark title="3.5.2 Special Case Logic"><destination structID="LinkTarget_179"/></bookmark></bookmark><bookmark title="3.6 Fp2Int"><destination structID="LinkTarget_180"/><bookmark title="3.6.1 Fp2Int Ports"><destination structID="LinkTarget_181"/></bookmark><bookmark title="3.6.2 Special Case Logic"><destination structID="LinkTarget_182"/></bookmark></bookmark><bookmark title="3.7 FpSqrt"><destination structID="LinkTarget_183"/><bookmark title="3.7.1 FpSqrt Ports"><destination structID="LinkTarget_184"/></bookmark><bookmark title="3.7.2 Special Case Logic"><destination structID="LinkTarget_185"/></bookmark></bookmark><bookmark title="3.8 FpRcp"><destination structID="LinkTarget_186"/><bookmark title="3.8.1 FpRcp Ports"><destination structID="LinkTarget_187"/></bookmark><bookmark title="3.8.2 Special Case Logic"><destination structID="LinkTarget_188"/></bookmark></bookmark><bookmark title="3.9 FpSplit"><destination structID="LinkTarget_189"/><bookmark title="3.9.1 FpSplit Ports"><destination structID="LinkTarget_190"/></bookmark><bookmark title="3.9.2 Special Case Logic"><destination structID="LinkTarget_191"/></bookmark></bookmark><bookmark title="3.10 FpCat"><destination structID="LinkTarget_192"/><bookmark title="3.10.1 FpCat Ports"><destination structID="LinkTarget_193"/></bookmark><bookmark title="3.10.2 Special Case Logic"><destination structID="LinkTarget_194"/></bookmark></bookmark><bookmark title="3.11 FpCmp"><destination structID="LinkTarget_195"/><bookmark title="3.11.1 FpCmp Ports"><destination structID="LinkTarget_196"/></bookmark><bookmark title="3.11.2 Special Case Logic"><destination structID="LinkTarget_197"/></bookmark></bookmark></bookmark><bookmark title="4 ParaCore Options"><destination structID="LinkTarget_198"/></bookmark><bookmark title="5 FPGA Area Usage"><destination structID="LinkTarget_199"/><bookmark title="5.1 Virtex II area Usage"><destination structID="LinkTarget_200"/></bookmark><bookmark title="5.2 Altera Area Usage"><destination structID="LinkTarget_201"/></bookmark></bookmark></bookmark-tree><Figure><ImageData src="images/fpu_ip_dillion_library_img_0.jpg"/></Figure><Part><H1>Dillon Engineering, Inc. 
</H1><P>3925West50thStreet,Suite202,Edina,MN 55424 Tel.:952-836-2413Fax:952-927-6514 www.di<Figure ActualText="l"><ImageData src="images/fpu_ip_dillion_library_img_1.jpg"/>ll</Figure>oneng.com </P><Sect><H2 id="LinkTarget_148">Floating Point Library IP Core 1 General Description </H2><L><LI><LI_Label>• </LI_Label><LI_Title>ParaCore ArchitectTM IP Core </LI_Title></LI><LI><LI_Label>• </LI_Label><LI_Title>Designed for IEEE 754 single and double precision math </LI_Title></LI><LI><LI_Label>• </LI_Label><LI_Title>Designed for custom precision, any exponent and mantissa width </LI_Title></LI><LI><LI_Label>• </LI_Label><LI_Title>Pipeline stages configurable via ParaCore parameters </LI_Title></LI><LI><LI_Label>• </LI_Label><LI_Title>Full IEEE 754 Special Case tracking </LI_Title></LI><LI><LI_Label>• </LI_Label><LI_Title>Parametric IP core for maximum flexibility </LI_Title></LI><LI><LI_Label>• </LI_Label><LI_Title>Available in generic HDL or targeted EDIF formats </LI_Title></LI><LI><LI_Label>• </LI_Label><LI_Title>Full test bench supplied </LI_Title></LI><LI><LI_Label>• </LI_Label><LI_Title>Greater than 200MHz operation in Xilinx Virtex II Pro </LI_Title></LI><LI><LI_Label>• </LI_Label><LI_Title>Accepts input data each clock cycle (pipelined version) </LI_Title></LI></L><P>The Dillon Engineering Floating Point Library IP Core (FPLIC) is a set of modules designed to perform all floating point math functions. The HDL representation of the FPLIC functions is generated with ParaCore Architect so it can be targeted to any device. </P><P>The floating point representation in the DE Floating point unit follows the IEEE 754 standards for both single and double precision. The floating point modules can be pipelined (depth customized) or can be left non-pipelined depending on the requirement. </P><P>FPLIC is designed to address the design challenges of digital signal processing in FPGA's today. It is the only floating point IP library that can be tailored made to meet exact needs of your application. </P><P>By optimizing the mantissa and exponents lengths for the target technology and application, tremendous gains in dynamic range and precision can be attained versus fixed point results with a minimal impact on device size and cost. </P><Sect><H2><Link>2 IEEE 754 Description </Link></H2><P>IEEE Standard 754 floating point is the most common representation today for real numbers on computers, including Intel-based PC's, Macintoshes, and most Unix platforms. </P><Sect><H4 id="LinkTarget_150">2.1 Storage Layout </H4><P>IEEE floating point numbers have three basic components: the sign, the exponent, and the mantissa. The exponent base (2) is implicit and need not be stored. </P><P>The following figure shows the layout for single (32-bit), double (64-bit) precision floating-point, and a custom precision example. The number of bits for each field are shown (bit ranges are in square brackets). </P><P>The custom size is shown as an example, any custom size is possible. </P><Table><TR><TH>F l o a t i n g P o i n t N u m b e r L a y o u t </TH><TH/></TR><TR><TH/><TD>Sign </TD><TD>Exponent </TD><TD>Mantissa </TD><TD>Bias </TD></TR><TR><TH>Single Precision </TH><TD>1 [31] </TD><TD>8 [30-23] </TD><TD>23 [22-00] </TD><TD>127 </TD></TR><TR><TH>Double Precision </TH><TD>1 [63] </TD><TD>11 [62-52] </TD><TD>52 [51-00] </TD><TD>1023 </TD></TR><TR><TH>Custom(e_width=6,m_w idth=16) </TH><TD>1 [22] </TD><TD>6 [21-16] </TD><TD>16 [15-0] </TD><TD>31 </TD></TR></Table><Sect><H4 id="LinkTarget_151">2.1.1 The Sign Bit </H4><P>Zero is a positive number; one is a negative number. Flipping the value of this bit flips the sign of the number. </P></Sect><Sect><H4 id="LinkTarget_152">2.1.2 The Exponent </H4><P>The exponent field needs to represent both positive and negative exponents. To do this, a bias is added to the actual exponent in order to get the stored exponent. For IEEE 754 single-precision floats, this value is 127. Thus, an exponent of zero means that 127 is stored in the exponent field. A stored value of 200 indicates an exponent of (200-127), or 73. For reasons discussed later, exponents of -127 (all zeros) and +128 (all ones) are reserved for special numbers. </P><P>For double precision, the exponent field is 11 bits, and has a bias of 1023. </P><P>For custom precision, the bias is (2**e_width)/2 – 1. </P></Sect><Sect><H4 id="LinkTarget_153">2.1.3 The Mantissa </H4><P>The mantissa represents the precision bits of the number. </P><P>Floating-point numbers are stored in normalized form. This puts the radix point after the first non-zero digit. </P><P>An optimization utilized by IEEE 754 is to discard the leading 1 and assume that it exists, saving 1 bit of storage. Thus, the mantissa has effectively 24 bits of resolution in single precision while only 23 bits are stored. </P><P>To summarize: </P><L><LI><LI_Label>• 	</LI_Label><LI_Title>The sign bit is 0 for positive, 1 for negative. </LI_Title></LI><LI><LI_Label>• 	</LI_Label><LI_Title>The exponent's base is two. </LI_Title></LI><LI><LI_Label>• 	</LI_Label><LI_Title>The exponent field contains 127 plus the true exponent for single-precision, or 1023 plus the true exponent for double precision. </LI_Title></LI><LI><LI_Label>• 	</LI_Label><LI_Title>The first bit of the mantissa is assumed to be 1, and is not stored explicitly. </LI_Title></LI></L></Sect></Sect><Sect><H4 id="LinkTarget_154">2.2 Ranges of Floating-Point Numbers </H4><P>The range of positive numbers is defined by the following table: </P><Table><TR><TD/><TD>Range </TD><TD>Decimal </TD></TR><TR><TD>Single Precision </TD><TD>2-126 to (2-2-23)x2127 </TD><TD>~10-37.93 to ~1038.53 </TD></TR><TR><TD>Double Precision </TD><TD>2-1022 to (2-2-52)x21023 </TD><TD>~10-307.65 to ~10308.25 </TD></TR><TR><TD>Custom (e_width=6, m_width=16) </TD><TD>2-30 to (2-2-16)x231 </TD><TD>~10-9.03 to ~109.63 </TD></TR></Table><P>Since the sign of floating point numbers is given by a special leading bit, the range for negative numbers is given by the negation of the above values. </P><P>There are five distinct numerical ranges that floating-point numbers are not able to represent (cases given relate to single precision): </P><L><LI><LI_Label>1. </LI_Label><LI_Title>Negative numbers less than -(2-2-23) x 2127 (negative overflow) </LI_Title></LI><LI><LI_Label>2. </LI_Label><LI_Title>Negative numbers greater than -2-126 (negative underflow) </LI_Title></LI><LI><LI_Label>3. </LI_Label><LI_Title>Zero </LI_Title></LI><LI><LI_Label>4. </LI_Label><LI_Title>Positive numbers less than 2-126 (positive underflow) </LI_Title></LI><LI><LI_Label>5. </LI_Label><LI_Title>Positive numbers greater than (2-2-23) x 2127 (positive overflow) </LI_Title></LI></L><P>Overflow means that values have grown too large for the representation, much in the same way that you can overflow integers. Underflow is a less serious problem because is just denotes a loss of precision, which is guaranteed to be closely approximated by zero. </P><P>Here's a table of the effective range (excluding infinite values) of IEEE floating-point numbers: </P><Table><TR><TD/><TD>Binary </TD><TD>Decimal </TD></TR><TR><TD>Single </TD><TD>± (2-2-23)x2127 </TD><TD>~ ± 1038.53 </TD></TR><TR><TD>Double </TD><TD>± (2-2-52)x21023 </TD><TD>~ ± 10308.25 </TD></TR><TR><TD>Custom (e_width=6, m_width=16) </TD><TD>± (2-2-16)x231 </TD><TD>~ ± 109.63 </TD></TR></Table><P>Notethattheextremevaluesoccur(regardlessofsign)whentheexponentisat s(2127f,21023f</P><P>themaximumvalueforfinitenumberorsingle-precisionordouble), andthemantissaisfi<Figure ActualText="l"><ImageData src="images/fpu_ip_dillion_library_img_2.jpg"/>ll</Figure>edwithones(includingthenormalizing1bit). </P></Sect><Sect><H4 id="LinkTarget_155">2.3 Special Cases </H4><P>IEEE 754 reserves exponent field values of all zeros and all ones to denote special cases in the floating-point scheme. </P><Sect><H4 id="LinkTarget_156">2.3.1 Zero </H4><P>Zero is a special value denoted with an exponent field of 0 and a mantissa of 0. Note that -0 and +0 are distinct values, though they both compare as equal. </P></Sect><Sect><H4 id="LinkTarget_157">2.3.2 Infinity </H4><P>The values +infinity and -infinity are denoted with an exponent of all ones and a mantissa of all zeros. The sign bit distinguishes between negative infinity and positive infinity. Being able to denote infinity as a specific value is useful because it allows operations to continue past overflow situations. </P></Sect><Sect><H4 id="LinkTarget_158">2.3.3 Indeterminate </H4><P>The value indeterminate is represented by an exponent of all ones, a mantissa with a leading one followed by all zeros, and a sign bit of one. This value is used to represent results that are indeterminate, such as (infinity -infinity), or (0 x infinity). </P></Sect><Sect><H4 id="LinkTarget_159">2.3.4 Not A Number </H4><P>Finally, the value NaN (NotaNumber) is used to represent a value that is an error of some form. This is is represented with an exponent field of all ones, a zero sign bit, and a non zero mantissa. This is a special value that might be used to denote a variable that doesn't yet hold a value. </P></Sect></Sect><Sect><H4 id="LinkTarget_160">2.4 Special Operations </H4><P>See the individual Fp module section for the special case logic for each of them. </P></Sect></Sect><Sect><H2 id="LinkTarget_161">3 Module Descriptions </H2><Sect><H3 id="LinkTarget_162">3.1 Common Information </H3><P>This section describes features that are common to all FPLIC modules. </P><Sect><H3 id="LinkTarget_163">3.1.1 Number Format </H3><P>The basic number format for all FPLIC numbers is &lt;sign&gt;&lt;exponent&gt;&lt;mantissa&gt;. The sign bit is always the MSB, followed by the exponent, and the the mantissa. Width of exponent and mantissa are customized when module is generated. </P></Sect><Sect><H3 id="LinkTarget_164">3.1.2 Special Case Status </H3><P>Standard special case tracking, with special cases encoded into all numbers as per IEEE 754, is supported by all modules that require the information. </P><P>All modules are built with special case status output ports (port_sp_out). This status port is defined by the following table: </P><Table><TR><TH>SP[3:0] Bits </TH><TH>Function </TH><TH>Description </TH></TR><TR><TD>'0001' </TD><TD>Zero </TD><TD>Number is zero. Sign bit in number also applies. </TD></TR><TR><TD>'0010' </TD><TD>INF </TD><TD>Infinity. Sign bit in number also applies. </TD></TR><TR><TD>'0100' </TD><TD>NAN </TD><TD>Not a number. </TD></TR><TR><TD>'1000' </TD><TD>IND </TD><TD>Indeterminate. </TD></TR></Table><P>If more than a single bit is set, then the number is set to indeterminate. 
IEEE 754 encodes this status information into the numbers as described in Section 
</P><P><Link>2. </Link>This is the default encoding for FPLIC numbers. </P></Sect><Sect><H3 id="LinkTarget_165">3.1.3 Performance </H3><P>The number of pipeline stages is customized when the module is generated. There is a trade off between pipeline stages, clock frequency and logic usage. Increasing the pipeline stages will increase the clock frequency and logic usage. Decreasing the pipeline stages decreases the clock frequency and logic usage. </P><P>The first pipeline stage is always applied to the output, the second to the input, and the remainder are internal pipelines. </P></Sect><Sect><H3 id="LinkTarget_166">3.1.4 SYNC_IN/SYNC_OUT </H3><P>Each module has an I/O pair that can be used to track the data through the pipeline stages. SYNC_OUT tracks SYNC_IN delayed by the number of pipeline stages the module in configured to have. If this feature is not used, then tie the SYNC_IN to 0. </P></Sect><Sect><H3 id="LinkTarget_167">3.1.5 I/O Timing </H3><P>In pipelined versions, all I/O is synchronous with port_clk with a input set on every block and an output on every clock following the pipeline delay. </P><P>Versions of each module are available that don't operate on continuous data, thus allowing logic reduction through logic sharing. </P></Sect></Sect><Sect><H3 id="LinkTarget_168">3.2 FpAdd/FpSub </H3><P>In the FpAdd (or FpSub) operation the exponents of the two numbers are compared with each other. The mantissa of the lesser of the exponents is shifted by the difference of the exponents. Then the two mantissa's are added and the resultant exponent is the greater of the two exponents. If a carry is produced, the exponent of the result is shifted to account for the carry which is produced. The sign of the resultant number is the sign of the greater number. </P><Sect><H3>3.2.1 FpAdd Ports 3.2.2 Special Case Logic </H3><Table><TR><TD/><TD/><TD>FpAdd/FpSub I/O Ports </TD></TR><TR><TD>Port </TD><TD>Dir </TD><TD>Function </TD></TR><TR><TD>port_a </TD><TD>In </TD><TD>Operand A. Operation is A+B (FpAdd) and A-B (FpSub) </TD></TR><TR><TD>port_b </TD><TD>In </TD><TD>Operand B. </TD></TR><TR><TD>port_sync_in </TD><TD>In </TD><TD>Input used to track the pipeline delay, does not effect math operation only used to create port_sync_out. </TD></TR><TR><TD>port_clk </TD><TD>In </TD><TD>Clock input, only used on pipelined versions. All I/O are synchronous to the clock. </TD></TR><TR><TD>port_x </TD><TD>Out </TD><TD>Result. </TD></TR><TR><TD>port_sync_out </TD><TD>Out </TD><TD>Delayed version of port_sync_in, delayed by pipeline depth. </TD></TR><TR><TD>port_sp_out </TD><TD>Out </TD><TD>Special case status for the result. </TD></TR></Table></Sect><Sect><P>Special case logic for the FpAdd/FpSub modules: </P><Table><TR><TH>FpAdd/FpSubSpecialCase Logic </TH></TR><TR><TH>Precedence </TH><TD>a </TD><TD>b </TD><TD>x </TD><TD>Notes </TD></TR><TR><TH>1 </TH><TD>NAN </TD><TD>any </TD><TD>NAN </TD><TD>“any” is any Fp number </TD></TR><TR><TH>1 </TH><TD>any </TD><TD>NAN </TD><TD>NAN </TD><TD/></TR><TR><TH>2 </TH><TD>IND </TD><TD>any </TD><TD>IND </TD><TD/></TR><TR><TH>2 </TH><TD>any </TD><TD>IND </TD><TD>IND </TD><TD/></TR><TR><TH>3 </TH><TD>±INF </TD><TD>any </TD><TD>INF </TD><TD>x.sign = a.sign </TD></TR><TR><TH>4 </TH><TD>any </TD><TD>±INF </TD><TD>INF </TD><TD>x.sign = !b.sign </TD></TR><TR><TH>5 </TH><TD>any </TD><TD>any </TD><TD>ZERO </TD><TD>Underflow, sign is 0. </TD></TR><TR><TH>5 </TH><TD>any </TD><TD>any </TD><TD>INF </TD><TD>Overflow, sign is 1 for negative overflow, 0 for positive. </TD></TR><TR><TH>5 </TH><TD>any </TD><TD>any </TD><TD>a±b </TD><TD>Valid result </TD></TR></Table></Sect></Sect><Sect><H3 id="LinkTarget_171">3.3 FpMult </H3><P>In the FpMult operation, the exponents of the two numbers are added and the result of this becomes the resultant exponent. The mantissa's are multiplied together to produce the resultant mantissa. The exponent is adjusted appropriately after the mantissa is normalized. </P><Sect><H3>3.3.1 FpMult Ports 3.3.2 Special Case Logic </H3><Table><TR><TH/><TH/><TH>FpMultI/OPorts </TH></TR><TR><TD>Port </TD><TD>Dir </TD><TD>Function </TD></TR><TR><TD>port_a </TD><TD>In </TD><TD>Operand A. </TD></TR><TR><TD>port_b </TD><TD>In </TD><TD>Operand B. </TD></TR><TR><TD>port_sync_in </TD><TD>In </TD><TD>Input used to track the pipeline delay, does not effect math operation only used to create port_sync_out. </TD></TR></Table><Table><TR><TH/><TH/><TH>FpMultI/OPorts </TH></TR><TR><TD>Port </TD><TD>Dir </TD><TD>Function </TD></TR><TR><TD>port_clk </TD><TD>In </TD><TD>Clock input, only used on pipelined versions. All I/O are synchronous to the clock. </TD></TR><TR><TD>port_x </TD><TD>Out </TD><TD>Result. </TD></TR><TR><TD>port_sync_out </TD><TD>Out </TD><TD>Delayed version of port_sync_in, delayed by pipeline depth. </TD></TR><TR><TD>port_sp_out </TD><TD>Out </TD><TD>Special case status for the result. </TD></TR></Table></Sect><Sect><P>Special case logic for the FpMult modules: </P><Table><TR><TH/><TH>FpMultSpecialCase Logic </TH></TR><TR><TD>Precedence </TD><TD>a </TD><TD>b </TD><TD>x </TD><TD>Notes </TD></TR><TR><TD>1 </TD><TD>IND </TD><TD>any </TD><TD>IND </TD><TD>“any” is any Fp number </TD></TR><TR><TD>1 </TD><TD>any </TD><TD>IND </TD><TD>IND </TD><TD/></TR><TR><TD>2 </TD><TD>NAN </TD><TD>any </TD><TD>NAN </TD><TD/></TR><TR><TD>2 </TD><TD>any </TD><TD>NAN </TD><TD>NAN </TD><TD/></TR><TR><TD>3 </TD><TD>±INF </TD><TD>any </TD><TD>INF </TD><TD>x.sign = a.sign ^ b.sign </TD></TR><TR><TD>4 </TD><TD>any </TD><TD>±INF </TD><TD>INF </TD><TD>x.sign = a.sign ^ b.sign </TD></TR><TR><TD>5 </TD><TD>any </TD><TD>any </TD><TD>ZERO </TD><TD>Underflow, sign is 0. </TD></TR><TR><TD>5 </TD><TD>any </TD><TD>any </TD><TD>INF </TD><TD>Overflow, x.sign = a.sign ^ b.sign </TD></TR><TR><TD>5 </TD><TD>any </TD><TD>any </TD><TD>a*b </TD><TD>Valid result </TD></TR></Table></Sect></Sect><Sect><H3 id="LinkTarget_174">3.4 FpDiv </H3><P>The FpDiv in FPLIC is done using the Goldschmidt's Algorithm. In this algorithm the result of the division is calculated by multiplying the numerator and denominator with a series of approximations for the reciprocal of the denominator. The mantissa of the numerator is divided by the mantissa of the denominator in this fashion. The resultant exponent is the difference between the exponents of the numerator and the denominator. </P><P id="LinkTarget_175">3.4.1 FpDiv Ports 
</P><Table><TR><TH/><TH/><TH>FpDivI/OPorts </TH></TR><TR><TD>Port </TD><TD>Dir </TD><TD>Function </TD></TR><TR><TD>port_a </TD><TD>In </TD><TD>Operand A. Operation is A/B. </TD></TR><TR><TD>port_b </TD><TD>In </TD><TD>Operand B. </TD></TR><TR><TD>port_sync_in </TD><TD>In </TD><TD>Input used to track the pipeline delay, does not effect math operation only used to create port_sync_out. </TD></TR><TR><TD>port_clk </TD><TD>In </TD><TD>Clock input, only used on pipelined versions. All I/O are synchronous to the clock. </TD></TR><TR><TD>port_x </TD><TD>Out </TD><TD>Result. </TD></TR><TR><TD>port_sync_out </TD><TD>Out </TD><TD>Delayed version of port_sync_in, delayed by pipeline depth. </TD></TR><TR><TD>port_sp_out </TD><TD>Out </TD><TD>Special case status for the result. </TD></TR></Table><Sect><H3 id="LinkTarget_176">3.4.2 Special Case Logic </H3><P>Special case logic for the FpDiv modules: </P><Table><TR><TH/><TH>FpDivSpecialCase Logic </TH></TR><TR><TD>Precedence </TD><TD>a </TD><TD>b </TD><TD>x </TD><TD>Notes </TD></TR><TR><TD>1 </TD><TD>NAN </TD><TD>any </TD><TD>NAN </TD><TD>“any” is any Fp number </TD></TR><TR><TD>1 </TD><TD>any </TD><TD>NAN </TD><TD>NAN </TD><TD/></TR><TR><TD>2 </TD><TD>IND </TD><TD>any </TD><TD>IND </TD><TD/></TR><TR><TD>2 </TD><TD>any </TD><TD>IND </TD><TD>IND </TD><TD/></TR><TR><TD>3 </TD><TD>any </TD><TD>±ZERO </TD><TD>INF </TD><TD>x.sign = a.sign ^ b.sign </TD></TR><TR><TD>4 </TD><TD>±ZERO </TD><TD>any </TD><TD>ZERO </TD><TD>x.sign = a.sign ^ b.sign </TD></TR><TR><TD>5 </TD><TD>any </TD><TD>±INF </TD><TD>ZERO </TD><TD>x.sign = a.sign ^ b.sign </TD></TR><TR><TD>5 </TD><TD>±INF </TD><TD>any </TD><TD>INF </TD><TD>x.sign = a.sign ^ b.sign </TD></TR><TR><TD>6 </TD><TD>any </TD><TD>any </TD><TD>ZERO </TD><TD>Underflow, sign is 0. </TD></TR><TR><TD>6 </TD><TD>any </TD><TD>any </TD><TD>INF </TD><TD>Overflow, x.sign = a.sign ^ b.sign </TD></TR></Table><Table><TR><TH/><TH/><TH>FpDiv Special Case Logic </TH></TR><TR><TD>6 </TD><TD>any </TD><TD/><TD>any </TD><TD>a*b </TD><TD>Valid result </TD></TR></Table></Sect></Sect><Sect><H3 id="LinkTarget_177">3.5 Int2Fp </H3><P>Int2Fp takes a integer and converts it to a floating point number. The width of the integer and size of floating point number are customized when the module is generated. </P><P>The preprocessing takes the two's complement of a negative number and keeps track of the sign bit. The positive integer is normalized so that the most significant 1 becomes the hidden bit and the exponent is set to reflect the number of shifts. </P><P id="LinkTarget_178">3.5.1 Int2Fp Ports </P><Table><TR><TH/><TH/><TH>In2Fp I/O Ports </TH></TR><TR><TD>P o r t </TD><TD>D i r </TD><TD>F u nct i o n </TD></TR><TR><TD>port_a </TD><TD>In </TD><TD>Integer input. </TD></TR><TR><TD>port_sync_in </TD><TD>In </TD><TD>Input used to track the pipeline delay, does not effect math operation only used to create port_sync_out. </TD></TR><TR><TD>port_clk </TD><TD>In </TD><TD>Clock input, only used on pipelined versions. All I/O are synchronous to the clock. </TD></TR><TR><TD>port_x </TD><TD>Out </TD><TD>Floating point output. </TD></TR><TR><TD>port_sync_out </TD><TD>Out </TD><TD>Delayed version of port_sync_in, delayed by pipeline depth. </TD></TR></Table><Sect><H3 id="LinkTarget_179">3.5.2 Special Case Logic </H3><P>No special cases for this module. </P></Sect></Sect><Sect><H3 id="LinkTarget_180">3.6 Fp2Int </H3><P>Fp2Int takes as input a floating point number and convert it to an integer. </P><P>The conversion barrel shifts the mantissa using the exponent and integer width to set the shift amount, then post processes the shifted result to encode the special cases. </P><P id="LinkTarget_181">3.6.1 Fp2Int Ports 
</P><Table><TR><TH/><TH/><TH>Fp2IntI/OPorts </TH></TR><TR><TD>Port </TD><TD>Dir </TD><TD>Function </TD></TR><TR><TD>port_a </TD><TD>In </TD><TD>Floating point input. </TD></TR><TR><TD>port_sync_in </TD><TD>In </TD><TD>Input used to track the pipeline delay, does not effect math operation only used to create port_sync_out. </TD></TR><TR><TD>port_sp_a </TD><TD>In </TD><TD>Special case status for operand A. </TD></TR><TR><TD>port_clk </TD><TD>In </TD><TD>Clock input, only used on pipelined versions. All I/O are synchronous to the clock. </TD></TR><TR><TD>port_x </TD><TD>Out </TD><TD>Integer output. </TD></TR><TR><TD>port_sync_out </TD><TD>Out </TD><TD>Delayed version of port_sync_in, delayed by pipeline depth. </TD></TR><TR><TD>port_oflow </TD><TD>Out </TD><TD>Indicates Fp number was too big for integer. </TD></TR></Table><Sect><H3 id="LinkTarget_182">3.6.2 Special Case Logic </H3><P>No special cases for this module. </P></Sect></Sect><Sect><H3 id="LinkTarget_183">3.7 FpSqrt </H3><P>The FpSqrt (square root) in FPLIC is done using the restoring shift/subtract algorithm. In this algorithm the result of the square root operation is calculated by multiplying the series of approximations for the root of reciprocal of the number. </P><Sect><H3>3.7.1 FpSqrt Ports 3.7.2 Special Case Logic </H3><Table><TR><TH/><TH/><TH>FpSqrtI/OPorts </TH></TR><TR><TD>Port </TD><TD>Dir </TD><TD>Function </TD></TR><TR><TD>port_a </TD><TD>In </TD><TD>Operand A, radicand. </TD></TR><TR><TD>port_sync_in </TD><TD>In </TD><TD>Input used to track the pipeline delay, does not effect math operation only used to create port_sync_out. </TD></TR><TR><TD>port_clk </TD><TD>In </TD><TD>Clock input, only used on pipelined versions. All I/O are synchronous to the clock. </TD></TR><TR><TD>port_x </TD><TD>Out </TD><TD>Result square root. </TD></TR></Table><Table><TR><TH/><TH/><TH>FpSqrtI/OPorts </TH></TR><TR><TD>Port </TD><TD>Dir </TD><TD>Function </TD></TR><TR><TD>port_sync_out </TD><TD>Out </TD><TD>Delayed version of port_sync_in, delayed by pipeline depth. </TD></TR><TR><TD>port_sp_out </TD><TD>Out </TD><TD>Special case status for the result. </TD></TR></Table></Sect><Sect><P>Special case logic for the FpSqrt modules: </P><Table><TR><TH/><TH>FpSqrtSpecialCase Logic </TH></TR><TR><TD>Precedence </TD><TD>a </TD><TD>x </TD><TD>Notes </TD></TR><TR><TD>1 </TD><TD>NAN </TD><TD>NAN </TD><TD/></TR><TR><TD>2 </TD><TD>IND </TD><TD>IND </TD><TD/></TR><TR><TD>3 </TD><TD>-any </TD><TD>IND </TD><TD>Negative input produces IND </TD></TR><TR><TD>4 </TD><TD>INF </TD><TD>IND </TD><TD/></TR><TR><TD>5 </TD><TD>any </TD><TD>a </TD><TD>Valid result </TD></TR></Table></Sect></Sect><Sect><H3 id="LinkTarget_186">3.8 FpRcp </H3><P>The FpRcp in FPLIC is done using the Goldschmidt's Algorithm. In this algorithm the result of the division is calculated by multiplying the numerator and denominator with a series of approximations for the reciprocal of the denominator. The mantissa of the numerator is divided by the mantissa of the denominator in this fashion. The resultant exponent is the difference between the exponents of the numerator and the denominator. </P><Sect><H3>3.8.1 FpRcp Ports 3.8.2 Special Case Logic </H3><Table><TR><TH/><TH/><TH>FpRcpI/OPorts </TH></TR><TR><TD>Port </TD><TD>Dir </TD><TD>Function </TD></TR><TR><TD>port_a </TD><TD>In </TD><TD>Operand A. </TD></TR><TR><TD>port_sync_in </TD><TD>In </TD><TD>Input used to track the pipeline delay, does not effect math operation only used to create port_sync_out. </TD></TR><TR><TD>port_clk </TD><TD>In </TD><TD>Clock input, only used on pipelined versions. All I/O are synchronous to the clock. </TD></TR><TR><TD>port_x </TD><TD>Out </TD><TD>Result. </TD></TR><TR><TD>port_sync_out </TD><TD>Out </TD><TD>Delayed version of port_sync_in, delayed by pipeline depth. </TD></TR><TR><TD>port_sp_out </TD><TD>Out </TD><TD>Special case status for the result. </TD></TR></Table></Sect><Sect><P>Special case logic for the FpRcp modules: </P><Table><TR><TH/><TH>FpRcpSpecialCase Logic </TH></TR><TR><TD>Precedence </TD><TD>a </TD><TD>x </TD><TD>Notes </TD></TR><TR><TD>1 </TD><TD>NAN </TD><TD>NAN </TD><TD>“any” is any Fp number </TD></TR><TR><TD>2 </TD><TD>IND </TD><TD>IND </TD><TD/></TR><TR><TD>3 </TD><TD>±INF </TD><TD>ZERO </TD><TD>x.sign = a.sign ^ b.sign </TD></TR><TR><TD>4 </TD><TD>±ZERO </TD><TD>INF </TD><TD>x.sign = a.sign ^ b.sign </TD></TR><TR><TD>5 </TD><TD>any </TD><TD>1/ a </TD><TD>Valud result </TD></TR></Table></Sect></Sect><Sect><H3 id="LinkTarget_189">3.9 FpSplit </H3><P>FpSplit is used to split a Fp number into the sign, exponent and mantissa. </P><Sect><H3>3.9.1 FpSplit Ports 3.9.2 Special Case Logic </H3><Table><TR><TH/><TH/><TH>FpRcpI/OPorts </TH></TR><TR><TD>Port </TD><TD>Dir </TD><TD>Function </TD></TR><TR><TD>port_fp </TD><TD>In </TD><TD>Fp number to be split. </TD></TR><TR><TD>port_sign </TD><TD>Out </TD><TD>Sign of Fp number. </TD></TR><TR><TD>port_exp </TD><TD>Out </TD><TD>Exponent of Fp number. </TD></TR><TR><TD>port_man </TD><TD>Out </TD><TD>Mantissa of Fp number. </TD></TR></Table></Sect><Sect><P>No special cases for this module. </P></Sect></Sect><Sect><H3 id="LinkTarget_192">3.10 FpCat </H3><P>The FpCat module is used to construct a Fp vector from the sign, exponent and mantissa. </P><P id="LinkTarget_193">3.10.1 FpCat Ports </P><Table><TR><TH/><TH/><TH>FpCatI/OPorts </TH></TR><TR><TD>Port </TD><TD>Dir </TD><TD>Function </TD></TR><TR><TD>port_sign </TD><TD>In </TD><TD>Sign input </TD></TR><TR><TD>port_exp </TD><TD>In </TD><TD>Expoent </TD></TR><TR><TD>port_man </TD><TD>In </TD><TD>mantissa </TD></TR><TR><TD>port_fp </TD><TD>Out </TD><TD>Floating point number concatinated from the sign, exp, and man. </TD></TR></Table><Sect><H3 id="LinkTarget_194">3.10.2 Special Case Logic </H3><P>No special cases for this module. </P></Sect></Sect><Sect><H3 id="LinkTarget_195">3.11 FpCmp </H3><P>The FpCmp is used to compare two Fp numbers, eq (equal), gt (greater than), lt (less than) and er (error) are produced. </P><Sect><H3 id="LinkTarget_196">3.11.1 FpCmp Ports </H3><Table><TR><TH/><TH/><TH>FpCmpI/OPorts </TH></TR><TR><TD>Port </TD><TD>Dir </TD><TD>Function </TD></TR><TR><TD>port_a </TD><TD>In </TD><TD>Operand A. </TD></TR><TR><TD>port_b </TD><TD>In </TD><TD>Operand B. </TD></TR><TR><TD>port_clk </TD><TD>In </TD><TD>clock </TD></TR><TR><TD>port_er </TD><TD>Out </TD><TD>Error, a or b IND or NAN </TD></TR><TR><TD>port_eq </TD><TD>Out </TD><TD>A == B is True </TD></TR><TR><TD>port_gt </TD><TD>Out </TD><TD>A &gt; B is True </TD></TR><TR><TD>port_lt </TD><TD>Out </TD><TD>A &lt; B is True </TD></TR></Table></Sect><Sect><H3 id="LinkTarget_197">3.11.2 Special Case Logic </H3><P>No special cases for this module. </P></Sect></Sect></Sect><Sect><H2 id="LinkTarget_198">4 ParaCore Options </H2><P>The DE FPLIC is very flexible since it was designed using ParaCore Architect. All configuration parameters are used to customize the module when it is generated. </P><P>The parameters for all Math operations are similar and defined by the following table. </P><Table><TR><TH/><TH>Math Operation Parameters </TH></TR><TR><TD>Parameter </TD><TD>Type </TD><TD>Description </TD></TR><TR><TD>exp_width </TD><TD>integer </TD><TD>Sets the exponent width for a floating point I/O to the module. </TD></TR><TR><TD>man_width </TD><TD>integer </TD><TD>Sets the mantissa width for a floating point I/O to the module. </TD></TR><TR><TD>width </TD><TD>integer </TD><TD>Set the integer width for any integer I/O of the module. </TD></TR><TR><TD>stages </TD><TD>integer </TD><TD>Defines the number of pipeline stages in the module. Stage == 0 is valid and results in a completely combinatorial module (clk is connected but not used). Stages &gt; 15 is valid but will not increase the clock frequency of the module. </TD></TR></Table><P>All modules are built by and delivered to the clients specifications. Bit accurate C models are available for all modules. </P></Sect><Sect><H2 id="LinkTarget_199">5 FPGA Area Usage </H2><P>The following section give a few samples of area usage in a couple of FPGA technologies. </P><Sect><H3 id="LinkTarget_200">5.1 Virtex II area Usage </H3><P>The following is the area used by the FPLIC in a Virtex II FPGA. Units are in slices with mult18x18s in parenthesis if used. </P><Table><TR><TH/><TH>Virtex II Area Usage (Slice) </TH></TR><TR><TD>Function </TD><TD>Single Precision </TD><TD>Double Precision </TD><TD>e_width=6,m_width=16 </TD></TR><TR><TD>FpAdd/FpSub </TD><TD>525 </TD><TD>3100 </TD><TD>503 </TD></TR><TR><TD>FpMult </TD><TD>141 (4) </TD><TD>458 (9) </TD><TD>79 (1) </TD></TR><TR><TD>FpDiv </TD><TD>1200 (28) </TD><TD>4600 (112) </TD><TD>465 </TD></TR></Table></Sect><Sect><H3 id="LinkTarget_201">5.2 Altera Area Usage </H3><P>The following is the area used by the FPLIC in Altera Apex FPGAs. </P><Table><TR><TH/><TH>Apex Usage (Slice) </TH><TH/></TR><TR><TD>Function </TD><TD>Single Precision </TD><TD>Double Precision </TD><TD/><TD>e_width=6,m_width=16 </TD></TR><TR><TD>FpAdd/FpSub </TD><TD>1673 </TD><TD>6742 </TD><TD/><TD>1022 </TD></TR><TR><TD>FpMult </TD><TD>1360 </TD><TD>6009 </TD><TD/><TD>737 </TD></TR><TR><TD>FpDiv </TD><TD>12397 </TD><TD>55178 </TD><TD/><TD>7410 </TD></TR></Table></Sect></Sect></Sect></Part></TaggedPDF-doc>