<?xml version="1.0" encoding="UTF-8" ?><!-- Created from PDF via Acrobat SaveAsXML --><!-- Mapping Table version: 28-February-2003 --><TaggedPDF-doc><?xpacket begin='﻿' id='W5M0MpCehiHzreSzNTczkc9d'?><?xpacket begin="﻿" id="W5M0MpCehiHzreSzNTczkc9d"?>
<x:xmpmeta xmlns:x="adobe:ns:meta/" x:xmptk="Adobe XMP Core 5.2-c001 63.139439, 2010/09/27-13:37:26        ">
   <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
      <rdf:Description rdf:about=""
            xmlns:xmp="http://ns.adobe.com/xap/1.0/">
         <xmp:CreateDate>2004-09-13T04:34:28-08:00</xmp:CreateDate>
         <xmp:ModifyDate>2004-09-13T04:34:28-08:00</xmp:ModifyDate>
      </rdf:Description>
      <rdf:Description rdf:about=""
            xmlns:pdf="http://ns.adobe.com/pdf/1.3/">
         <pdf:Producer>iText by lowagie.com (r1.02b;p128)</pdf:Producer>
      </rdf:Description>
      <rdf:Description rdf:about=""
            xmlns:dc="http://purl.org/dc/elements/1.1/">
         <dc:format>xml</dc:format>
      </rdf:Description>
   </rdf:RDF>
</x:xmpmeta>
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                           
<?xpacket end="w"?><?xpacket end='r'?><Figure><ImageData src=""/></Figure><Part><H3>80C187 
80-BIT MATH COPROCESSOR 
</H3><Sect><P>Y 	High Performance 80-Bit Internal Architecture </P><P>Y 	Implements ANSI/IEEE Standard 7541985 for Binary Floating-Point Arithmetic </P><P>Y 	Upward Object-Code Compatible from 8087 </P><P>Y 	Fully Compatible with 387DX and 387SX Math Coprocessors. Implements all 387 Architectural Enhancements over 8087 </P><P>Y 	Directly Interfaces with 80C186 CPU </P><P>Y 	80C186/80C187 Provide a Software/ Binary Compatible Upgrade from 80186/82188/8087 Systems </P><P>Y 	Expands 80C186’s Data Types to Include 32-, 64-, 80-Bit Floating-Point, 32-, 64-Bit Integers and 18-Digit BCD Operands </P><P>Y 	Directly Extends 80C186’s Instruction Set to Trigonometric, Logarithmic, Exponential, and Arithmetic Instructions for All Data Types </P><P>Y 	Full-Range Transcendental Operations for SINE, COSINE, TANGENT, ARCTANGENT, and LOGARITHM </P><P>Y 	Built-In Exception Handling </P><P>Y 	Eight 80-Bit Numeric Registers, Usable as Individually Addressable General Registers or as a Register Stack </P><P>Y 	Available in 40-Pin CERDIP and 44-Pin PLCC Package (See Packaging Outlines and Dimensions, Order #231369) </P></Sect><P>The Intel 80C187 is a high-performance math coprocessor that extends the architecture of the 80C186 with floating-point, extended integer, and BCD data types. A computing system that includes the 80C187 fully conforms to the IEEE Floating-Point Standard. The 80C187 adds over seventy mnemonics to the instruction set of the 80C186, including support for arithmetic, logarithmic, exponential, and trigonometric mathematical operations. The 80C187 is implemented with 1.5 micron, high-speed CHMOS III technology and packaged in both a 40-pin CERDIP and a 44-pin PLCC package. The 80C187 is upward object-code compatible from the 8087 math coprocessor and will execute code written for the 80387DX and 80387SX math coprocessors. </P><P>*Other brands and names are the property of their respective owners. 
Information in this document is provided in connection with Intel products. Intel assumes no liability whatsoever, including infringement of any patent or 
copyright, for sale and use of Intel products except as provided in Intel’s Terms and Conditions of Sale for such products. Intel retains the right to make 
changes to these specifications at any time, without notice. Microcomputer Products may have minor variations to this specification known as errata. 
</P><P>COPYRIGHT ©INTEL CORPORATION, 1995 November 1992 	Order Number: 270640-004 </P><Sect><Figure><ImageData src=""/></Figure></Sect><Figure><ImageData src="images/math_ic_intel_80c187_1989_img_2.jpg"/>270640–1 </Figure><P>Figure 1. 80C187 Block Diagram </P><Sect><Figure><ImageData src=""/></Figure></Sect><P>80C187 Data Registers </P><P>7978 6463 0 </P><Sect><P>R0 </P><P>R1 </P><P>R2 </P><P>R3 </P><P>R4 </P><P>R5 </P><P>R6 </P><P>R7 </P></Sect><Table><TR><TH>SIGN </TH><TH>EXPONENT </TH><TH>SIGNIFICAND </TH></TR><TR><TD/><TD/><TD/></TR><TR><TD/><TD/><TD/></TR><TR><TD/><TD/><TD/></TR><TR><TD/><TD/><TD/></TR><TR><TD/><TD/><TD/></TR><TR><TD/><TD/><TD/></TR><TR><TD/><TD/><TD/></TR></Table><P>150 15 0 INSTRUCTION POINTER DATA POINTER </P><Sect><Table><TR><TH>CONTROL REGISTER </TH></TR><TR><TH>STATUS REGISTER </TH></TR><TR><TH>TAG WORD </TH></TR></Table></Sect><P>Figure 2. Register Set </P><Sect><P>FUNCTIONAL DESCRIPTION </P><P>The 80C187 Math Coprocessor provides arithmetic instructions for a variety of numeric data types. It also executes numerous built-in transcendental functions (e.g. tangent, sine, cosine, and log functions). The 80C187 effectively extends the register and instruction set of the 80C186 CPU for existing data types and adds several new data types as well. Figure2 shows the additional registers visible to programs in a system that includes the 80C187. Essentially, the 80C187 can be treated as an additional resource or an extension to the CPU. The 80C186 CPU together with an 80C187 can be used as a single unified system. </P><P>A 80C186 system that includes the 80C187 is completely upward compatible with software for the 8086/8087. </P><P>The 80C187 interfaces only with the 80C186 CPU. The interface hardware for the 80C187 is not implemented on the 80C188. </P><P>PROGRAMMING INTERFACE </P><P>The 80C187 adds to the CPU additional data types, registers, instructions, and interrupts specifically designed to facilitate high-speed numerics processing. All new instructions and data types are directly supported by the assembler and compilers for high-level languages. The 80C187 also supports the full 80387DX instruction set. </P><P>All communication between the CPU and the 80C187 is transparent to applications software. The CPU automatically controls the 80C187 whenever a numerics instruction is executed. All physical memory and virtual memory of the CPU are available for storage of the instructions and operands of programs that use the 80C187. All memory addressing modes are available for addressing numerics operands. </P><P>The end of this data sheet lists by class the instructions that the 80C187 adds to the instruction set. </P><P>NOTE: The 80C187 Math Coprocessor is also referred to as a Numeric Processor Extension (NPX) in this document. </P><P>Data Types </P><P>Table 1 lists the seven data types that the 80C187 supports and presents the format for each type. Operands are stored in memory with the least significant digit at the lowest memory address. Programs retrieve these values by generating the lowest address. For maximum system performance, all operands should start at even physical-memory addresses; operands may begin at odd addresses, but will require extra memory cycles to access the entire operand. </P><P>Internally, the 80C187 holds all numbers in the extended-precision real format. Instructions that load operands from memory automatically convert operands represented in memory as 16-, 32-, or 64-bit integers, 32-or 64-bit floating-point numbers, or 18digit packed BCD numbers into extended-precision real format. Instructions that store operands in memory perform the inverse type conversion. </P><Figure><ImageData src=""/></Figure><P>Numeric Operands </P><P>A typical NPX instruction accepts one or two operands and produces one (or sometimes two) results. In two-operand instructions, one operand is the contents of an NPX register, while the other may be a memory location. The operands of some instructions are predefined; for example, FSQRT always takes the square root of the number in the top stack element (refer to the section on Data Registers). </P><P>Register Set </P><P>Figure 2 shows the 80C187 register set. When an 80C187 is present in a system, programmers may use these registers in addition to the registers normally available on the CPU. </P><P>DATA REGISTERS </P><P>80C187 computations use the extended-precision real data type. </P></Sect><P>Table 1. Data Type Representation in Memory </P><Figure><ImageData src="images/math_ic_intel_80c187_1989_img_5.jpg"/></Figure><Sect><P>270640 –2 </P><P>NOTES: </P></Sect><L><Sect><LI><LI_Label>1. </LI_Label><LI_Title>S e Sign bit (0 e Positive, 1 e Negative) </LI_Title></LI><LI><LI_Label>2. </LI_Label><LI_Title>dn e Decimal digit (two per byte) </LI_Title></LI></Sect><LI><LI_Label>3. </LI_Label><LI_Title>X e Bits have no significance; 80C187 ignores when loading, zeros when storing </LI_Title></LI><Sect><LI><LI_Label>4. </LI_Label><LI_Title>U e Position of implicit binary point </LI_Title></LI></Sect><LI><LI_Label>5. </LI_Label><LI_Title>I e Integer bit of significand; stored in temporary real, implicit in single and double precision </LI_Title></LI><Sect><LI><LI_Label>6. </LI_Label><LI_Title>Exponent Bias (normalized values): Single: 127 (7FH) Double: 1023 (3FFH) Extended Real: 16383 (3FFFH) </LI_Title></LI><LI><LI_Label>7. </LI_Label><LI_Title>Packed BCD:(b1)S(D17 ...D0) </LI_Title></LI><LI><LI_Label>8. </LI_Label><LI_Title>Real:(b1)S (2E-BIAS)(F0,F1 ...) </LI_Title></LI></Sect></L><Sect><Figure><ImageData src=""/></Figure><P>The 80C187 register set can be accessed either as a stack, with instructions operating on the top one or two stack elements, or as individually addressable registers. The TOP field in the status word identifies the current top-of-stack register. A ‘‘push’’ operation decrements TOP by one and loads a value into the new top register.A ‘‘pop’’ operation stores the value from the current top register and then increments TOP by one. The 80C187 register stack grows ‘‘down’’ toward lower-addressed registers. </P><P>Instructions may address the data registers either implicitly or explicitly. Many instructions operate on the register at the TOP of the stack. These instructions implicitly address the register at which TOP points. Other instructions allow the programmer to explicitly specify which register to use. This explicit addressing is also relative to TOP. </P><P>TAG WORD </P><P>The tag word marks the content of each numeric data register, as Figure 3 shows. Each two-bit tag represents one of the eight data registers. The principal function of the tag word is to optimize the NPX’s performance and stack handling by making it possible to distinguish between empty and nonempty register locations. It also enables exception handlers to identify special values (e.g. NaNs or denormals) in the contents of a stack location without the need to perform complex decoding of the actual data. </P><P>STATUS WORD </P><P>The 16-bit status word (in the status register) shown in Figure4 reflects the overall state of the 80C187. It may be read and inspected by programs. </P><P>Bit 15, the B-bit (busy bit) is included for 8087 compatibility only. It always has the same value as the ES bit (bit 7 of the status word); it does not indicate the status of the BUSY output of 80C187. </P><P>Bits 13 –11 (TOP) point to the 80C187 register that is the current top-of-stack. </P><P>The four numeric condition code bits (C3–C0) are similar to the flags in a CPU; instructions that perform arithmetic operations update these bits to reflect the outcome. The effects of these instructions on the condition code are summarized in Tables 2 through 5. </P><P>Bit 7 is the error summary (ES) status bit. This bit is set if any unmasked exception bit is set; it is clear otherwise. If this bit is set, the ERROR signal is asserted. </P><P>Bit 6 is the stack flag (SF). This bit is used to distinguish invalid operations due to stack overflow or underflow from other kinds of invalid operations. When SF is set, bit 9 (C1) distinguishes between stack overflow (C1 e 1) and underflow (C1 e 0). </P><P>Figure 4 shows the six exception flags in bits 5 –0 of the status word. Bits 5 –0 are set to indicate that the 80C187 has detected an exception while executing an instruction. A later section entitled ‘‘Exception Handling’’ explains how they are set and used. </P><P>Note that when a new value is loaded into the status word by the FLDENV or FRSTOR instruction, the value of ES (bit 7) and its reflection in the B-bit (bit 15) are not derived from the values loaded from memory but rather are dependent upon the values of the exception flags (bits 5 –0)in the status word and their corresponding masks in the control word. If ES is set in such a case, the ERROR output of the 80C187 is activated immediately. </P></Sect><Figure><ImageData src="images/math_ic_intel_80c187_1989_img_7.jpg"/>15 0 TAG (7) TAG (6) TAG (5) TAG (4) TAG (3) TAG (2) TAG (1) TAG (0) NOTE: The index i of tag(i) is not top-relative. A program typically uses the ‘‘top’’ field of Status Word to determine which tag(i) field refers to logical top of stack. TAG VALUES: 00 e Valid 01 e Zero 10 e QNaN, SNaN, Infinity, Denormal and Unsupported Formats 11 e Empty </Figure><P>Figure 3. Tag Word </P><Sect><Figure><ImageData src=""/></Figure></Sect><Figure><ImageData src="images/math_ic_intel_80c187_1989_img_9.jpg"/></Figure><P>270640 –3 ES is set if any unmasked exception bit is set; cleared otherwise. See Table 2 for interpretation of condition code. TOP values: </P><P>000 e Register 0 is Top of Stack 
001 e Register 1 is Top of Stack
</P><Sect><P> 
 
 
</P></Sect><P>111 e Register 7 is Top of Stack For definitions of exceptions, refer to the section entitled, ‘‘Exception Handling’’ </P><P>Figure 4. Status Word </P><Sect><Figure><ImageData src=""/></Figure><P>CONTROL WORD </P></Sect><P>The NPX provides several processing options that are selected by loading a control word from memory into the control register. Figure 5 shows the format and encoding of fields in the control word. </P><P>Table 2. Condition Code Interpretation </P><Table><TR><TH>Instruction </TH><TH>C0(S) </TH><TH>C3(Z) </TH><TH>C1(A) </TH><TH>C2(C) </TH></TR><TR><TD>FPREM, FPREM1 (See Table 3) </TD><TD>Three Least Significant Bits of Quotient Q2 Q0 </TD><TD>Q1 or O/U </TD><TD>Reduction 0 e Complete 1 e Incomplete </TD></TR><TR><TD>FCOM, FCOMP, FCOMPP, FTST FUCOM, FUCOMP, FUCOMPP, FICOM, FICOMP </TD><TD>Result of Comparison (See Table 4) </TD><TD>Zero or O/U </TD><TD>Operand is not Comparable (Table 4) </TD></TR><TR><TD>FXAM </TD><TD>Operand Class (See Table 5) </TD><TD>Sign or O/U </TD><TD>Operand Class (Table 5) </TD></TR><TR><TD>FCHS, FABS, FXCH, FINCSTP, FDECSTP, Constant Loads, FXTRACT, FLD, FILD, FBLD, FSTP (Ext Real) </TD><TD>UNDEFINED </TD><TD>Zero or O/U </TD><TD>UNDEFINED </TD></TR><TR><TD>FIST, FBSTP, FRNDINT, FST, FSTP, FADD, FMUL, FDIV, FDIVR, FSUB, FSUBR, FSCALE, FSQRT, FPATAN, F2XM1, FYL2X, FYL2XP1 </TD><TD>UNDEFINED </TD><TD>Roundup or O/U </TD><TD>UNDEFINED </TD></TR><TR><TD>FPTAN, FSIN, FCOS, FSINCOS </TD><TD>UNDEFINED </TD><TD>Roundup or O/U, Undefined if C2 e 1 </TD><TD>Reduction 0 e Complete 1 e Incomplete </TD></TR><TR><TD>FLDENV, FRSTOR </TD><TD>Each Bit Loaded from Memory </TD><TD/></TR><TR><TD>FLDCW, FSTENV, FSTCW, FSTSW, FCLEX, FINIT, FSAVE </TD><TD>UNDEFINED </TD><TD/></TR></Table><P>O/U 	When both IE and SF bits of status word are set, indicating a stack exception, this bit distinguishes between stack overflow (C1 e 1) and underflow (C1 e 0). </P><P>Reduction 	If FPREM or FPREM1 produces a remainder that is less than the modulus, reduction is complete. When reduction is incomplete the value at the top of the stack is a partial remainder, which can be used as input to further reduction. For FPTAN, FSIN, FCOS, and FSINCOS, the reduction bit is set if the operand at the top of the stack is too large. In this case the original operand remains at the top of the stack. </P><P>Roundup 	When the PE bit of the status word is set, this bit indicates whether one was added to the least significant bit of the result during the last rounding. </P><P>UNDEFINED Do not rely on finding any specific value in these bits. </P><Sect><Figure><ImageData src=""/></Figure><P>The low-order byte of this control word configures exception masking. Bits 5–0 of the control word contain individual masks for each of the six exceptions that the 80C187 recognizes. </P><P>The high-order byte of the control word configures the 80C187 operating mode, including precision, rounding, and infinity control. </P><P>The ‘‘infinity control bit’’ (bit 12) is not meaningful to the 80C187, and programs must ignore its value. To maintain compatibility with the 8087, this bit can be programmed; however, regardless of its value, the 80C187 always treats infinity in the affine sense(b%k a%). This bit is initialized to zero both after a hardware reset and after the FINIT instruction. </P><P>The rounding control (RC) bits (bits 11 –10) provide for directed rounding and true chop, as well as the unbiased round to nearest even mode specified in the IEEE standard. Rounding control affects only those instructions that perform rounding at the end of the operation (and thus can generate a precision exception); namely, FST, FSTP, FIST, all arithmetic instructions (except FPREM, FPREM1, FXTRACT, FABS, and FCHS), and all transcendental instructions. </P><P>The precision control (PC) bits (bits 9 –8) can be used to set the 80C187 internal operating precision of the significand at less than the default of 64 bits (extended precision). This can be useful in providing compatibility with early generation arithmetic processors of smaller precision. PC affects only the instructions ADD, SUB, DIV, MUL, and SQRT. For all other instructions, either the precision is determined by the opcode or extended precision is used. </P></Sect><P>Table 3. Condition Code Interpretation after FPREM and FPREM1 Instructions </P><Table><TR><TH/><TH>Condition Code </TH><TH/><TH/><TH>Interpretation after FPREM and FPREM1 </TH></TR><TR><TH>C2 </TH><TD>C3 </TD><TD>C1 </TD><TD>C0 </TD></TR><TR><TH>1 </TH><TD>X </TD><TD>X </TD><TD>X </TD><TD/><TD>Incomplete Reduction: Further Iteration Required for Complete Reduction </TD></TR><TR><TH>0 </TH><TD>Q1 </TD><TD>Q0 </TD><TD>Q2 </TD><TD>QMOD 8 </TD><TD>Complete Reduction: C0, C3, C1 Contain Three Least Significant Bits of Quotient </TD></TR><TR><TD>0 0 1 1 0 0 1 1 </TD><TD>0 1 0 1 0 1 0 1 </TD><TD>0 0 0 0 1 1 1 1 </TD><TD>0 1 2 3 4 5 6 7 </TD></TR></Table><P>Table 4. Condition Code Resulting from Comparison Table 5. Condition Code Defining Operand Class </P><Table><TR><TH>Order </TH><TH>C3 </TH><TH>C2 </TH><TH>C0 </TH></TR><TR><TH>TOP l Operand </TH><TD>0 </TD><TD>0 </TD><TD>0 </TD></TR><TR><TH>TOP k Operand </TH><TD>0 </TD><TD>0 </TD><TD>1 </TD></TR><TR><TH>TOP e Operand </TH><TD>1 </TD><TD>0 </TD><TD>0 </TD></TR><TR><TH>Unordered </TH><TD>1 </TD><TD>1 </TD><TD>1 </TD></TR></Table><Sect><Figure><ImageData src=""/></Figure></Sect><Table><TR><TH>C3 </TH><TH>C2 </TH><TH>C1 </TH><TH>C0 </TH><TH>Value at TOP </TH></TR><TR><TH>0 </TH><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>a Unsupported </TD></TR><TR><TH>0 </TH><TD>0 </TD><TD>0 </TD><TD>1 </TD><TD>a NaN </TD></TR><TR><TH>0 </TH><TD>0 </TD><TD>1 </TD><TD>0 </TD><TD>b Unsupported </TD></TR><TR><TH>0 </TH><TD>0 </TD><TD>1 </TD><TD>1 </TD><TD>b NaN </TD></TR><TR><TH>0 </TH><TD>1 </TD><TD>0 </TD><TD>0 </TD><TD>a Normal </TD></TR><TR><TH>0 </TH><TD>1 </TD><TD>0 </TD><TD>1 </TD><TD>a Infinity </TD></TR><TR><TH>0 </TH><TD>1 </TD><TD>1 </TD><TD>0 </TD><TD>b Normal </TD></TR><TR><TH>0 </TH><TD>1 </TD><TD>1 </TD><TD>1 </TD><TD>b Infinity </TD></TR><TR><TH>1 </TH><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>a 0 </TD></TR><TR><TH>1 </TH><TD>0 </TD><TD>0 </TD><TD>1 </TD><TD>a Empty </TD></TR><TR><TH>1 </TH><TD>0 </TD><TD>1 </TD><TD>0 </TD><TD>b 0 </TD></TR><TR><TH>1 </TH><TD>0 </TD><TD>1 </TD><TD>1 </TD><TD>b Empty </TD></TR><TR><TH>1 </TH><TD>1 </TD><TD>0 </TD><TD>0 </TD><TD>a Denormal </TD></TR><TR><TH>1 </TH><TD>1 </TD><TD>1 </TD><TD>1 </TD><TD>b Denormal </TD></TR></Table><Sect><P>INSTRUCTION AND DATA POINTERS </P><P>Because the NPX operates in parallel with the CPU, any exceptions detected by the NPX may be reported after the CPU has executed the ESC instruction which caused it. To allow identification of the failing numerics instruction, the 80C187 contains registers that aid in diagnosis. These registers supply the opcode of the failing numerics instruction, the address of the instruction, and the address of its numerics memory operand (if appropriate). </P><P>The instruction and data pointers are provided for user-written exception handlers. Whenever the 80C187 executes a new ESC instruction, it saves the address of the instruction (including any prefixes that may be present), the address of the operand (if present), and the opcode. </P><P>The instruction and data pointers appear in the format shown by Figure 6. The ESC instruction FLDENV, FSTENV, FSAVE and FRSTOR are used to transfer these values between the registers and memory. Note that the value of the data pointer is undefined if the prior ESC instruction did not have a </P><P>memory operand. </P><P>Interrupt Description </P><P>CPU interrupt 16 is used to report exceptional conditions while executing numeric programs. Interrupt 16 indicates that the previous numerics instruction caused an unmasked exception. The address of the faulty instruction and the address of its operand are stored in the instruction pointer and data pointer registers. Only ESC instructions can cause this interrupt. The CPU return address pushed onto the stack of the exception handler points to an ESC instruction (including prefixes). This instruction can be restarted after clearing the exception condition in the NPX. FNINIT, FNCLEX, FNSTSW, FNSTENV, and FNSAVE cannot cause this interrupt. </P><P>Exception Handling </P><P>The 80C187 detects six different exception conditions that can occur during instruction execution. Table6 lists the exception conditions in order of precedence, showing for each the cause and the default action taken by the 80C187 if the exception is masked by its corresponding mask bit in the control word. </P><P>Any exception that is not masked by the control word sets the corresponding exception flag of the status word, sets the ES bit of the status word, and asserts the ERROR signal. When the CPU attempts to execute another ESC instruction, interrupt 16 occurs. The exception condition must be resolved via an interrupt service routine. The return address pushed onto the CPU stack upon entry to the service routine does not necessarily point to the failing instruction nor to the following instruction. The 80C187 saves the address of the floating-point instruction that caused the exception and the address of any memory operand required by that instruction. </P><P>If error trapping is required at the end of a series of numerics instructions (specifically, when the last ESC instruction modifies memory data and that data is used in subsequent nonnumerics instructions), it is necessary to insert the FNOP instruction to force the 80C187 to check its ERROR input. </P><Figure><ImageData src=""/></Figure></Sect><Figure><ImageData src="images/math_ic_intel_80c187_1989_img_14.jpg"/></Figure><Table><TR><TH/><TH>270640 – 4 </TH></TR><TR><TH>Precision Control </TH><TD>Rounding Control </TD><TD/></TR><TR><TH>00-24 Bits (Single Precision) </TH><TD>00-Round to Nearest or Even </TD><TD/></TR><TR><TH>01-(Reserved) </TH><TD>01-Round Down (toward b%) </TD><TD/></TR><TR><TH>10-53 Bits (Double Precision) </TH><TD>10-Round Up (toward a%) </TD><TD/></TR><TR><TH>11-64 Bits (Extended Precision) </TH><TD>11-Chop (Truncate toward Zero) </TD><TD/></TR></Table><P>*The ‘‘infinity control’’ bit is not meaningful to the 80C187. To maintain compatibility with the 8087, this bit can be programmed; however, regardless of its value, the 80C187 treats infinity in the affine sense(b%k a%). </P><P>Figure 5. Control Word Table 6. Exceptions </P><Table><TR><TD>15 </TD><TD>7 </TD><TD>0 </TD><TD/></TR><TR><TD/><TD>CONTROL WORD </TD><TD/><TD>a0 </TD></TR><TR><TD/><TD>STATUS WORD </TD><TD/><TD>a2 </TD></TR><TR><TD/><TD>TAG WORD </TD><TD/><TD>a4 </TD></TR><TR><TD/><TD>INSTRUCTION POINTER15..0 </TD><TD/><TD>a6 </TD></TR><TR><TD/><TD>IP19..16 0 OPCODE10..0 </TD><TD/><TD>a8 </TD></TR><TR><TD/><TD>OPERAND POINTER15..0 </TD><TD/><TD>aA </TD></TR><TR><TD/><TD>OP19..16 0 0 0 0 0 0 0 0 0 0 0 </TD><TD>0 </TD><TD>aC </TD></TR><TR><TD/><TD>Figure 6. Instruction and Data Pointer Image in Memory </TD><TD/><TD/></TR></Table><Sect><Figure><ImageData src=""/></Figure></Sect><Table><TR><TH>Exception </TH><TH>Cause </TH><TH>Default Action (If Exception is Masked) </TH></TR><TR><TD>Invalid Operation </TD><TD>Operation on a signalling NaN, unsupported format, indeterminate form (0*%, 0/0), (a%) a (b%), etc.), or stack overflow/underflow (SF is also set) </TD><TD>Result is a quiet NaN, integer indefinite, or BCD indefinite </TD></TR><TR><TD>Denormalized Operand </TD><TD>At least one of the operands is denormalized, i.e. it has the smallest exponent but a nonzero significand </TD><TD>The operand is normalized, and normal processing continues </TD></TR><TR><TD>Zero Divisor </TD><TD>The divisor is zero while the dividend is a noninfinite, nonzero number </TD><TD>Result is % </TD></TR><TR><TD>Overflow </TD><TD>The result is too large in magnitude to fit in the specified format </TD><TD>Result is largest finite value or % </TD></TR><TR><TD>Underflow </TD><TD>The true result is nonzero but too small to be represented in the specified format, and, if underflow exception is masked, denormalization causes loss of accuracy </TD><TD>Result is denormalized or zero </TD></TR><TR><TD>Inexact Result (Precision) </TD><TD>The true result is not exactly representable in the specified format (e.g. 1/3); the result is rounded according to the rounding mode </TD><TD>Normal processing continues </TD></TR></Table><Sect><P>Initialization </P><P>After FNINIT or RESET, the control word contains the value 037FH (all exceptions masked, precision control 64 bits, rounding to nearest) the same values as in an 8087 after RESET. For compatibility with the 8087, the bit that used to indicate infinity control (bit 12) is set to zero; however, regardless of its setting, infinity is treated in the affine sense. After FNINIT or RESET, the status word is initialized as follows: </P><P>All exceptions are set to zero. </P><P>Stack TOP is zero, so that after the first push the </P><P>stack top will be register seven (111B). </P><P>The condition codeC3–C0 is undefined. </P><P>The B-bit is zero. </P><P>The tag word contains FFFFH (all stack locations are empty). </P><P>80C186/80C187 initialization software should execute an FNINIT instruction (i.e. an FINIT without a preceding WAIT) after RESET. The FNINIT is not strictly required for 80C187 software, but Intel recommends its use to help ensure upward compatibility with other processors. </P><P>8087 Compatibility </P><P>This section summarizes the differences between the 80C187 and the 8087. Many changes have been designed into the 80C187 to directly support the IEEE standard in hardware. These changes result in increased performance by elminating the need for software that supports the standard. </P><P>GENERAL DIFFERENCES </P><P>The 8087 instructions FENI/FNENI and FDISI/ FNDISI perform no useful function in the 80C187 Numeric Processor Extension. They do not alter the state of the 80C187 Numeric Processor Extension. (They are treated similarly to FNOP, except that ERROR is not checked.) While 8086/8087 code containing these instructions can be executed on the 80C186/80C187, it is unlikely that the exception-handling routines containing these instructions will be completely portable to the 80C187 Numeric Processor Extension. </P><P>The 80C187 differs from the 8087 with respect to instruction, data, and exception synchronization. Except for the processor control instructions, all of the 80C187 numeric instructions are automatically synchronized by the 80C186 CPU. When necessary, the 80C186 automatically tests the BUSY line from the 80C187 Numeric Processor Extension to ensure that the 80C187 Numeric Processor Extension has completed its previous instruction before executing the next ESC instruction. No explicit WAIT instructions are required to assure this synchronization. For the 8087 used with 8086 and 8088 CPUs, explicit WAITs are required before each numeric instruction to ensure synchronization. Although 8086/8087 programs having explicit WAIT instructions will execute on the 80C186/80C187, these WAIT instructions are unnecessary. </P><Figure><ImageData src=""/></Figure><P>The 80C187 supports only affine closure for infinity arithmetic, not projective closure. </P><P>Operands for FSCALE and FPATAN are no longer restricted in range (except for g%); F2XM1 and FPTAN accept a wider range of operands. </P><P>Rounding control is in effect for FLD constant. </P><P>Software cannot change entries of the tag word to values (other than empty) that differ from actual register contents. </P><P>After reset, FINIT, and incomplete FPREM, the 80C187 resets to zero the condition code bits C3– C0 of the status word. </P><P>In conformance with the IEEE standard, the 80C187 does not support the special data formats pseudozero, pseudo-NaN, pseudoinfinity, and unnormal. </P><P>The denormal exception has a different purpose on the 80C187. A system that uses the denormal-exception handler solely to normalize the denormal operands, would better mask the denormal exception on the 80C187. The 80C187 automatically normalizes denormal operands when the denormal exception is masked. </P><P>EXCEPTIONS </P><P>A number of differences exist due to changes in the IEEE standard and to functional improvements to the architecture of the 80C186/80C187: </P><P>1. The 	80C186/80C187 traps exceptions only on the next ESC instruction; i.e. the 80C186 does not notice unmasked 80C187 exceptions on the 80C186 ERROR input line until a later numerics instruction is executed. Because the 80C186 does not sample ERROR on WAIT and FWAIT instructions, programmers should place an FNOP instruction at the end of a sequence of numerics instructions to force the 80C186 to sample its ERROR input. </P><L><LI><LI_Label>2. </LI_Label><LI_Title>The 	80C187 Numeric Processor Extension signals exceptions through a dedicated ERROR line to the CPU. The 80C187 error signal does not pass through an interrupt controller (the 8087 INT signal does). Therefore, any interrupt-controlleroriented instructions in numerics exception handlers for the 8086/8087 should be deleted. </LI_Title></LI><LI><LI_Label>3. </LI_Label><LI_Title>Interrupt vector 16 must point to the numerics exception handling routine. </LI_Title></LI><LI><LI_Label>4. </LI_Label><LI_Title>The ESC instruction address saved in the 80C187 Numeric Processor Extension includes any leading prefixes before the ESC opcode. The corresponding address saved in the 8087 does not include leading prefixes. </LI_Title></LI><LI><LI_Label>5. </LI_Label><LI_Title>When 	the overflow or underflow exception is masked, the 80C187 differs from the 8087 in rounding when overflow or underflow occurs. The 80C187 produces results that are consistent with the rounding mode. </LI_Title></LI><LI><LI_Label>6. </LI_Label><LI_Title>When 	the underflow exception is masked, the 80C187 sets its underflow flag only if there is also a loss of accuracy during denormalization. </LI_Title></LI><LI><LI_Label>7. </LI_Label><LI_Title>Fewer invalid-operation exceptions due to denormal operands, because the instructions FSQRT, FDIV, FPREM, and conversions to BCD or to integer normalize denormal operands before proceeding. </LI_Title></LI><LI><LI_Label>8. </LI_Label><LI_Title>The 	FSQRT, FBSTP, and FPREM instructions may cause underflow, because they support de-normal operands. </LI_Title></LI><LI><LI_Label>9. </LI_Label><LI_Title>The 	denormal exception can occur during the transcendental instructions and the FXTRACT instruction. </LI_Title></LI><LI><LI_Label>10. </LI_Label><LI_Title>The denormal exception 	no longer takes precedence over all other exceptions. </LI_Title></LI><LI><LI_Label>11. </LI_Label><LI_Title>When 	the denormal exception is masked, the 80C187 automatically normalizes denormal operands. The 8087 performs unnormal arithmetic, which might produce an unnormal result. </LI_Title></LI><LI><LI_Label>12. </LI_Label><LI_Title>When 	the operand is zero, the FXTRACT instruction reports a zero-divide exception and leaves b% in ST(1). </LI_Title></LI><LI><LI_Label>13. </LI_Label><LI_Title>The status 	word has a new bit (SF) that signals when invalid-operation exceptions are due to stack underflow or overflow. </LI_Title></LI><LI><LI_Label>14. </LI_Label><LI_Title>FLDextendedprecision no longer reports denormal exceptions, because the instruction is not numeric. </LI_Title></LI><LI><LI_Label>15. </LI_Label><LI_Title>FLD single/double precision when the operand is denormal converts the number to extended precision and signals the denormalized oper</LI_Title></LI></L><Figure><ImageData src=""/></Figure><P>and exception. When loading a signalling NaN, FLD single/double precision signals an invalid-operand exception. </P><L><LI><LI_Label>16. </LI_Label><LI_Title>The 80C187 	only generates quiet NaNs (as on the 8087); however, the 80C187 distinguishes between quiet NaNs and signalling NaNs. Signalling NaNs trigger exceptions when they are used as operands; quiet NaNs do not (except for FCOM, FIST, and FBSTP which also raise IE for quiet NaNs). </LI_Title></LI><LI><LI_Label>17. </LI_Label><LI_Title>When stack overflow 	occurs during FPTAN and overflow is masked, both ST(0) and ST(1) contain quiet NaNs. The 8087 leaves the original operand in ST(1) intact. </LI_Title></LI><LI><LI_Label>18. </LI_Label><LI_Title>When 	the scaling factor is g%, the FSCALE (ST(0), ST(1) instruction behaves as follows </LI_Title></LI></L><P>(ST(0) and ST(1) contain the scaled and scaling </P><P>operands respectively): FSCALE (0, %) generates the invalid operation exception. </P><P>FSCALE (finite, b%) generates zero with the same sign as the scaled operand. </P><P>FSCALE (finite, a%) generates % with the </P><P>same sign as the scaled operand. The 8087 returns zero in the first case and raises the invalid-operation exception in the other cases. </P><P>19. The 80C187 	returns signed infinity/zero as the unmasked response to massive overflow/underflow. The 8087 supports a limited range for the scaling factor; within this range either massive overflow/underflow do not occur or undefined results are produced. </P></Sect><P>Table 7. Pin Summary </P><Table><TR><TH>Pin Name </TH><TH>Function </TH><TH>Active State </TH><TH>Input/ Output </TH></TR><TR><TD>CLK CKM RESET </TD><TD>CLocK ClocKing Mode System reset </TD><TD>High </TD><TD>I I I </TD></TR><TR><TD>PEREQ BUSY ERROR </TD><TD>Processor Extension REQuest Busy status Error status </TD><TD>High High Low </TD><TD>O O O </TD></TR><TR><TD>D15–D0 NPRD NPWR </TD><TD>Data pins Numeric Processor ReaD Numeric Processor WRite </TD><TD>High Low Low </TD><TD>I/O I I </TD></TR><TR><TD>NPS1 NPS2 CMD0 CMD1 </TD><TD>NPX select #1 NPX select #2 CoMmanD 0 CoMmanD 1 </TD><TD>Low High High High </TD><TD>I I I I </TD></TR><TR><TD>VCC VSS </TD><TD>System power System ground </TD><TD/><TD>I I </TD></TR></Table><Sect><P>HARDWARE INTERFACE </P><P>In the following description of hardware interface, an overbar above a signal name indicates that the active or asserted state occurs when the signal is at a low voltage. When no overbar is present above the signal name, the signal is asserted when at the high voltage level. </P><P>Signal Description </P><P>In the following signal descriptions, the 80C187 pins are grouped by function as follows: </P><L><LI><LI_Label>1. </LI_Label><LI_Title>Execution Control-CLK, CKM, RESET </LI_Title></LI><LI><LI_Label>2. </LI_Label><LI_Title>NPX Handshake-PEREQ, BUSY, ERROR </LI_Title></LI><LI><LI_Label>3. </LI_Label><LI_Title>Bus Interface Pins-D15–D0, NPWR, NPRD </LI_Title></LI><LI><LI_Label>4. </LI_Label><LI_Title>Chip/Port Select-NPS1, NPS2, CMD0, CMD1 </LI_Title></LI><LI><LI_Label>5. </LI_Label><LI_Title>Power Supplies-VCC,VSS </LI_Title></LI></L><P>Table 7 lists every pin by its identifier, gives a brief description of its function, and lists some of its characteristics. Figure 7 shows the locations of pins on the CERDIP package, while Figure8 shows the locations of pins on the PLCC package. Table 8 helps to locate pin identifiers in Figures 7 and 8. </P><P>Clock (CLK) </P><P>This input provides the basic timing for internal operation. This pin does not require MOS-level input; it will operate at either TTL or MOS levels up to the maximum allowed frequency. A minimum frequency must be provided to keep the internal logic properly functioning. Depending on the signal on CKM, the signal on CLK can be divided by two to produce the internal clock signal (in which case CLK may be up to 32 MHz in frequency), or can be used directly (in which case CLK may be up to 12.5 MHz). </P><P>Clocking Mode (CKM) </P><P>This pin is a strapping option. When it is strapped to VCC (HIGH), the CLK input is used directly; when strapped to VSS (LOW), the CLK input is divided by two to produce the internal clock signal. During the RESET sequence, this input must be stable at least four internal clock cycles (i.e. CLK clocks when CKM is HIGH;2 c CLK clocks when CKM is LOW) before RESET goes LOW. </P><Figure><ImageData src="images/math_ic_intel_80c187_1989_img_18.jpg"/>270640 – 5 *N.C. e Pin Not Connected Figure 7. CERDIP Pin Configuration 270640 – 6 *N.C. e Pin Not Connected **‘‘Top View’’ means as the package is seen from the component side of the board. Figure 8. PLCC Pin Configuration </Figure><Figure><ImageData src=""/></Figure></Sect><P>Table 8. PLCC Pin Cross-Reference </P><Table><TR><TH>Pin Name </TH><TH>CERDIP Package </TH><TH>PLCC Package </TH></TR><TR><TH>BUSY </TH><TD>25 </TD><TD>28 </TD></TR><TR><TH>CKM </TH><TD>39 </TD><TD>44 </TD></TR><TR><TH>CLK </TH><TD>32 </TD><TD>36 </TD></TR><TR><TH>CMD0 </TH><TD>29 </TD><TD>32 </TD></TR><TR><TH>CMD1 </TH><TD>31 </TD><TD>35 </TD></TR><TR><TH>D0 </TH><TD>23 </TD><TD>26 </TD></TR><TR><TH>D1 </TH><TD>22 </TD><TD>25 </TD></TR><TR><TH>D2 </TH><TD>21 </TD><TD>24 </TD></TR><TR><TH>D3 </TH><TD>20 </TD><TD>22 </TD></TR><TR><TH>D4 </TH><TD>19 </TD><TD>21 </TD></TR><TR><TH>D5 </TH><TD>18 </TD><TD>20 </TD></TR><TR><TH>D6 </TH><TD>17 </TD><TD>19 </TD></TR><TR><TH>D7 </TH><TD>16 </TD><TD>18 </TD></TR><TR><TH>D8 </TH><TD>15 </TD><TD>17 </TD></TR><TR><TH>D9 </TH><TD>14 </TD><TD>16 </TD></TR><TR><TH>D10 </TH><TD>12 </TD><TD>14 </TD></TR><TR><TH>D11 </TH><TD>11 </TD><TD>13 </TD></TR><TR><TH>D12 </TH><TD>8 </TD><TD>9 </TD></TR><TR><TH>D13 </TH><TD>7 </TD><TD>8 </TD></TR><TR><TH>D14 </TH><TD>6 </TD><TD>7 </TD></TR><TR><TH>D15 </TH><TD>5 </TD><TD>5 </TD></TR><TR><TH>ERROR </TH><TD>26 </TD><TD>29 </TD></TR><TR><TH>No Connect </TH><TD>2 </TD><TD>6, 11, 23, 33, 40 </TD></TR><TR><TH>NPRD </TH><TD>27 </TD><TD>30 </TD></TR><TR><TH>NPS1 </TH><TD>34 </TD><TD>38 </TD></TR><TR><TH>NPS2 </TH><TD>33 </TD><TD>37 </TD></TR><TR><TH>NPWR </TH><TD>28 </TD><TD>31 </TD></TR><TR><TH>PEREQ </TH><TD>24 </TD><TD>27 </TD></TR><TR><TH>RESET </TH><TD>35 </TD><TD>39 </TD></TR><TR><TH>VCC </TH><TD>3, 9, 13, 37, 40 </TD><TD>1, 3, 10, 15, 42 </TD></TR><TR><TH>VSS </TH><TD>1, 4, 10, 30, 36, 38 </TD><TD>2, 4, 12, 34, 41, 43 </TD></TR></Table><Sect><P>System Reset (RESET) </P><P>A LOW to HIGH transition on this pin causes the 80C187 to terminate its present activity and to enter a dormant state. RESET must remain active (HIGH) for at least four internal clock periods. (The relation of the internal clock period to CLK depends on CLKM; the internal clock may be different from that of the CPU.) Note that the 80C187 is active internally for 25 clock periods after the termination of the RESET signal (the HIGH to LOW transition of RESET); therefore, the first instruction should not be written to the 80C187 until 25 internal clocks after the falling edge of RESET. Table9 shows the status of the output pins during the reset sequence. After a reset, all output pins return to their inactive states. </P><P>Table 9. Output Pin Status during Reset </P><Table><TR><TD>Output </TD><TD>Value </TD></TR><TR><TD>Pin Name </TD><TD>during Reset </TD></TR><TR><TD>BUSY </TD><TD>HIGH </TD></TR><TR><TD>ERROR </TD><TD>HIGH </TD></TR><TR><TD>PEREQ </TD><TD>LOW </TD></TR><TR><TD>D15–D0 </TD><TD>TRI-STATE OFF </TD></TR></Table><P>Processor Extension Request (PEREQ) </P><P>When active, this pin signals to the CPU that the 80C187 is ready for data transfer to/from its data FIFO. When there are more than five data transfers, PEREQ is deactivated after the first three transfers and subsequently after every four transfers. This signal always goes inactive before BUSY goes inactive. </P><Figure><ImageData src=""/></Figure><P>Busy Status (BUSY) </P><P>When active, this pin signals to the CPU that the 80C187 is currently executing an instruction. This pin is active HIGH. It should be connected to the 80C186’s TEST/BUSY pin. During the RESET sequence this pin is HIGH. The 80C186 uses this HIGH state to detect the presence of an 80C187. </P><P>Error Status (ERROR) </P><P>This pin reflects the ES bit of the status register. When active, it indicates that an unmasked exception has occurred. This signal can be changed to inactive state only by the following instructions (without a preceding WAIT): FNINIT, FNCLEX, FNSTENV, FNSAVE, FLDCW, FLDENV, and FRSTOR. This pin should be connected to the ERROR pin of the CPU. ERROR can change state only when BUSY is active. </P><P>Data Pins (D15–D0) </P><P>These bidirectional pins are used to transfer data and opcodes between the CPU and 80C187. They are normally connected directly to the corresponding CPU data pins. Other buffers/drivers driving the local data bus must be disabled when the CPU reads from the NPX. High state indicates a value of one. D0 is the least significant data bit. </P><P>Numeric Processor Write (NPWR) </P><P>A signal on this pin enables transfers of data from the CPU to the NPX. This input is valid only when NPS1 and NPS2 are both active. </P><P>Numeric Processor Read (NPRD) </P><P>A signal on this pin enables transfers of data from the NPX to the CPU. This input is valid only when NPS1 and NPS2 are both active. </P><P>Numeric Processor Selects (NPS1 and NPS2) </P><P>Concurrent assertion of these signals indicates that the CPU is performing an escape instruction and enables the 80C187 to execute that instruction. No data transfer involving the 80C187 occurs unless the device is selected by these lines. </P><P>Command Selects (CMD0 and CMD1) </P><P>These pins along with the select pins allow the CPU to direct the operation of the 80C187. </P><P>System Power (VCC) </P><P>System power provides the a5V g10% DC supply input. All VCC pins should be tied together on the circuit board and local decoupling capacitors should be used between VCC and VSS. </P><P>System Ground (VSS) </P><P>All VSS pins should be tied together on the circuit board and local decoupling capacitors should be used between VCC and VSS. </P><P>Processor Architecture </P><P>As shown by the block diagram (Figure 1), the 80C187 NPX is internally divided into three sections: the bus control logic (BCL), the data interface and control unit, and the floating-point unit (FPU). The FPU (with the support of the control unit which contains the sequencer and other support units) executes all numerics instructions. The data interface and control unit is responsible for the data flow to and from the FPU and the control registers, for receiving the instructions, decoding them, and sequencing the microinstructions, and for handling some of the administrative instructions. The BCL is responsible for CPU bus tracking and interface. </P><P>BUS CONTROL LOGIC </P><P>The BCL communicates solely with the CPU using I/O bus cycles. The BCL appears to the CPU as a special peripheral device. It is special in two respects: the CPU initiates I/O automatically when it encounters ESC instructions, and the CPU uses reserved I/O addresses to communicate with the BCL. The BCL does not communicate directly with memory. The CPU performs all memory access, transferring input operands from memory to the 80C187 and transferring outputs from the 80C187 to memory. A dedicated communication protocol makes possible high-speed transfer of opcodes and operands between the CPU and 80C187. </P><Figure><ImageData src=""/></Figure></Sect><Table><Caption><P>Table 10. Bus Cycles Definition </P></Caption><TR><TH>NPS1 </TH><TH>NPS2 </TH><TH>CMD0 </TH><TH>CMD1 </TH><TH>NPRD </TH><TH>NPWR </TH><TH>Bus Cycle Type </TH></TR><TR><TH>x </TH><TD>0 </TD><TD>x </TD><TD>x </TD><TD>x </TD><TD>x </TD><TD>80C187 Not Selected </TD></TR><TR><TH>1 </TH><TD>x </TD><TD>x </TD><TD>x </TD><TD>x </TD><TD>x </TD><TD>80C187 Not Selected </TD></TR><TR><TH>0 </TH><TD>1 </TD><TD>0 </TD><TD>0 </TD><TD>1 </TD><TD>0 </TD><TD>Opcode Write to 80C187 </TD></TR><TR><TH>0 </TH><TD>1 </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>1 </TD><TD>CW or SW Read from 80C187 </TD></TR><TR><TH>0 </TH><TD>1 </TD><TD>1 </TD><TD>0 </TD><TD>0 </TD><TD>1 </TD><TD>Read Data from 80C187 </TD></TR><TR><TH>0 </TH><TD>1 </TD><TD>1 </TD><TD>0 </TD><TD>1 </TD><TD>0 </TD><TD>Write Data to 80C187 </TD></TR><TR><TH>0 </TH><TD>1 </TD><TD>0 </TD><TD>1 </TD><TD>1 </TD><TD>0 </TD><TD>Write Exception Pointers </TD></TR><TR><TH>0 </TH><TD>1 </TD><TD>0 </TD><TD>1 </TD><TD>0 </TD><TD>1 </TD><TD>Reserved </TD></TR><TR><TH>0 </TH><TD>1 </TD><TD>1 </TD><TD>1 </TD><TD>0 </TD><TD>1 </TD><TD>Read Opcode Status </TD></TR><TR><TH>0 </TH><TD>1 </TD><TD>1 </TD><TD>1 </TD><TD>1 </TD><TD>0 </TD><TD>Reserved </TD></TR></Table><Sect><P>DATA INTERFACE AND CONTROL UNIT </P><P>The data interface and control unit latches the data and, subject to BCL control, directs the data to the FIFO or the instruction decoder. The instruction decoder decodes the ESC instructions sent to it by the CPU and generates controls that direct the data flow in the FIFO. It also triggers the microinstruction sequencer that controls execution of each instruction. If the ESC instruction is FINIT, FCLEX, FSTSW, FSTSW AX, FSTCW, FSETPM, or FRSTPM, the control executes it independently of the FPU and the sequencer. The data interface and control unit is the one that generates the BUSY, PEREQ, and ERROR signals that synchronize 80C187 activities with the CPU. </P><P>FLOATING-POINT UNIT </P><P>The FPU executes all instructions that involve the register stack, including arithmetic, logical, transcendental, constant, and data transfer instructions. The data path in the FPU is 84 bits wide (68 significant bits, 15 exponent bits, and a sign bit) which allows internal operand transfers to be performed at very high speeds. </P><P>Bus Cycles </P><P>The pins NPS1, NPS2, CMD0, CMD1, NPRD and NPWR identify bus cycles for the NPX. Table 10 defines the types of 80C187 bus cycles. </P><P>80C187 ADDRESSING </P><P>The NPS1, NPS2, CMD0, and CMD1 signals allow the NPX to identify which bus cycles are intended for the NPX. The NPX responds to I/O cycles when the I/O address is 00F8H, 00FAH, 00FCH, or 00FEH. The correspondence betwen I/O addresses and control signals is defined by Table 11. To guarantee correct operation of the NPX, programs must not perform any I/O operations to these reserved port addresses. </P></Sect><Table><Caption><P>Table 11. I/O Address Decoding </P></Caption><TR><TH>I/O Address (Hexadecimal) </TH><TH/><TH>80C187 Select and Command Inputs </TH><TH/></TR><TR><TD>NPS2 </TD><TD>NPS1 </TD><TD>CMD1 </TD><TD>CMD0 </TD></TR><TR><TH>00F8 00FA 00FC 00FE </TH><TD>1 1 1 1 </TD><TD>0 0 0 0 </TD><TD>0 0 1 1 </TD><TD>0 1 0 1 </TD></TR></Table><Sect><Figure><ImageData src=""/></Figure><P>CPU/NPX SYNCHRONIZATION </P><P>The pins BUSY, PEREQ, and ERROR are used for various aspects of synchronization between the CPU and the NPX. </P><P>BUSY is used to synchronize instruction transfer from the CPU to the 80C187. When the 80C187 recognizes an ESC instruction, it asserts BUSY. For most ESC instructions, the CPU waits for the 80C187 to deassert BUSY before sending the new opcode. </P><P>The NPX uses the PEREQ pin of the CPU to signal that the NPX is ready for data transfer to or from its data FIFO. The NPX does not directly access memory; rather, the CPU provides memory access services for the NPX. </P><P>Once the CPU initiates an 80C187 instruction that has operands, the CPU waits for PEREQ signals that indicate when the 80C187 is ready for operand transfer. Once all operands have been transferred (or if the instruction has no operands) the CPU continues program execution while the 80C187 executes the ESC instruction. </P><P>In 8086/8087 systems, WAIT instructions are required to achieve synchronization of both commands and operands. The 80C187, however, does not require WAIT instructions. The WAIT or FWAIT instruction commonly inserted by high-level compilers and assembly-language programmers for exception synchronization is not treated as an instruction by the 80C186 and does not provide exception trapping. (Refer to the section ‘‘System Configuration for 8087-Compatible Exception Trapping’’.) </P><P>Once it has started to execute a numerics instruction and has transferred the operands from the CPU, the 80C187 can process the instruction in parallel with and independent of the host CPU. When the NPX detects an exception, it asserts the ERROR signal, which causes a CPU interrupt. </P><P>OPCODE INTERPRETATION </P><P>The CPU and the NPX use a bus protocol that adapts to the numerics opcode being executed. Only the NPX directly interprets the opcode. Some of the results of this interpretation are relevant to the CPU. The NPX records these results (opcode status information) in an internal 16-bit register. The 80C186 accesses this register only via reads from NPX port 00FEH. Tables 10 and 11 define the signal combinations that correspond to each of the following steps. </P><L><LI><LI_Label>1. </LI_Label><LI_Title>The CPU writes the opcode to NPX port 00F8H. This write can occur even when the NPX is busy or is signalling an exception. The NPX does not necessarily begin executing the opcode immediately. </LI_Title></LI><LI><LI_Label>2. </LI_Label><LI_Title>The 	CPU reads the opcode status information from NPX port 00FEH. </LI_Title></LI><LI><LI_Label>3. </LI_Label><LI_Title>The CPU initiates subsequent bus cycles according to the opcode status information. The opcode status information specifies whether to wait until the NPX is not busy, when to transfer exception pointers to port 00FCH, when to read or write operands and results at port 00FAH, etc. </LI_Title></LI></L><P>For most instructions, the NPX does not start executing the previously transferred opcode until the CPU (guided by the opcode status information) first writes exception pointer information to port 00FCH of the NPX. This protocol is completely transparent to programmers. </P><P>Bus Operation </P><P>With respect to bus interface, the 80C187 is fully asynchronous with the CPU, even when it operates from the same clock source as the CPU. The CPU initiates a bus cycle for the NPX by activating both NPS1 and NPS2, the NPX select signals. During the CLK period in which NPS1 and NPS2 are activated, the 80C187 also examines the NPRD and NPRW input signals to determine whether the cycle is a read or a write cycle and examines the CMD0 and CMD1 inputs to determine whether an opcode, operand, or control/status register transfer is to occur. The 80C187 activates its BUSY output some time after the leading edge of the NPRD or NPRW signal. Input and ouput data are referenced to the trailing edges of the NPRD and NPRW signals. </P><Figure><ImageData src=""/></Figure><P>The 80C187 activates the PEREQ signal when it is ready for data transfer. The 80C187 deactivates PEREQ automatically. </P><P>System Configuration </P><P>The 80C187 can be connected to the 80C186 CPU as shown by Figure 9. (Refer to the 80C186 Data Sheet for an explanation of the 80C186’s signals.) This interface has the following characteristics: </P><P>The 80C187’s NPS1, ERROR, PEREQ, and BUSY pins are connected directly to the corresponding pins of the 80C186. </P></Sect><Figure><ImageData src="images/math_ic_intel_80c187_1989_img_24.jpg"/>270640 – 7 <Caption><P>Figure 9. 80C186/80C187 System Configuration </P></Caption></Figure><Sect><P>The 80C186 pin MCS3/NPS is connected to NPS1;NPS2 is connected toVCC. Note that if the 80C186 CPU’s DEN signal is used to gate external data buffers, it must be combined with the NPS signal to insure numeric accesses will not activate these buffers. </P><P>The NPRD and NPRW pins are connected to the </P><P>RD and WR pins of the 80C186. 
CMD1 and CMD0 come from the latched A2 and 
A1 of the 80C186, respectively. 
</P><P>The 80C187 BUSY output connects to the 80C186 TEST/BUSY input. During RESET, the signal at the 80C187 BUSY output automatically programs the 80C186 to use the 80C187. </P><P>The 80C187 can use the CLKOUT signal of the 80C186 to conserve board space when operating at 12.5 MHz or less. In this case, the 80C187 CKM input must be pulled HIGH. For operation in excess of 12.5 MHz, a double-frequency external oscillator for CLK input is needed. In this case, CKM must be pulled LOW. </P><Figure><ImageData src=""/></Figure><P>System Configuration for 80186/ 80187-Compatible Exception Trapping </P><P>When the 80C187 ERROR output signal is connected directly to the 80C186 ERROR input, floating-point exceptions cause interrupt #16. However, existing software may be programmed to expect floating-point exceptions to be signalled over an external interrupt pin via an interrupt controller. </P><P>For exception handling compatible with the 80186/ 82188/8087, the 80C186 can be wired to recognize exceptions through an external interrupt pin, as Figure 10 shows. (Refer to the 80C186 Data Sheet for an explanation of the 80C186’s signals.) With this arrangement, a flip-flop is needed to latch BUSY upon assertion of ERROR. The latch can then be cleared during the exception-handler routine by forcing a PCS pin active. The latch must also be cleared at RESET in order for the 80C186 to work with the 80C187. </P></Sect><Figure><ImageData src="images/math_ic_intel_80c187_1989_img_26.jpg"/>270640 – 8 *For input clocking options, refer to Figure 9. <Caption><P>Figure 10. System Configuration for 8087-Compatible Exception Trapping </P></Caption></Figure><Sect><Figure><ImageData src=""/></Figure><P>ELECTRICAL DATA </P><P>Absolute Maximum Ratings* </P><P>Case Temperature Under Bias (TC)...0°Cto a85°C </P><P>StorageTemperature .......... b65°Cto a150°C 
</P><P>Voltage on Any Pin with Respect to Ground ....b0.5V toVCC a0.5V </P><P>PowerDissipation..........................1.5W 
</P><P>Power and Frequency Requirements </P><P>The typical relationship between and the fre-</P><P>ICC quency of operation F is as follows: </P><P>e55a5 * F mA where F is in MHz. </P><P>ICCtyp </P><P>When the frequency is reduced below the minimum operating frequency specified in the AC Characteristics table, the internal states of the 80C187 may become indeterminate. The 80C187 clock cannot be stopped; otherwise, ICC would increase significantly beyond what the equation above indicates. </P></Sect><P>DC Characteristics TC e0°Cto a85°C,VCC ea</P><Table><TR><TH>Symbol </TH><TH>Parameter </TH><TH>Min </TH><TH>Max </TH><TH>Units </TH><TH>Test Conditions </TH></TR><TR><TD>VIL </TD><TD>Input LOW Voltage </TD><TD>b0.5 </TD><TD>a0.8 </TD><TD>V </TD><TD/></TR><TR><TD>VIH </TD><TD>Input HIGH Voltage </TD><TD>2.0 </TD><TD>VCC a0.5 </TD><TD>V </TD><TD/></TR><TR><TD>VICL </TD><TD>Clock Input LOW Voltage </TD><TD>b0.5 </TD><TD>a0.8 </TD><TD>V </TD><TD/></TR><TR><TD>VICH </TD><TD>Clock Input HIGH Voltage </TD><TD>2.0 </TD><TD>VCC a0.5 </TD><TD>V </TD><TD/></TR><TR><TD>VOL </TD><TD>Output LOW Voltage </TD><TD/><TD>0.45 </TD><TD>V </TD><TD>IOL e3.0 mA </TD></TR><TR><TD>VOH </TD><TD>Output HIGH Voltage </TD><TD>2.4 </TD><TD/><TD>V </TD><TD>IOH eb0.4 mA </TD></TR><TR><TD>ICC </TD><TD>Power Supply Current </TD><TD/><TD>156 135 </TD><TD>mA mA </TD><TD>16 MHz 12.5 MHz </TD></TR><TR><TD>ILI </TD><TD>Input Leakage Current </TD><TD/><TD>g10 </TD><TD>mA </TD><TD>0V sVIN sVCC </TD></TR><TR><TD>ILO </TD><TD>I/O Leakage Current </TD><TD/><TD>g10 </TD><TD>mA </TD><TD>0.45V sVOUT sVCC b0.45V </TD></TR><TR><TD>CIN </TD><TD>Input Capacitance </TD><TD/><TD>10 </TD><TD>pF </TD><TD>FC e1MHz </TD></TR><TR><TD>CO </TD><TD>I/O or Output Capacitance </TD><TD/><TD>12 </TD><TD>pF </TD><TD>FC e1MHz </TD></TR><TR><TD>CCLK </TD><TD>Clock Capacitance </TD><TD/><TD>20 </TD><TD>pF </TD><TD>FC e1MHz </TD></TR></Table><Sect><P>NOTICE: This is a production data sheet. The specifications are subject to change without notice. </P><P>*WARNING:Stressingthedevicebeyondthe‘‘Absolute Maximum Ratings’’ may cause permanent damage. These are stress ratings only. Operation beyond the ‘‘Operating Conditions’’ is not recommended and extended exposure beyond the ‘‘Operating Conditions’’ mayaffect device reliability. </P><P>5V g10% </P><Figure><ImageData src=""/></Figure><P>80C187 AC Characteristics </P></Sect><P>TC e 0°Cto a85°C, VCC e 5V g10% 
All timings are measured at 1.5V unless otherwise specified 
</P><Table><TR><TH>Symbol </TH><TH>Parameter </TH><TH>12.5 MHz </TH><TH>16 MHz </TH><TH>Test Conditions</TH></TR><TR><TD>Min (ns) </TD><TD>Max (ns) </TD><TD>Min (ns) </TD><TD>Max (ns) </TD></TR><TR><TH>Tdvwh (t6) Twhdx (t7) </TH><TD>Data Setup to NPWR Data Hold from NPWR </TD><TD>43 14 </TD><TD/><TD>33 14 </TD><TD/><TD/></TR><TR><TH>Trlrh (t8) Twlwh (t9) </TH><TD>NPRD Active Time NPWR Active Time </TD><TD>59 59 </TD><TD/><TD>54 54 </TD><TD/><TD/></TR><TR><TH>Tavwl (t10) Tavrl (t11) </TH><TD>Command Valid to NPWR Command Valid to NPRD </TD><TD>0 0 </TD><TD/><TD>0 0 </TD><TD/><TD/></TR><TR><TH>Tmhrl (t12) </TH><TD>Min Delay from PEREQ Active to NPRD Active </TD><TD>40 </TD><TD/><TD>30 </TD><TD/><TD/></TR><TR><TH>Twhax (t18) Trhax (t19) </TH><TD>Command Hold from NPWR Command Hold from NPRD </TD><TD>12 12 </TD><TD/><TD>8 8 </TD><TD/><TD/></TR><TR><TH>Tivcl (t20) </TH><TD>NPRD, NPWR, RESET to CLK Setup Time </TD><TD>46 </TD><TD/><TD>38 </TD><TD/><TD>Note 1 </TD></TR><TR><TH>Tclih (t21) </TH><TD>NPRD, NPWR, RESET from CLK Hold Time </TD><TD>26 </TD><TD/><TD>18 </TD><TD/><TD>Note 1 </TD></TR><TR><TH>Trscl (t24) </TH><TD>RESET to CLK Setup </TD><TD>21 </TD><TD/><TD>19 </TD><TD/><TD>Note 1 </TD></TR><TR><TH>Tclrs (t25) </TH><TD>RESET from CLK Hold </TD><TD>14 </TD><TD/><TD>9 </TD><TD/><TD>Note 1 </TD></TR><TR><TH>Tcmdi (t26) </TH><TD>Command Inactive Time </TD><TD/><TD/><TD/><TD/><TD/></TR><TR><TH/><TD>Write to Write </TD><TD>69 </TD><TD/><TD>59 </TD><TD/><TD/></TR><TR><TH/><TD>Read to Read </TD><TD>69 </TD><TD/><TD>59 </TD><TD/><TD/></TR><TR><TH/><TD>Read to Write </TD><TD>69 </TD><TD/><TD>59 </TD><TD/><TD/></TR><TR><TH/><TD>Write to Read </TD><TD>69 </TD><TD/><TD>59 </TD><TD/><TD/></TR></Table><Sect><P>NOTE: </P></Sect><P>1. This is an asynchronous input. This specification is given for testing purposes only, to assure recognition at a specific CLK edge. </P><Sect><Figure><ImageData src=""/></Figure><P>Timing Responses </P></Sect><P>All timings are measured at 1.5V unless otherwise specified </P><Table><TR><TH>Symbol </TH><TH>Parameter </TH><TH>12.5 MHz </TH><TH>16 MHz </TH><TH>Test Conditions</TH></TR><TR><TD>Min (ns) </TD><TD>Max (ns) </TD><TD>Min (ns) </TD><TD>Max (ns) </TD></TR><TR><TH>Trhqz (t27) Trlqv (t28) </TH><TD>NPRD Inactive to Data Float* NPRD Active to Data Valid </TD><TD/><TD>18 50 </TD><TD/><TD>18 45 </TD><TD>Note 2 Note 3 </TD></TR><TR><TH>Tilbh (t29) </TH><TD>ERROR Active to Busy Inactive </TD><TD>104 </TD><TD/><TD>104 </TD><TD/><TD>Note 4 </TD></TR><TR><TH>Twlbv (t30) </TH><TD>NPWR Active to Busy Active </TD><TD/><TD>80 </TD><TD/><TD>60 </TD><TD>Note 4 </TD></TR><TR><TH>Tklml (t31) </TH><TD>NPRD or NPWR Active to PEREQ Inactive </TD><TD/><TD>80 </TD><TD/><TD>60 </TD><TD>Note 5 </TD></TR><TR><TH>Trhqh (t32) </TH><TD>Data Hold from NPRD Inactive </TD><TD>2 </TD><TD/><TD>2 </TD><TD/><TD>Note 3 </TD></TR><TR><TH>Trlbh (t33) </TH><TD>RESET Inactive to BUSY Inactive </TD><TD/><TD>80 </TD><TD/><TD>60 </TD><TD/></TR></Table><Sect><P>NOTES: </P><P>*The data float delay is not tested. </P></Sect><P>2. The float condition occurs when the measured output current is less thanIOL onD15–D0. </P><Sect><P>3.D15–D0 loading:CL e 100 pF. </P><L><LI><LI_Label>4. </LI_Label><LI_Title>BUSY loading: CL e 100 pF. </LI_Title></LI><LI><LI_Label>5. </LI_Label><LI_Title>On last data transfer of numeric instruction. </LI_Title></LI></L><P>Clock Timings </P></Sect><Table><TR><TH/><TH/><TH/><TH>12.5 MHz </TH><TH>16 MHz* </TH><TH>Test </TH></TR><TR><TD/><TD/><TD/><TD/></TR><TR><TH>Symbol </TH><TD>Parameter </TD><TD/><TD>Min </TD><TD>Max </TD><TD>Min </TD><TD>Max </TD><TD>Conditions </TD></TR><TR><TH/><TD/><TD/><TD>(ns) </TD><TD>(ns) </TD><TD>(ns) </TD><TD>(ns) </TD><TD/></TR><TR><TH>Tclcl (t1a) </TH><TD>CLK Period </TD><TD>CKM e 1 </TD><TD>80 </TD><TD>250 </TD><TD>N/A </TD><TD>N/A </TD><TD>Note 6 </TD></TR><TR><TH>(t1B) </TH><TD/><TD>CKM e 0 </TD><TD>40 </TD><TD>125 </TD><TD>31.25 </TD><TD>125 </TD><TD>Note 6 </TD></TR><TR><TH>Tclch (t2a) </TH><TD>CLK Low Time </TD><TD>CKM e 1 </TD><TD>35 </TD><TD/><TD>N/A </TD><TD/><TD>Note 6 </TD></TR><TR><TH>(t2b) </TH><TD/><TD>CKM e 0 </TD><TD>9 </TD><TD/><TD>7 </TD><TD/><TD>Note 7 </TD></TR><TR><TH>Tchcl (t3a) </TH><TD>CLK High Time </TD><TD>CKM e 1 </TD><TD>35 </TD><TD/><TD>N/A </TD><TD/><TD>Note 6 </TD></TR><TR><TH>(t3b) </TH><TD/><TD>CKM e 0 </TD><TD>13 </TD><TD/><TD>9 </TD><TD/><TD>Note 8 </TD></TR><TR><TH>Tch2ch1(t4) </TH><TD/><TD/><TD/><TD>10 </TD><TD/><TD>8 </TD><TD>Note 9 </TD></TR><TR><TH>Tch1ch2(t5) </TH><TD/><TD/><TD/><TD>10 </TD><TD/><TD>8 </TD><TD>Note 10 </TD></TR></Table><Sect><P>NOTES: </P></Sect><P>*16 MHz operation is available only in divide-by-2 mode (CKM strapped LOW). </P><L><Sect><LI><LI_Label>6. </LI_Label><LI_Title>At 1.5V </LI_Title></LI><LI><LI_Label>7. </LI_Label><LI_Title>At 0.8V </LI_Title></LI><LI><LI_Label>8. </LI_Label><LI_Title>At 2.0V </LI_Title></LI></Sect><LI><LI_Label>9. </LI_Label><LI_Title>CKM e 1: 3.7V to 0.8V at 16 MHz, 3.5V to 1.0V at 12.5 MHz </LI_Title></LI><LI><LI_Label>10. </LI_Label><LI_Title>CKM e 1: 0.8V to 3.7V at 16 MHz, 1.0V to 3.5V at 12.5 MHz </LI_Title></LI></L><Sect><Figure><ImageData src=""/></Figure></Sect><P>AC DRIVE AND MEASUREMENT AC SETUP, HOLD, AND DELAY TIME POINTS-CLK INPUT MEASUREMENTS-GENERAL </P><Figure><ImageData src="images/math_ic_intel_80c187_1989_img_31.jpg"/>270640 – 9 270640 – 10 </Figure><Sect><P>AC TEST LOADING ON OUTPUTS </P></Sect><Figure><ImageData src="images/math_ic_intel_80c187_1989_img_32.jpg"/>270640 – 11 </Figure><Sect><P>DATA TRANSFER TIMING (INITIATED BY CPU) DATA CHANNEL TIMING (INITIATED BY 80C187) </P></Sect><Figure><ImageData src="images/math_ic_intel_80c187_1989_img_33.jpg"/>270640 – 12 </Figure><Sect><Figure><ImageData src=""/></Figure></Sect><Figure><ImageData src="images/math_ic_intel_80c187_1989_img_35.jpg"/>270640 – 13 </Figure><Sect><P>ERROR OUTPUT TIMING </P></Sect><Figure><ImageData src="images/math_ic_intel_80c187_1989_img_36.jpg"/>270640 – 14 </Figure><Sect><P>CLK, RESET TIMING (CKM e 1) </P></Sect><Figure><ImageData src="images/math_ic_intel_80c187_1989_img_37.jpg"/>270640 – 15 </Figure><Sect><Figure><ImageData src=""/></Figure><P>CLK, NPRD, NPWR TIMING (CKM e 1) </P></Sect><Figure><ImageData src="images/math_ic_intel_80c187_1989_img_39.jpg"/>270640 – 16 </Figure><Sect><P>CLK, RESET TIMING (CKM e 0) </P></Sect><Figure><ImageData src="images/math_ic_intel_80c187_1989_img_40.jpg"/>270640 – 17 RESET must meet timing shown to guarantee known phase of internal divide by 2 circuits. </Figure><Sect><P>NOTE: </P></Sect><P>RESET, NPWR, NPRD inputs are asynchronous to CLK. Timing requirements are given for testing purposes only, to assure recognition at a specific CLK edge. </P><Sect><P>CLK, NPRD, NPWR TIMING (CKM e 0) </P></Sect><Figure><ImageData src="images/math_ic_intel_80c187_1989_img_41.jpg"/>270640 – 18 </Figure><Sect><P>RESET, BUSY TIMING </P></Sect><Figure><ImageData src="images/math_ic_intel_80c187_1989_img_42.jpg"/>270640 – 19 </Figure><Sect><Figure><ImageData src=""/></Figure><P>80C187 EXTENSIONS TO THE CPU’s INSTRUCTION SET </P><P>Instructions for the 80C187 assume one of the five forms shown in Table 12. In all cases, instructions are at least two bytes long and begin with the bit pattern 11011B, which identifies the ESCAPE class of instruction. Instructions that refer to memory operands specify addresses using the CPU’s addressing modes. </P><P>MOD (Mode field) and R/M (Register/Memory specifier) have the same interpretation as the corresponding fields of CPU instructions (refer to Programmer’s Reference Manual for the CPU). The DISP (displacement) is optionally present in instructions that have MOD and R/M fields. Its presence depends on the values of MOD and R/M, as for instructions of the CPU. </P><P>The instruction summaries that follow assume that the instruction has been prefetched, decoded, and is ready for execution; that bus cycles do not require wait states; that there are no local bus HOLD requests delaying processor access to the bus; and that no exceptions are detected during instruction execution. Timings are given in internal 80C187 clocks and include the time for opcode and data transfer between the CPU and the NPX. If the instruction has MOD and R/M fields that call for both base and index registers, add one clock. </P></Sect><Table><Caption><P>Table 12. Instruction Formats </P></Caption><TR><TH/><TH/><TH/><TH/><TH>Instruction </TH><TH/><TH/><TH>Optional Field</TH></TR><TR><TD/><TD>First Byte </TD><TD/><TD/><TD/><TD>Second Byte </TD><TD/></TR><TR><TH>1 </TH><TD>11011 </TD><TD>OPA </TD><TD>1 </TD><TD/><TD>MOD </TD><TD>1 </TD><TD>OPB </TD><TD>R/M </TD><TD>DISP </TD></TR><TR><TH>2 </TH><TD>11011 </TD><TD>MF </TD><TD>OPA </TD><TD/><TD>MOD </TD><TD>OPB * </TD><TD>R/M </TD><TD>DISP </TD></TR><TR><TH>3 </TH><TD>11011 </TD><TD>d </TD><TD>P </TD><TD>OPA </TD><TD/><TD>1 </TD><TD>1 </TD><TD>OPB * </TD><TD>ST (i) </TD><TD/></TR><TR><TH>4 </TH><TD>11011 </TD><TD>0 </TD><TD>0 </TD><TD>1 </TD><TD/><TD>1 </TD><TD>1 </TD><TD>1 </TD><TD/><TD>OP </TD></TR><TR><TH>5 </TH><TD>11011 </TD><TD>0 </TD><TD>1 </TD><TD>1 </TD><TD/><TD>1 </TD><TD>1 </TD><TD>1 </TD><TD/><TD>OP </TD></TR></Table><P>15–11 10 9 8 76543 210 </P><Sect><P>NOTES: </P></Sect><P>OP e Instruction opcode, possibly split into two fields OPA and OPB </P><P>MF e Memory Format d e Destination 00-32-Bit Real 0-Destination is ST(0) 01-32-Bit Integer 0-Destination is ST(i) </P><P>10-64-Bit Real R XOR d e 0-Destination (op) Source 11-16-Bit Integer R XOR d e 1-Source (op) Destination </P><P>*In FSUB and FDIV, the low-order bit of OPB is the R (reversed) bit </P><P>P 	e Pop ST(i) e Register Stack Element i 0-Do not pop stack 000 e Stack Top 1-Pop stack after operation 001 e Second Stack Element </P><Sect><P>ESC e 11011 </P><P>111 e Eighth Stack Element </P><Figure><ImageData src=""/></Figure></Sect><P>80C187 Extensions to the 80C186 Instruction Set 80C187 Extensions to the 80C186 Instruction Set (Continued) </P><Figure><ImageData src="images/math_ic_intel_80c187_1989_img_45.jpg"/>Encoding Clock Count Range Instruction Byte Byte Optional 32-Bit 32-Bit 64-Bit 16-Bit 0 1 Bytes 2 – 3 Real Integer Real Integer DATA TRANSFER FLD e Loada Integer/real memory to ST(0) ESC MF 1 MOD 000 R/M DISP 40 65– 72 59 67– 71 Long integer memory to ST(0) ESC 111 MOD 101 R/M DISP 90– 101 Extended real memory to ST(0) ESC 011 MOD 101 R/M DISP 74 BCD memory to ST(0) ESC 111 MOD 100 R/M DISP 296 – 305 ST(i) to ST(0) ESC 001 11000 ST(i) 16 FST e Store ST(0) to integer/real memory ESC MF 1 MOD 010 R/M DISP 58 93– 107 73 80– 93 ST(0) to ST(i) ESC 101 11010 ST(i) 13 FSTP e Store and Pop ST(0) to integer/real memory ESC MF 1 MOD 011 R/M DISP 58 93– 107 73 80– 93 ST(0) to long integer memory ESC 111 MOD 111 R/M DISP 116 – 133 ST(0) to extended real ESC 011 MOD 111 R/M DISP 83 ST(0) to BCD memory ESC 111 MOD 110 R/M DISP 542 – 564 ST(0) to ST(i) ESC 101 11001 ST (i) 14 FXCH e Exchange ST(i) and ST(0) ESC 001 11001 ST(i) 20 COMPARISON FCOM e Compare Integer/real memory to ST(0) ESC MF 0 MOD 010 R/M DISP 48 78– 85 67 77– 81 ST(i) to ST(0) ESC 000 11010 ST(i) 26 FCOMP e Compare and pop Integer/real memory to ST ESC MF 0 MOD 011 R/M DISP 48 78– 85 67 77– 81 ST(i) to ST(0) ESC 000 11011 ST(i) 28 FCOMPP e Compare and pop twice ST(1) to ST(0) 28 FTST e Test ST(0) 30 FUCOM e Unordered compare 26 FUCOMP e Unordered compare and pop 28 FUCOMPP e Unordered compare and pop twice 28 FXAM e Examine ST(0) 32-40 CONSTANTS FLDZ e Load a0.0 into ST(0) 22 FLD1 e Load a1.0 into ST(0) 26 FLDPI e Load pi into ST(0) 42 FLDL2T e Load log2(10) into ST(0) 42 Shaded areas indicate instructions not available in 8087. NOTE: a. When loading single-or double-precision zero from memory, add 5 clocks. 28 </Figure><Table><TR><TD>ESC 110 </TD><TD>1101 1001 </TD></TR><TR><TD>ESC 001 </TD><TD>1110 0100 </TD></TR><TR><TD>ESC 101 </TD><TD>11100 ST(i) </TD></TR></Table><Figure><ImageData src="images/math_ic_intel_80c187_1989_img_46.jpg"/>ESC 101 11101 ST(i) </Figure><Table><TR><TD>ESC 010 </TD><TD>1110 1001 </TD></TR><TR><TD>ESC 001 </TD><TD>11100101 </TD></TR></Table><Table><TR><TD>ESC 001 </TD><TD>1110 1110 </TD></TR><TR><TD>ESC 001 </TD><TD>1110 1000 </TD></TR><TR><TD>ESC 001 </TD><TD>1110 1011 </TD></TR><TR><TD>ESC 001 </TD><TD>1110 1001 </TD></TR></Table><Sect><Figure><ImageData src=""/></Figure></Sect><Figure><ImageData src="images/math_ic_intel_80c187_1989_img_48.jpg"/>Encoding Clock Count Range Instruction Byte Byte Optional 32-Bit 32-Bit 64-Bit 16-Bit 0 1 Bytes 2 – 3 Real Integer Real Integer CONSTANTS (Continued) FLDL2E e Load log2(e) into ST(0) ESC 001 1110 1010 42 FLDLG2 e Load log10(2) into ST(0) ESC 001 1110 1100 43 FLDLN2 e Load loge(2) into ST(0) ESC 001 1110 1101 43 ARITHMETIC FADD e Add Integer/real memory with ST(0) ESC MF 0 MOD 000 R/M DISP 44– 52 77– 92 65– 73 77– 91 ST(i) and ST(0) ESCdP0 11000 ST(i) 25– 33b FSUB e Subtract Integer/real memory with ST(0) ESC MF 0 MOD 10 R R/M DISP 44– 52 77– 92 65– 73 77– 91c ST(i) and ST(0) ESCdP0 1110 R R/M 28– 36d FMUL e Multiply Integer/real memory with ST(0) ESC MF 0 MOD 001 R/M DISP 47– 57 81– 102 68– 93 82– 93 ST(i) and ST(0) ESCdP0 1100 1 R/M 31– 59e FDIV e Divide Integer/real memory with ST(0) ESC MF 0 MOD 11 R R/M DISP 108 140 – 147f 128 142 – 146g ST(i) and ST(0) ESCdP0 1111 R R/M 90h FSQRTi e Square root ESC 001 1111 1010 124 – 131 FSCALE e Scale ST(0) by ST(1) ESC 001 1111 1101 69– 88 FPREM e Partial remainder of ST(0) d ST(1) 76– 157 FPREM1 e Partial remainder (IEEE) 97– 187 FRNDINT e Round ST(0) to integer 68– 82 FXTRACT e Extract components of ST(0) 72– 78 FABS e Absolute value of ST(0) 24 FCHS e Change sign of ST(0) 26– 27 ESC 001 1111 1000 ESC 001 1111 0101 ESC 001 1111 1100 ESC 001 1111 0100 ESC 001 1110 0001 ESC 001 1110 0000 </Figure><Sect><P>Shaded areas indicate instructions not available in 8087. </P><P>NOTES: </P><L><LI><LI_Label>b. </LI_Label><LI_Title>Add 3 clocks to the range when d e 1. </LI_Title></LI><LI><LI_Label>c. </LI_Label><LI_Title>Add 1 clock to each range when R e 1. </LI_Title></LI><LI><LI_Label>d. </LI_Label><LI_Title>Add 3 clocks to the range when d e 0. </LI_Title></LI><LI><LI_Label>e. </LI_Label><LI_Title>typical e 54 (When d e 0, 48–56, typical e 51). </LI_Title></LI><LI><LI_Label>f. </LI_Label><LI_Title>Add 1 clock to the range when R e 1. </LI_Title></LI><LI><LI_Label>g. </LI_Label><LI_Title>153–159 whenR e 1. </LI_Title></LI><LI><LI_Label>h. </LI_Label><LI_Title>Add 3 clocks to the range when d e 1. </LI_Title></LI><LI><LI_Label>i. </LI_Label><LI_Title>b0 s ST(0) s a%. </LI_Title></LI></L><Figure><ImageData src=""/></Figure></Sect><P>80C187 Extensions to the 80C186 Instruction Set (Continued) </P><Figure><ImageData src="images/math_ic_intel_80c187_1989_img_50.jpg"/>Encoding Instruction Byte Byte Optional Clock Count Range 0 1 Bytes 2 – 3 TRANSCENDENTAL FCOS e Cosine of ST(0) ESC 001 1111 1111 125 – 774j FPTANk e Partial tangent of ST(0) ESC 001 1111 0010 193 – 499j FPATAN e Partial arctangent ESC 001 1111 0011 316 – 489 FSIN e Sine of ST(0) ESC 001 1111 1110 124 – 773j FSINCOS e Sine and cosine of ST(0) ESC 001 1111 1011 196 – 811j F2XM1l e 2ST(0) b 1 ESC 001 1111 0000 213 – 478 FYL2Xm e ST(1) * log2(ST(0)) ESC 001 1111 0001 122 – 540 FYL2XP1n e ST(1) * log2(ST(0) a 1.0) ESC 001 1111 1001 259 – 549 PROCESSOR CONTROL FINIT e Initialize NPX ESC 011 1110 0011 35 FSTSW AX e Store status word ESC 111 1110 0000 17 FLDCW e Load control word ESC 001 MOD 101 R/M DISP 23 FSTCW e Store control word ESC 001 MOD 111 R/M DISP 21 FSTSW e Store status word ESC 101 MOD 111 R/M DISP 21 FCLEX e Clear exceptions ESC 011 1110 0010 13 FSTENV e Store environment ESC 001 MOD 110 R/M DISP 146 FLDENV e Load environment ESC 001 MOD 100 R/M DISP 113 FSAVE e Save state ESC 101 MOD 110 R/M DISP 550 FRSTOR e Restore state ESC 101 MOD 100 R/M DISP 482 FINCSTP e Increment stack pointer ESC 001 1111 0111 23 FDECSTP e Decrement stack pointer ESC 001 1111 0110 24 FFREE e Free ST(i) ESC 101 1100 0 ST(i) 20 FNOP e No operations ESC 001 1101 0000 14 </Figure><Sect><P>Shaded areas indicate instructions not available in 8087. </P><P>NOTES: </P></Sect><P>j. These timings hold for operands in the range lxlk q/4. For operands not in this range, up to 78 clocks may be needed to reduce the operand. </P><Sect><P>k 263</P><L><LI><LI_Label>k. </LI_Label><LI_Title>0 s lST(0) l. </LI_Title></LI><LI><LI_Label>l. </LI_Label><LI_Title>b1.0 s ST(0) s 1.0. </LI_Title></LI><LI><LI_Label>m. </LI_Label><LI_Title>0 s ST(0) k%, b% k ST(1) k a%. </LI_Title></LI><LI><LI_Label>n. </LI_Label><LI_Title>0 s lST(0)lk (2 bS(2))/2, b% k ST(1) k a%. </LI_Title></LI></L><P>DATA SHEET REVISION REVIEW </P></Sect><P>The following list represents the key differences between the -002 and the -001 version of the 80C187 data sheet. Please review this summary carefully. </P><P>1. Figure 10, titled ‘‘System Configuration for 8087-Compatible Exception Trapping’’, was replaced with a revised schematic. The previous configuration was faulty. Updated timing diagrams on Data Transfer Timing, Error Output, and RESET/BUSY. </P><P>This datasheet has been download from: </P></Part><Part><H3><Link>www.datasheetcatalog.com </Link></H3><P>Datasheets for electronics components. </P></Part></TaggedPDF-doc>