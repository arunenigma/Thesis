<?xml version="1.0" encoding="UTF-8" ?><!-- Created from PDF via Acrobat SaveAsXML --><!-- Mapping Table version: 28-February-2003 --><TaggedPDF-doc><?xpacket begin='﻿' id='W5M0MpCehiHzreSzNTczkc9d'?><?xpacket begin="﻿" id="W5M0MpCehiHzreSzNTczkc9d"?>
<x:xmpmeta xmlns:x="adobe:ns:meta/" x:xmptk="Adobe XMP Core 5.2-c001 63.139439, 2010/09/27-13:37:26        ">
   <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
      <rdf:Description rdf:about=""
            xmlns:xmp="http://ns.adobe.com/xap/1.0/">
         <xmp:CreatorTool>PScript5.dll Version 5.2</xmp:CreatorTool>
         <xmp:ModifyDate>2008-05-30T01:04:43-04:00</xmp:ModifyDate>
         <xmp:CreateDate>2008-05-29T23:51:13-04:00</xmp:CreateDate>
         <xmp:MetadataDate>2008-05-30T01:04:43-04:00</xmp:MetadataDate>
      </rdf:Description>
      <rdf:Description rdf:about=""
            xmlns:dc="http://purl.org/dc/elements/1.1/">
         <dc:format>xml</dc:format>
         <dc:title>
            <rdf:Alt>
               <rdf:li xml:lang="x-default">Microsoft Word - TA0_datasheet_revC[1]-1.doc</rdf:li>
            </rdf:Alt>
         </dc:title>
         <dc:creator>
            <rdf:Seq>
               <rdf:li>RSC</rdf:li>
            </rdf:Seq>
         </dc:creator>
      </rdf:Description>
      <rdf:Description rdf:about=""
            xmlns:pdf="http://ns.adobe.com/pdf/1.3/">
         <pdf:Producer>Acrobat Distiller 8.1.0 (Windows)</pdf:Producer>
      </rdf:Description>
      <rdf:Description rdf:about=""
            xmlns:xmpMM="http://ns.adobe.com/xap/1.0/mm/">
         <xmpMM:DocumentID>uuid:262d1b10-0b70-45be-a1e1-0532968b716b</xmpMM:DocumentID>
         <xmpMM:InstanceID>uuid:14c797db-526f-d945-b3e3-47e2bc43029a</xmpMM:InstanceID>
      </rdf:Description>
   </rdf:RDF>
</x:xmpmeta>
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                           
<?xpacket end="w"?><?xpacket end='r'?><Part><H1>Test Article 0 
Datasheet 
</H1><P>Revision C 
January 24, 2008 
</P><P>University of Southern California 
Information Sciences Institute 
</P><Sect><H3>Table of Content </H3><P>Table of Content ............................................................................................................................. 2 
</P><P>1. Introduction ................................................................................................................................. 3 
</P><P>2. Test Article and Floating-Point Unit Overview .......................................................................... 3 
2-1. Overall Test Article Architecture .................................................................................... 3 
2-2. Overall FPU Architecture ................................................................................................ 4 
2-3. Supported Operations and Major Datapath Components ................................................ 6 
2-4. Instruction issue rate (latency and throughput) ............................................................... 6 
</P><P>3. Floating-Point Number Representation (Single Precision – 32bit) ............................................ 8 
3-1. Floating-point number ..................................................................................................... 8 
3-2. Rounding ....................................................................................................................... 11 
3-3. Exceptions ..................................................................................................................... 12 
</P><P>4. Instructions ................................................................................................................................ 14 
4-1. Addition/Subtraction ..................................................................................................... 14 
4-2. Absolute Value/Negation .............................................................................................. 18 
4-3. Float-to-Integer .............................................................................................................. 21 
4-4. Integer-to-Float .............................................................................................................. 24 
4-5. Multiplication ................................................................................................................ 27 
4-6. Division ......................................................................................................................... 30 
</P><P>5. Test Article Pinout .................................................................................................................... 37 
</P><P>6. Timing Information ................................................................................................................... 38 
</P><P>7. Physical Chip Dimensions and Core Locations ........................................................................ 40 
</P></Sect><Sect><H3>1. Introduction </H3><P>This document represents the overall architecture of a test article designed at University of Southern California Information Sciences Institute. <Annot>The test article contains four variants of a </Annot>single-precision floating-point unit. First, an overview and block diagram are given for both the test article and floating-point unit. Then, floating-point number representation and algorithms used for each instruction are discussed. The FPU architecture including instruction latency and throughput is then presented. Finally, chip pinout and timing information is provided. </P><P><Annot>This FPU implements a subset of the functionality specified in the IEEE-754 floating-point </Annot>standard. Only single-precision numbers are supported and the only supported rounding mode is “round to nearest even if tie”. This implementation does not support denormalized inputs; thus, it is not fully IEEE-754 compliant with respect to gradual underflow.  <Annot>Similarly, the </Annot>implementation of the inexact exception generation for the division operation is not fully IEEE754 compliant. </P></Sect><Sect><H3>2. Test Article and Floating-Point Unit Overview 2-1. Overall Test Article Architecture </H3><P>This test article contains four variants of a single-precision floating-point unit (FPU). The four FPU variants are connected together very simply by connecting all FPU inputs together and multiplexing FPU outputs.  Therefore, the test article chip signals are identical to the signals required for each FPU, with the addition of two select bits for multiplexing between the outputs of the four FPU variants. A depiction of the test article organization is shown below. </P><Figure><ImageData src="images/test_article0_img_0.jpg"/></Figure><P>Test Article Inputs/Outputs </P><L><L><LI><LI_Label>• </LI_Label><LI_Title>Inputs </LI_Title></LI><L><LI><LI_Label>– </LI_Label><LI_Title>sel[1:0] : 2-bit selector for FPU output multiplexer – opcode[2:0] : 3-bit opcode input for 8 operations </LI_Title></LI><LI><LI_Label>– </LI_Label><LI_Title>clk 	   : Clock signal </LI_Title></LI><LI><LI_Label>– </LI_Label><LI_Title>resetn 	   : Active-low synchronous reset signal </LI_Title></LI><LI><LI_Label>– </LI_Label><LI_Title>en_input 	: Pipeline enable signal for FPU inputs </LI_Title></LI><LI><LI_Label>– </LI_Label><LI_Title>en 	: Pipeline enable signal </LI_Title></LI><LI><LI_Label>– 	</LI_Label><LI_Title>A[31;0], B[31:0] : Operand A and Operand B 
(MSB = A[31], B[31]) 
</LI_Title></LI><LI><LI_Label>– </LI_Label><LI_Title>start_div	  : Start signal for division operation </LI_Title></LI></L></L><L><LI><LI_Label>• </LI_Label><LI_Title>Outputs </LI_Title></LI><L><LI><LI_Label>– 	</LI_Label><LI_Title>R[31:0] : FPU result output 
(MSB = R[31]) 
</LI_Title></LI><LI><LI_Label>– </LI_Label><LI_Title>D0 	: Divide_By_Zero exception flag </LI_Title></LI><LI><LI_Label>– </LI_Label><LI_Title>IV 	: Invalid exception flag </LI_Title></LI><LI><LI_Label>– </LI_Label><LI_Title>IX 	: Inexact exception flag </LI_Title></LI><LI><LI_Label>– </LI_Label><LI_Title>OV 	: Overflow exception flag </LI_Title></LI><LI><LI_Label>– </LI_Label><LI_Title>UD 	: Underflow exception flag </LI_Title></LI></L></L></L><P>Given that the test article simply consists of four variants of the same FPU architecture, the majority of the remainder of this document focuses on the FPU design. </P><Sect><H4>2-2. Overall FPU Architecture </H4><P><Annot>The FPU has a 5-stage pipelined architecture with a 2-stage pipelined multiplier for an </Annot>optimized area-performance result. The overall block diagram is presented below. </P><P>clk, resetn opcode[2:0] A[31:0] B[31:0] start_div en_input </P><Figure><ImageData src="images/test_article0_img_1.jpg"/>Stage 1 : Operand Formatter Operand Swap  ROM Access en Stage 2 : Exponent Difference → Fraction Alignment Multiplier (stage 1) Stage 3 : Fraction Add/Sub → Leading Zero Detect Multiplier (stage 2) Stage 4 : Fraction Normalization → Rounding Stage 5 : Result Formatter Square/Cube Unit <Caption><P>R[31:0] D0 IV IX OV UD </P></Caption></Figure></Sect><Sect><H4>FPU inputs/outputs </H4><L><L><LI><LI_Label>• 	</LI_Label><LI_Title>Inputs – opcode[2:0] : 3-bit opcode input for 8 operations </LI_Title></LI><L><LI><LI_Label>– </LI_Label><LI_Title>clk 	   : Clock signal </LI_Title></LI><LI><LI_Label>– </LI_Label><LI_Title>resetn 	   : active-low synchronous reset signal </LI_Title></LI><LI><LI_Label>– </LI_Label><LI_Title>en_input 	: Pipeline enable signal for FPU inputs </LI_Title></LI><LI><LI_Label>– </LI_Label><LI_Title>en 	: Pipeline enable signal </LI_Title></LI><LI><LI_Label>– 	</LI_Label><LI_Title>A[31;0], B[31:0] : Operand A and Operand B (MSB = A[31], B[31]) </LI_Title></LI><LI><LI_Label>– </LI_Label><LI_Title>start_div	  : Start signal for division operation </LI_Title></LI></L></L><LI><LI_Label>• </LI_Label><LI_Title>Outputs </LI_Title></LI></L><L><LI><LI_Label>– 	</LI_Label><LI_Title>R[31:0] : FPU result output 
(MSB = R[31]) 
</LI_Title></LI><LI><LI_Label>– </LI_Label><LI_Title>D0 	: Divide_By_Zero exception flag </LI_Title></LI><LI><LI_Label>– </LI_Label><LI_Title>IV 	: Invalid exception flag </LI_Title></LI><LI><LI_Label>– </LI_Label><LI_Title>IX 	: Inexact exception flag </LI_Title></LI><LI><LI_Label>– </LI_Label><LI_Title>OV 	: Overflow exception flag </LI_Title></LI><LI><LI_Label>– </LI_Label><LI_Title>UD 	: Underflow exception flag </LI_Title></LI></L></Sect><Sect><H4>2-3. Supported Operations and Major Datapath Components </H4><P>The ISI FPU implementation supports 8 instructions, and these instructions are encoded with 3bit binary numbers: opcode[2:0] </P><P>OP_ADD (Addition) : 000 OP_SUB (Subtraction) : 001 OP_F2I (Float-to-Integer) : 010 OP_I2F (Integer-to-Float) : 011 OP_NEG (Negation) : 100 OP_ABS (Absolute) : 101 OP_MUL (Multiplication) : 110 OP_DIV (Division) : 111 </P><P>The major datapath components used in the FPU are listed below: </P><L><LI><LI_Label>– </LI_Label><LI_Title>Adder 	: 9-bit x 2, 32-bit, 34-bit </LI_Title></LI><LI><LI_Label>– </LI_Label><LI_Title>Incrementer 	: 9-bit, 34-bit </LI_Title></LI><LI><LI_Label>– </LI_Label><LI_Title>Multiplier 	: 33-bit by 26-bit (2-stage) </LI_Title></LI><LI><LI_Label>– </LI_Label><LI_Title>Shifter 	: Left (32-bit), Right (32-bit) </LI_Title></LI><LI><LI_Label>– </LI_Label><LI_Title>Comparator 	: 31-bit, 5-bit </LI_Title></LI><LI><LI_Label>– </LI_Label><LI_Title>Counter 	: 3-bit </LI_Title></LI><LI><LI_Label>– 	</LI_Label><LI_Title>Special components: Operand formatters, Operand status checker, Stage controllers, RSA (right shift amount) generator, Leading-zero detector, Sticky-bit generators, Rounding logic, Squaring unit, Cubing unit, Accumulator, Exception generator, Result formatter, ROM (128 by 7-bit) </LI_Title></LI><LI><LI_Label>– 	</LI_Label><LI_Title>Other components: pipeline registers, muxes </LI_Title></LI></L></Sect><Sect><H4>2-4. Instruction issue rate (latency and throughput) </H4><P>(1) Division: non-linear pipeline </P><P><Annot>The latency of the division instruction is 12 clock cycles, but another division instruction can be </Annot>issued every 5 clock cycles after the previous division instruction. If the next instruction immediately subsequent to a division instruction is not a division operation, the external </P><P><Annot>scheduler must wait 8 cycles to issue that instruction</Annot>. <Annot>The division instruction requires an extra </Annot>signal, start_div, to initiate the division process called. For more information, refer to section 4-6. </P><Table><TR><TH>1 </TH><TD>2 </TD><TD>3 </TD><TD>4 </TD><TD>5 </TD><TD>6 </TD><TD>7 </TD><TD>8 B </TD><TD>9 </TD><TD>10 </TD><TD>11 </TD><TD>12 </TD></TR><TR><TH>S1 </TH></TR><TR><TH/><TD>S2 </TD><TD>S2 </TD><TD>S2 </TD><TD>S2 </TD></TR><TR><TD/><TD>S3 </TD><TD>S3 </TD><TD><Figure><ImageData src="images/test_article0_img_2.jpg"/></Figure></TD><TD>S3 </TD><TD><Figure><ImageData src="images/test_article0_img_3.jpg"/></Figure></TD><TD>S3 </TD></TR><TR><TD/><TD>S4 </TD><TD>S4 </TD><TD/><TD>S4 </TD><TD/><TD>S4</TD></TR><TR><TD/><TD>AX </TD><TD/><TD>Qt </TD></TR><TR><TD/><TD>S5 </TD><TD/><TD/><TD>S5 </TD></TR><TR><TD/><TD/></TR></Table><P>[ Pipeline diagram of OP_DIV ] </P><P>OP_DIV OP_DIV OP_DIV OP_DIV 5 cycles </P><P><Figure><ImageData src="images/test_article0_img_4.jpg"/></Figure>5 cycles </P><P><Figure><ImageData src="images/test_article0_img_5.jpg"/></Figure>5 cycles </P><Figure><ImageData src="images/test_article0_img_6.jpg"/></Figure><Figure><ImageData src="images/test_article0_img_7.jpg"/></Figure><Figure><ImageData src="images/test_article0_img_8.jpg"/></Figure><P>[ Example of consecutive division instruction ] </P><P>(2) Instructions other than division </P><P><Annot>For all instructions other than division, processing occurs in a linear pipeline fashion. Thus the </Annot>latency is 5 clock cycles and an instruction can be issued at every clock cycle. </P><Figure><ImageData src="images/test_article0_img_9.jpg"/></Figure><P>[ Pipeline diagram of other instructions ] </P><Figure><ImageData src="images/test_article0_img_10.jpg"/></Figure><P>[ Example of mixed instruction stream] </P></Sect></Sect><Sect><H3>3. Floating-Point Number Representation (Single Precision – 32bit) </H3><Sect><H4>3-1. Floating-point number </H4><P>The designer of a floating-point representation must find a compromise between size of the fraction and the size of the exponent because a fixed word size means you must take a bit from one to add a bit to the other. This trade-off is between accuracy and range: increasing the size of fraction enhances the accuracy of the fraction, while increasing the size of the exponent increases the range of numbers that can be represented. The data format of a single-precision floating-point number as described in the IEEE-754 standard is presented below. </P><P>(-1)S × 2(EXP-127) × (1.FRAC) </P><Figure><ImageData src="images/test_article0_img_11.jpg"/> The IEEE-754 standard uses a sign-magnitude representation. </Figure><L><LI><LI_Label>• 	</LI_Label><LI_Title>S : Sign bit (1 bit) 1 = negative 0 = positive </LI_Title></LI><LI><LI_Label>• </LI_Label><LI_Title>EXP : Exponent (8 bit) is biased by 127 </LI_Title></LI></L><P>Biased representation: Since the exponent can be positive or negative, some method must be chosen to represent its sign. The IEEE standard does not use either sign/magnitude method or two’s complement method, but instead uses a biased representation. In the case of single precision, where the exponent is stored in 8 bits, the bias is 127. What this means is that if e is the value of the exponent bits interpreted as an unsigned integer, then the exponent of the floating-point number is e – 127. Referring to the table below, single precision has emax = 127, emin = -126. The reason for having |emin| &lt; emax is so that the reciprocal of the </P><P>1</P><P>smallest number ( ) will not overflow. Although it is true that the reciprocal of the </P><P>2e min </P><P>largest number will underflow, underflow is usually less serious than overflow. </P><P>• FRAC : Fraction (23 bit) – also called as mantissa or significand </P><P>In the case of normalized floating-point numbers, the most significant bit of the fraction is always 1, and there is no reason to waste a bit of storage representing it. Formats that use this trick are said to have a “hidden” bit. So the fraction is 24 bits, even though it is encoded using 23 bits. Therefore a leading 1 is implicit if the data is a normalized number: Frac = 1.xxxx….xxxx. </P><Table><TR><TD><Figure><ImageData src="images/test_article0_img_12.jpg"/></Figure></TD><TD/></TR><TR><TD>Normalized Number Denormalized Number </TD><TD>(-1)S × 2(Exp-127) × (1.Frac) (-1)S × 2(Exp-126) × (0.Frac) </TD></TR><TR><TD>Positive Zero </TD><TD>S = 0, Exp = 0, Frac = 0 </TD></TR><TR><TD>Negative Zero </TD><TD>S = 1, Exp = 0, Frac = 0 </TD></TR><TR><TD>Signaling NaN ( Not a Number) </TD><TD>S = u, Exp = 255, Frac ≠ 0, FracMSB = 1 </TD></TR><TR><TD>Quiet NaN </TD><TD>S = u, Exp = 255, Frac ≠ 0, FracMSB = 0 </TD></TR><TR><TD>Positive Infinity </TD><TD>S = 0, Exp = 255, Frac = 0 </TD></TR><TR><TD>Negative Infinity </TD><TD>S = 1, Exp = 255, Frac = 0 </TD></TR></Table><Figure><ImageData src="images/test_article0_img_13.jpg"/></Figure><P>[ IEEE-754 floating-point data formats ] </P><P>(1) Normalized numbers </P><P>Real numbers in the following range can be represented as normalized single-precision numbers:  </P><P>2-126 × 1.0000….0000 ≤ |n| ≤ 2127 × 1.1111….1111 </P><L><L><LI><LI_Label>(2)</LI_Label><LI_Title> Zeros </LI_Title></LI><LI>Since the sign bit can take on two different values, there are two distinct zeros, +0 and -0. The IEEE standard defines comparison so that -0 = +0, rather than -0 &lt; +0. When a multiplication or division involves a signed zero, the usual sign rules apply in computing the sign of the answer. Another example of the use of signed zero concerns underflow and functions that have a discontinuity at 0. Although distinguishing between +0 and -0 has advantages, it can occasionally be confusing. For example, signed zero destroys the relation x = y ↔ 1/x = 1/y, which is false when x = +0 and y = -0 (1/x = ∞, 1/y = -∞). However, the IEEE committee decided that the advantages of utilizing the sign of zero outweighed the disadvantages. </LI></L><LI><LI_Label>(3)</LI_Label><LI_Title> NaN (Not a Number) </LI_Title></LI></L><P>NaNs are the result of any invalid operation. Using NaNs allows the compiler to schedule instructions speculatively, and only at the end of a chain of computation check the validity of the result. Traditionally, the computation of 0/0 or <Figure><ImageData src="images/test_article0_img_14.jpg"/></Figure>−1 has been treated as an unrecoverable error which causes a computation to halt. This problem can be avoided by introducing a special value called NaN, and specifying that the computation of </P><P>expressions like 0/0 and <Figure><ImageData src="images/test_article0_img_15.jpg"/></Figure>−1 produce NaN, rather than halting. </P><P>Implementations are free to put system-dependent information into the fraction field. Thus there is not a unique NaN, but rather a whole family of NaNs. When a NaN and an ordinary floating-point number are combined, the result should be the same as the NaN operand. Thus if the result of a long computation is a NaN, the system-dependent information in the fraction will be the information that was generated when the first NaN in the computation was generated, with one caveat. If both operands are NaNs, then the result will be one of those NaNs, but it might not be the NaN that was generated first. </P><P>Any operation on a quiet NaN does not, in general, cause an exception. The NaN gets propagated to the output. An operation on a signaling NaN causes an exception. </P><L><L><LI><LI_Label>(4)</LI_Label><LI_Title> Infinity </LI_Title></LI><LI>Just as NaNs provide a way to continue a computation when expressions like 0/0 or <Figure><ImageData src="images/test_article0_img_16.jpg"/></Figure>−1 are encountered, infinities provide a way to continue when an overflow occurs. This is much safer than simply returning the largest representable number. You can distinguish between getting ∞ because of overflow and getting ∞ because of division by zero by checking the exception flags. </LI></L><LI><LI_Label>(5)</LI_Label><LI_Title> Denormalized numbers </LI_Title></LI></L><P>Denormalized numbers are too small to be represented in the normalized format and allow underflowing calculations to proceed with limited precision. </P><P>The IEEE standard uses denormalized numbers. They are the most controversial part of the standard and probably accounted for the long delay in the approval of the  IEEE-754 standard. Most high performance hardware that claims to be IEEE compatible does not support denormalized numbers directly, but rather traps when consuming or producing denormals, and leaves it to software to simulate the IEEE standard. </P><P>The range of real numbers that can be represented as denormalized single precision numbers is:  </P><P>2-126 × 0.0000….0001 ≤ |n| ≤ 2-126 × 0.1111….1111 </P></Sect><Sect><H4>3-2. Rounding </H4><P>Squeezing infinitely many real numbers into a finite number of bits requires an approximate representation. The result of a floating-point calculation must often be rounded in order to fit back into its finite representation. IEEE-754 operations are specified to produce a result as if carried to infinite precision and then rounded according to one of four rounding modes. (Round toward +∞, Round toward -∞, Round toward 0, Round to nearest even if tie) </P><P>Provided there is no overflow, underflow, or invalid operation exceptions, IEEE-754 standard guarantees that the computed result is within ½ulp. The only supported rounding mode in the ISI FPU design is “Round to nearest even if tie”. </P><L><LI><LI_Label>• 	</LI_Label><LI_Title>G(Guard), R(Round), S(Sticky) – 3 redundant bits are used to get ½ ulp (units in the last place) error between real result and computed result </LI_Title></LI><LI><LI_Label>• 	</LI_Label><LI_Title>Round to nearest (even if tie): </LI_Title></LI></L><P>When the result is in “halfway” between two floating-point numbers (GRS = 100), round up only if result becomes even number; otherwise, round down (In decimal, 10.5 becomes 10, but 11.5 becomes 12). </P><Table><TR><TH>L </TH><TH>G </TH><TH>R </TH><TH>S </TH><TH>Roundup </TH><TH>L </TH><TH>G </TH><TH>R </TH><TH>S </TH><TH>Roundup </TH></TR><TR><TH>0 </TH><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>1 </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD></TR><TR><TH>0 </TH><TD>0 </TD><TD>0 </TD><TD>1 </TD><TD>0 </TD><TD>1 </TD><TD>0 </TD><TD>0 </TD><TD>1 </TD><TD>0 </TD></TR><TR><TH>0 </TH><TD>0 </TD><TD>1 </TD><TD>0 </TD><TD>0 </TD><TD>1 </TD><TD>0 </TD><TD>1 </TD><TD>0 </TD><TD>0 </TD></TR><TR><TH>0 </TH><TD>0 </TD><TD>1 </TD><TD>1 </TD><TD>0 </TD><TD>1 </TD><TD>0 </TD><TD>1 </TD><TD>1 </TD><TD>0 </TD></TR><TR><TH>0 </TH><TD>1 </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>1 </TD><TD>1 </TD><TD>0 </TD><TD>0 </TD><TD>1 </TD></TR><TR><TH>0 </TH><TD>1 </TD><TD>0 </TD><TD>1 </TD><TD>1 </TD><TD>1 </TD><TD>1 </TD><TD>0 </TD><TD>1 </TD><TD>1 </TD></TR><TR><TH>0 </TH><TD>1 </TD><TD>1 </TD><TD>0 </TD><TD>1 </TD><TD>1 </TD><TD>1 </TD><TD>1 </TD><TD>0 </TD><TD>1 </TD></TR><TR><TH>0 </TH><TD>1 </TD><TD>1 </TD><TD>1 </TD><TD>1 </TD><TD>1 </TD><TD>1 </TD><TD>1 </TD><TD>1 </TD><TD>1 </TD></TR></Table><P>[ Truth table of “Round to nearest even if tie ] </P><P>*Roundup = LG + GR + GS = G(L + R + S) </P></Sect><Sect><H4>3-3. Exceptions </H4><P>When an exception condition occurs in IEEE arithmetic, the default is to deliver a result and continue, but exception flags will also be set. The IEEE standard divides exceptions into 5 classes and there is a separate status flag for each class of exception. </P><L><L><LI><LI_Label>• </LI_Label><LI_Title>Overflow : </LI_Title></LI><LI>The overflow exception is raised when the exponent is too large to be represented in the exponent field. When the | result | &gt; 2127 × 1.1111….1111 (the largest normalized number), then set result to ±∞ </LI></L><LI><LI_Label>• </LI_Label><LI_Title>Underflow : </LI_Title></LI></L><P>The underflow exception is raised when the result is too small to be represented in the normalized form.  In other words, when the nonzero fraction is so small that it cannot be represented (the negative exponent is too large to fit in the exponent field), the underflow exception is raised. When the | result | &lt; 2-126 × 0.0000….0001 (the smallest denormalized number), then set result to ±0. Addition/Subtraction operations do not produce underflow exceptions in IEEE-754. </P><P>o Gradual underflow (when the computed result is a denormalized number) : </P><P>Recall that to simplify the implementation, the ISI FPU does not support denormalized operands. When gradual underflow occurs, i.e., | result | is less than the minimum normalized number but greater than or equal to the minimum denormalized </P><P>number, the ISI FPU design sets the output to the minimum normalized number (±2126 × 1.0000….0000 = x00800000 or x80800000) and also raises both the “Underflow” and “Inexact” exceptions. </P><P>• Inexact : </P><P>The inexact exception is raised when the result of a floating-point operation is not exact. </P><P>This is easy to detect by checking G, R and S bits. 
GRS = 000 : the result is exact 
GRS != 000 : the result involves rounding, therefore inexact 
</P><L><L><LI><LI_Label>• </LI_Label><LI_Title>Divide by Zero : </LI_Title></LI><LI>The divide by zero exception is raised when the operation A/B, B=0 and A!=0 occurs. </LI></L><LI><LI_Label>• </LI_Label><LI_Title>Invalid : </LI_Title></LI></L><P>Any operation on a signaling NaN (sNaN), ∞±∞, 0×(±∞), 0/0, (±∞)/(±∞) and comparison that involves a NaN will cause invalid exception. The default result of an operation that causes an invalid exception is to return NaN. </P></Sect><Sect><H4>4. Instructions 4-1. Addition/Subtraction </H4><P>oprA[31:0] 	oprB[31:0] </P><P>Operand 
Selection 
</P><P>Fraction 
Alignment 
</P><P>Fraction 
Calculation 
</P><P>Exponent 
Adjustment 
</P><P>Fraction 
Normalization 
</P><P>Rounding </P><Figure><ImageData src="images/test_article0_img_17.jpg"/>Operand Formatter Alignment shifter FracAdder ExpA ExpB FracA FracB ExpG ExpL FracG FracL’ExpG-ExpL FracG FracL |oprA| &gt; |oprB| Comparator ExpAdder Leading Zero Nomalization shifter Adder (+1) FracZ’FracZ’’Adder (+1) Result Formatter FracZ ExpZ’ExpZ Result[31:0] FracZ’’’ExpG ExpAdder Rounding Logic Sticky RSA RSA </Figure><P>[ Basic datapath of OP_ADD and OP_SUB ] </P><L><LI><LI_Label>• 	</LI_Label><LI_Title>Internal format of operands Input operands should be reformatted to be suitable for required operations. </LI_Title></LI><LI><LI_Label>• </LI_Label><LI_Title>Added bits </LI_Title></LI></L><Figure><ImageData src="images/test_article0_img_18.jpg"/></Figure><P>Redundant bit for exponent computation: opr[36] = 0 </P><P>Redundant bit for fraction computation: opr[27] = 0 </P><P>Hidden bit: opr[26] = 1, if input operand is a normalized number, </P><P>otherwise 0 </P><P>G,R,S bits are added for rounding purpose: opr[2:0] = 000 </P><P>*Z: Output format </P><P>• Sign bit calculation </P><P>Addition </P><P>If (SignA == SignB), SignZ = SignA </P><P>If (SignA != SignB), SignZ = (|oprA| &gt; |oprB|) ? SignA : SignB) </P><P>Subtraction </P><P>If (SignA == SignB), SignZ = ((|oprA| &gt; |oprB|) ? SignA : SignB) </P><P>If (SignA != SignB), SignZ = SignA </P><P>• Exponent and Fraction calculation </P><L><L><LI><LI_Label>(1)</LI_Label><LI_Title> Operand selection (operand comparison and swap) ExpG = (|oprA| &gt; |oprB|) ? ExpA : ExpB ExpL = (|oprA| &gt; |oprB|) ? ExpB : ExpA FracG = (|oprA| &gt; |oprB|) ? FracA : FracB FracL’ = (|oprA| &gt; |oprB|) ? FracB : FracA </LI_Title></LI><LI>Required datapath: comparator(31bit), muxes(9bit × 2, 28bit × 2) </LI></L><L><LI><LI_Label>(2)</LI_Label><LI_Title> Fraction alignment right-shift amount calculation RSA = ExpG – ExpL </LI_Title></LI><LI> Required datapath: subtractor(9bit) </LI></L><L><LI><LI_Label>(3)</LI_Label><LI_Title> Fraction alignment (shift the fraction of smaller operand to right) FracL = (FracL’ &gt;&gt; RSA) </LI_Title></LI><LI>Required datapath: right-shifter(28bit), sticky-bit generator </LI></L><L><LI><LI_Label>(4)</LI_Label><LI_Title> Fraction calculation FracZ’ = FracG ± FracL </LI_Title></LI><LI>Required datapath: adder/subtractor(28bit) </LI></L><L><LI><LI_Label>(5)</LI_Label><LI_Title> Fraction normalization and Exponent adjustment FracZ’’ = FracZ’ &lt;&lt; leadingZero(FracZ’) ExpZ’ = ExpG – leadingZero(FracZ’) </LI_Title></LI><LI>Required datapath: leading-zero detector, left-shifter(28bit), 
subtractor(9bit) 
</LI></L><L><LI><LI_Label>(6)</LI_Label><LI_Title> Rounding FracZ’’’ = (roundup == 1) ? FracZ’’ + 1 : FracZ’’ FracZ = (MSB(FracZ’’’) == “10.”) ? (FracZ’’’ &gt;&gt; 1) : FracZ’’’ ExpZ = (MSB(FracZ’’’) == “10.”) ? ExpZ’ + 1 : ExpZ’ </LI_Title></LI><LI>Required datapath: rounding logic, incrementer(25bit, 9bit), mux </LI></L><LI><LI_Label>(7)</LI_Label><LI_Title> Output formatting and Exception generation </LI_Title></LI></L><P>• Exceptions </P><P>These cases do not raise exceptions, but result should be set to special value. When either one of inputs is qNaN, set result to qNaN When either ∞ ± Norm, set result to ∞. </P><L><L><LI><LI_Label>(1)</LI_Label><LI_Title> Invalid IV = 1 when ∞ + (-∞), (-∞)+(∞), ∞ -∞, (-∞) - (-∞),</LI_Title></LI><LI> set result to qNaN. 
IV = 1 when either one of inputs is sNaN, set result to qNaN. 
IV = 0 when either one of inputs is qNaN, set result to qNaN. 
Otherwise IV = 0. 
</LI></L><LI><LI_Label>(2)</LI_Label><LI_Title> Overflow OV = 1 when ExpZ ≥ 255, set result to ∞. Otherwise OV = 0. </LI_Title></LI><LI><LI_Label>(3)</LI_Label><LI_Title> Divide by Zero D0 = 0. </LI_Title></LI><L><LI><LI_Label>(4)</LI_Label><LI_Title> Underflow – underflow in Addition/Subtraction operation actually means that </LI_Title></LI><LI>                          the result is a denormalized number UD = 1 when ExpG ≤ Leading Zero, set result to the smallest normalized number Otherwise UD = 0. </LI></L><LI><LI_Label>(5)</LI_Label><LI_Title> Inexact </LI_Title></LI></L><P>IX = 1 when OV = 1, 
IX = 1 when  the result is a denormalized number. 
IX = 1 when GRS != 000. 
Otherwise IX = 0. 
</P></Sect><Sect><H4>4-2. Absolute Value/Negation </H4><P>oprA[31:0] No input </P><P>No swap </P><P>Fraction Alignment </P><P>FracA + 0 </P><P>Set leading-zero to 0 </P><P>No 
Normalization 
Shift 
</P><P>No Rounding 
</P><Figure><ImageData src="images/test_article0_img_19.jpg"/>Operand Formatter Alignment shifter FracAdder ExpA 0 FracA 0 ExpA 0 FracA 0 ExpG-ExpL FracA 0 Comparator ExpAdder Leading Zero Nomalization shifter FracA FracA ExpA ExpAdder Sticky RSA RSA 0 </Figure><Figure><ImageData src="images/test_article0_img_20.jpg"/></Figure><P>ExpA </P><P>FracA </P><Figure><ImageData src="images/test_article0_img_21.jpg"/>Adder (+1) Adder (+1) Result Formatter FracA ExpA Result[31:0] Rounding Logic </Figure><P>[ Basic datapath of OP_ABS and OP_NEG ] </P><L><LI><LI_Label>• </LI_Label><LI_Title>Internal format of operands – input is oprA. </LI_Title></LI><L><LI><LI_Label>• </LI_Label><LI_Title>Added bits </LI_Title></LI><LI>Hidden bit: oprA[26] = 1, if input operand is a normalized number, otherwise 0 G,R,S bits are initialized with = 000 </LI></L><LI><LI_Label>• </LI_Label><LI_Title>Sign bit calculation </LI_Title></LI></L><P>The same datapath is used as in two-operand operations, with the internal format of oprB initialized with an appropriate value even though there is no input. </P><Figure><ImageData src="images/test_article0_img_22.jpg"/></Figure><P>Absolute Value 
SignZ = 0 (set it to positive) 
</P><P>Negation 
SignZ = ~SignA 
</P><P>• Exponent and Fraction calculation </P><L><LI><LI_Label>(1)</LI_Label><LI_Title> Operand selection (operand comparison and swap) – No swap. ExpG = ExpA ExpL = 0 FracG = FracA FracL’ = 0 </LI_Title></LI><LI><LI_Label>(2)</LI_Label><LI_Title> Fraction alignment right-shift amount calculation RSA = ExpG – ExpL = ExpA – 0 = ExpA </LI_Title></LI><LI><LI_Label>(3)</LI_Label><LI_Title> Fraction alignment (shift the fraction of smaller operand to right) FracL = (FracL’ &gt;&gt; RSA) = (0 &gt;&gt; ExpA) = 0 </LI_Title></LI><LI><LI_Label>(4)</LI_Label><LI_Title> Fraction calculation FracZ’ = FracG + 0 = FracA </LI_Title></LI><LI><LI_Label>(5)</LI_Label><LI_Title> Fraction normalization and Exponent adjustment FracZ’’ = FracZ’ &lt;&lt; leadingZero(FracZ’) = FracZ’ &lt;&lt; 0 = FracA ExpZ’ = ExpG – leadingZero(FracZ’) = ExpG – 0 = ExpA </LI_Title></LI><LI><LI_Label>(6)</LI_Label><LI_Title> Rounding because GRS = 000, there is no rounding. FracZ = FracA ExpZ = ExpA </LI_Title></LI><L><LI><LI_Label>(7)</LI_Label><LI_Title> Output formatting and Exception generation </LI_Title></LI><LI>• Exceptions – there are no exceptions for Absolute Value/Negation operations. </LI></L><LI><LI_Label>(1)</LI_Label><LI_Title> Invalid IV = 0. </LI_Title></LI><LI><LI_Label>(2)</LI_Label><LI_Title> Overflow OV = 0. </LI_Title></LI><LI><LI_Label>(3)</LI_Label><LI_Title> Divide by Zero D0 = 0. </LI_Title></LI><LI><LI_Label>(4)</LI_Label><LI_Title> Underflow UD = 0. </LI_Title></LI><LI><LI_Label>(5)</LI_Label><LI_Title> Inexact IX = 0. </LI_Title></LI></L></Sect><Sect><H4>4-3. Float-to-Integer </H4><P>oprA[31:0] No input </P><P>Operand Swap </P><P>Fraction Alignment </P><P>Fraction Calculation </P><P>Set leading-zero 
to 0 
</P><P>No 
Normalization 
Shift 
</P><P>No Rounding 
</P><Figure><ImageData src="images/test_article0_img_23.jpg"/></Figure><Figure><ImageData src="images/test_article0_img_24.jpg"/>Operand Formatter Alignment shifter FracAdder ExpA 157 FracA 0 157 ExpA 0 FracA 157-ExpA 0 FracL Comparator ExpAdder Leading Zero Nomalization shifter FracZ’FracZ’157 ExpAdder StickyRSA RSA 0 </Figure><P>157 </P><P>Rounding 0 Logic </P><Figure><ImageData src="images/test_article0_img_25.jpg"/>Adder (+1) Adder (+1) Result Formatter FracZ157 Result[31:0] </Figure><P>[ Basic datapath of OP_F2I ] </P><P>• Internal format of operands – input is oprA. </P><P>FracZ’ </P><P>Fraction field of the internal format is promoted to 32 bits wide in order to support Floatto-Integer operation because data format of integer is 32 bits. Exponent field of oprB is initialized with 157, because RSA = 157 – Exp is used to shift FRAC to convert floating-point input to an integer number. </P><Figure><ImageData src="images/test_article0_img_26.jpg"/>•Added bits </Figure><P>Hidden bit: oprA[26] = 1, if input operand is a normalized number, </P><P>otherwise 0 
G,R,S bits are initialized with = 000 
oprA[3:0] bits are also initialized to 0000. 
</P><L><LI><LI_Label>• 	</LI_Label><LI_Title>Sign bit calculation 
SignZ = SignA 
</LI_Title></LI><LI><LI_Label>• 	</LI_Label><LI_Title>Exponent and Fraction calculation </LI_Title></LI></L><L><LI><LI_Label>(1)</LI_Label><LI_Title> Selection (operand comparison and swap) – always swap. ExpG = 157 ExpL = ExpA FracG = 0 FracL’ = FracA </LI_Title></LI><LI><LI_Label>(2)</LI_Label><LI_Title> Alignment right shift amount calculation RSA = 157 – ExpA </LI_Title></LI><L><LI><LI_Label>(3)</LI_Label><LI_Title> Alignment (shift the fraction of smaller operand to right) FracL = (FracA &gt;&gt; RSA) </LI_Title></LI><LI>Changes in datapath: right-shifter(28bit → 32bit) </LI></L><LI><LI_Label>(4)</LI_Label><LI_Title> Fraction calculation A 2’s complement calculation is performed when the input is a negative floating-point number. If (SignA == 0), FracZ’ = FracL + 0 If (SignA == 1), FracZ’ = (~FracL) + 1 </LI_Title></LI><LI><LI_Label>(5)</LI_Label><LI_Title> Fraction normalization and Exponent adjustment Set leading-zero to 0 FracZ’’ = FracZ’ &lt;&lt; leadingZero(FracZ’) = FracZ’ &lt;&lt; 0 ExpZ’ = ExpG – leadingZero(FracZ’) = 157 – 0 = 157 </LI_Title></LI><LI><LI_Label>(6)</LI_Label><LI_Title> Rounding there is no rounding for OP_F2I.. FracZ = FracZ’’ ExpZ = 157 </LI_Title></LI><L><LI><LI_Label>(7)</LI_Label><LI_Title> Output formatting and Exception generation R [30:0] = FracZ[30:0] </LI_Title></LI><LI>• Exceptions </LI></L><LI><LI_Label>(1)</LI_Label><LI_Title> Invalid IV = 1 when input is too large to be represented as an integer. Otherwise IV = 0 When IV = 1 and SignA = 0, set result to ∞(integer). </LI_Title></LI><LI><LI_Label>(2)</LI_Label><LI_Title> Overflow OV = 0. </LI_Title></LI><LI><LI_Label>(3)</LI_Label><LI_Title> Divide by Zero D0 = 0. </LI_Title></LI><LI><LI_Label>(4)</LI_Label><LI_Title> Underflow UD = 0. </LI_Title></LI><LI><LI_Label>(5)</LI_Label><LI_Title> Inexact IX = 1 when there are any ones in the fraction field which are right-shifted out. </LI_Title></LI></L><P> Changes in datapath: adder/subtractor(28bit → 32bit) </P></Sect><Sect><H4>4-4. Integer-to-Float </H4><P>oprA[31:0] No input </P><P>Operand Swap </P><P>No 
Alignment 
Shift 
</P><P>Fraction 
Calculation 
</P><P>Exponent 
Caculation 
</P><P>Fraction 
Normalization 
</P><P>Rounding </P><Figure><ImageData src="images/test_article0_img_27.jpg"/>Operand Formatter Alignment shifter FracAdder 0 157 Integer 0 157 0 0 Integer 157 0 Integer Comparator ExpAdder Leading Zero Nomalization shifter Adder (+1) FracZ’FracZ’’Adder (+1) Result Formatter FracZ ExpZ’ExpZ Result[31:0] FracZ’’’157 ExpAdder Rounding Logic StickyRSA 0 </Figure><P>[ Basic datapath of OP_I2F ] </P><P>• Internal format of operands – input is oprA. </P><P>Fraction field of the internal format is changed to 32bit wide in order to support Integer-
to-Float because data format of integer is 32bit. 
Exponent field of oprB should be initialized with 157 because,  
157 minus the exponent of the position of the leading-zero will be the exponent of the 
result. 
</P><Figure><ImageData src="images/test_article0_img_28.jpg"/>•Added bits </Figure><P>oprA[41] is initialized with the sign of integer. </P><L><LI><LI_Label>• 	</LI_Label><LI_Title>Sign bit calculation 
SignZ = SignA 
</LI_Title></LI><LI><LI_Label>• 	</LI_Label><LI_Title>Exponent and Fraction calculation </LI_Title></LI></L><L><LI><LI_Label>(1)</LI_Label><LI_Title> Selection (operand comparison and swap) – always swap. ExpG = 157 ExpL = 0 FracG = 0 FracL’ = integer input </LI_Title></LI><LI><LI_Label>(2)</LI_Label><LI_Title> Alignment right shift amount calculation RSA = 157 – 0 = 157 </LI_Title></LI><LI><LI_Label>(3)</LI_Label><LI_Title> Alignment (shift the fraction of smaller operand to right) Set RSA to 0 FracL = (FracL’ &gt;&gt; RSA) = FracL’ </LI_Title></LI><LI><LI_Label>(4)</LI_Label><LI_Title> Fraction calculation A 2’s complement calculation is performed when the input is a negative integer number. If (SignA == 0), FracZ’ = FracL + 0 If (SignA == 1), FracZ’ = (~FracL) + 1 </LI_Title></LI><LI><LI_Label>(5)</LI_Label><LI_Title> Fraction normalization and Exponent adjustment FracZ’’ = FracZ’ &lt;&lt; leadingZero(FracZ’) ExpZ’ = ExpG – leadingZero(FracZ’) </LI_Title></LI><L><LI><LI_Label>(6)</LI_Label><LI_Title> Rounding FracZ’’’ = (roundup == 1) ? FracZ’’ + 1 : FracZ’’ </LI_Title></LI><LI>FracZ = (MSB(FracZ’’’) == “10.”) ? (FracZ’’’ &gt;&gt; 1) : FracZ’’’ 
ExpZ = (MSB(FracZ’’’) == “10.”) ? ExpZ’ + 1 : ExpZ’ 
</LI></L><L><LI><LI_Label>(7)</LI_Label><LI_Title> Output formatting and Exception generation </LI_Title></LI><LI>• 	Exceptions – because data format of integer(32bit) is larger than the fraction field of floating-point(24bit), there can be an inexact exception. </LI></L><LI><LI_Label>(1)</LI_Label><LI_Title> Invalid IV = 0. </LI_Title></LI><LI><LI_Label>(2)</LI_Label><LI_Title> Overflow OV = 0. </LI_Title></LI><LI><LI_Label>(3)</LI_Label><LI_Title> Divide by Zero D0 = 0. </LI_Title></LI><LI><LI_Label>(4)</LI_Label><LI_Title> Underflow UD = 0. </LI_Title></LI><LI><LI_Label>(5)</LI_Label><LI_Title> Inexact IX = 1 when the computed result is not exact. Otherwise IX = 0. </LI_Title></LI></L></Sect><Sect><H4>4-5. Multiplication </H4><P>oprA[31:0] oprB[31:0] </P><P>No Swap </P><P>Fraction 
Multiplication 
</P><P>Exponent 
Computation 
</P><P>Rounding </P><Figure><ImageData src="images/test_article0_img_29.jpg"/>Operand Formatter Adder (+) ExpA ExpB FracA FracB ExpA ExpB FracA FracB Comparator FracZ’’FracMultiplier ExpZ’Adder (-127) FracZ’Rounding Logic</Figure><Figure><ImageData src="images/test_article0_img_30.jpg"/>Adder (+1) Adder (+1) Result Formatter FracZExpZ ExpZ’’FracZ’’’Result[31:0] </Figure><P>[ Basic datapath of OP_MUL ] </P><L><L><LI><LI_Label>• </LI_Label><LI_Title>Internal format of operands </LI_Title></LI><LI>Required operations for floating-point multiplication are relatively simpler as compared to other instructions. </LI></L><LI><LI_Label>• </LI_Label><LI_Title>Added bits </LI_Title></LI></L><Figure><ImageData src="images/test_article0_img_31.jpg"/></Figure><P>Redundant bit for exponent computation: opr[32] = 0 
Hidden bit: opr[23] = 1, if input operand is a normalized number, 
</P><P>otherwise 0 There is no need to add redundant 0 bit to the fraction field. There is no need to add G,R,S bits for multiplication operations. </P><L><L><LI><LI_Label>• </LI_Label><LI_Title>Sign bit calculation </LI_Title></LI><LI>if (SignA == SignB), SignZ = 0 (positive) 
if (SignA != SignB), SignZ = 1 (negative) 
</LI></L><LI><LI_Label>• </LI_Label><LI_Title>Exponent and Fraction calculation </LI_Title></LI></L><L><LI><LI_Label>(1)</LI_Label><LI_Title> Operand selection (operand comparison and swap) – No swap ExpG = ExpA ExpL = ExpB FracG = FracA FracL = FracB </LI_Title></LI><L><LI><LI_Label>(2)</LI_Label><LI_Title> Exponent computation ExpZ’ = ExpA + ExpB ExpZ’’ = ExpZ’ – 127 </LI_Title></LI><LI>Required datapath: adder(9bit), decrementer(9bit) </LI></L><L><LI><LI_Label>(3)</LI_Label><LI_Title> Fraction multiplication FracZ’ = FracA × FracB </LI_Title></LI><LI>Required datapath: multiplier(24bit × 24bit) </LI></L><L><LI><LI_Label>(4)</LI_Label><LI_Title> Sticky bit generation and Rounding decision FracZ’’ = FracZ’, G, R, S </LI_Title></LI><LI>Required datapath: rounding logic, mux </LI></L><L><LI><LI_Label>(5)</LI_Label><LI_Title> Rounding </LI_Title></LI><LI>FracZ’’’ = (roundup == 1) ? FracZ’’ + 1 : FracZ’’ 
FracZ = (MSB(FracZ’’’) == “10.”) ? FracZ’’’ &gt;&gt; 1 : FracZ’’’ 
ExpZ = (MSB(FracZ’’’) == “10.”) ? ExpZ’’ + 1 : ExpZ’’ 
</LI></L><LI><LI_Label>(6)</LI_Label><LI_Title> Output formatting and Exception generation </LI_Title></LI></L><P>• Exceptions </P><P>These cases do not raise exceptions, but result should be set to special value. When either one of inputs is qNaN, set result to qNaN When ∞ × Norm, set result to ∞. When 0 × Norm, set result to 0. </P><L><LI><LI_Label>(1)</LI_Label><LI_Title> Invalid IV = 1 when ∞ × 0, set result to qNaN. IV = 1 when either one of inputs is sNaN, set result to qNaN. Otherwise IV = 0. </LI_Title></LI><LI><LI_Label>(2)</LI_Label><LI_Title> Overflow OV = 1 when ExpZ ≥ 255, set result to ∞. Otherwise OV = 0. </LI_Title></LI><LI><LI_Label>(3)</LI_Label><LI_Title> Divide by Zero D0 = 0. </LI_Title></LI><LI><LI_Label>(4)</LI_Label><LI_Title> Underflow UD = 1 when ExpG ≤ –24, set result to 0. Otherwise UD = 0. </LI_Title></LI><LI><LI_Label>(5)</LI_Label><LI_Title> Inexact IX = 1 when OV = 1, IX = 1 when GRS != 000. IX = 0 when either one of inputs is NaN. Otherwise IX = 0. </LI_Title></LI><LI><LI_Label>(6)</LI_Label><LI_Title> Denormalized output When –24 ≤ ExpZ ≤ 0, set result to the smallest normalized number, and set UD = 1, IX = 1. </LI_Title></LI></L><P>4-6. Division </P></Sect><Sect><H4>4-6-1. Algorithm </H4><P>The most complex datapath component of the division operation is the fraction divider. To calculate a quotient, the core operation of fraction division is computing the reciprocal of the divisor; then the quotient can be obtained by multiplying the reciprocal by the dividend. In order to calculate the reciprocal of the divisor, the ISI FPU implementation uses a binomial expansion algorithm using Taylor series expansion. The equation is </P><P>1 23</P><P>q = a ÷ b = a ×≈ aX (1+ (1− bX ) + (1− bX ) + (1− bX ))</P><P>b </P><P>where X is the initial approximation of divisor b and is determined by using a ROM as a lookup table. </P><Figure><ImageData src="images/test_article0_img_32.jpg"/>This division algorithm is suitable for a parallel hardware concept since the quotient can be obtained directly without iterations by using parallel powering units such as a squaring unit and a </Figure><P>cubing unit, which compute the higher-order terms significantly faster than traditional multipliers with a relatively small hardware overhead.  </P><P>oprA[31:0] oprB[31:0] </P><Figure><ImageData src="images/test_article0_img_33.jpg"/>Operand Formatter Adder (-) ExpA ExpB FracA FracB ExpA ExpB FracA FracB Comparator Adder (+1) Adder (+1) Result Formatter FracZExpZ Multiplier ExpZ’Adder (+127) ExpZ’’FracZ’Rounding Logic ROM X FracA’BX Adder (1-BX) 1 -BX (1 -BX)2 (1 -BX)3 Accunulator X AX S Q Multiplier Adder (+1) Qt Multiplier FracB QtB Qt Multiplier </Figure><P>Result[31:0] </P><P>[ Direct implementation of division algorithm with rounding ] </P><L><LI><LI_Label>• </LI_Label><LI_Title>Internal format of operands </LI_Title></LI><LI><LI_Label>• </LI_Label><LI_Title>Added bits </LI_Title></LI></L><Figure><ImageData src="images/test_article0_img_34.jpg"/></Figure><P>Redundant bit for exponent computation: opr[33] = 0 Redundant bit for fraction computation: opr[24] = 0 Hidden bit: opr[23] = 1, if input operand is a normalized number </P><P>otherwise 0 There is no need to add G,R,S bits for division operations </P><L><L><LI><LI_Label>• </LI_Label><LI_Title>Sign bit calculation </LI_Title></LI><LI>if (SignA == SignB), SignZ = 0 (positive) 
if (SignA != SignB), SignZ = 1 (negative) 
</LI></L><LI><LI_Label>• </LI_Label><LI_Title>Exponent calculation </LI_Title></LI></L><L><L><LI><LI_Label>(1)</LI_Label><LI_Title> Exponent computation ExpZ’ = ExpA – ExpB ExpZ’’ = ExpZ’ + 127 </LI_Title></LI><LI>Required datapath: subtractor(9bit), incrementer(9bit) </LI></L><LI><LI_Label>(2)</LI_Label><LI_Title> Rounding ExpZ = (MSB(FracZ’) == “10.”) ? ExpZ’’ + 1 : ExpZ’’ </LI_Title></LI></L><P>Required datapath: incrementer(9bit) </P><P>• Fraction calculation </P><L><L><LI><LI_Label>(1)</LI_Label><LI_Title> ROM access and fraction alignment X = ROM output FracA = (FracA &gt; FracB) ? FracA : FracA &lt;&lt; 1 </LI_Title></LI><LI>Fraction A is adjusted so that quotient is always normalized Required datapath: ROM(128 × 7), mux </LI></L><LI><LI_Label>(2)</LI_Label><LI_Title> Calculate BX BX = FracB × X </LI_Title></LI><L><LI><LI_Label>(3)</LI_Label><LI_Title> Calculate AX and 1 – BX AX = FracA × X SC = 1 – BX </LI_Title></LI><LI>Required datapath: multiplier(25bit × 8bit), incrementer(32bit) </LI></L><L><LI><LI_Label>(4)</LI_Label><LI_Title> Square/Cubic terms generation and accumulation S = 1 + SC + SC2 + SC3 </LI_Title></LI><LI>Required datapath: squaring unit, cubing unit, accumulator </LI></L><L><LI><LI_Label>(5)</LI_Label><LI_Title> Calculate intermediate quotient Q = AX × S </LI_Title></LI><LI>Required datapath: multiplier(33bit × 33bit) </LI></L><L><LI><LI_Label>(6)</LI_Label><LI_Title> Truncate Q to Qt Qt = truncate(Q) + ½ ulp </LI_Title></LI><LI>Required datapath: incrementer(25bit) </LI></L><L><LI><LI_Label>(7)</LI_Label><LI_Title> Calculate QtB : this value will be used for rounding decision QtB = Qt × FracB </LI_Title></LI><LI>Required datapath: multiplier(25bit × 24bit) </LI></L><L><LI><LI_Label>(8)</LI_Label><LI_Title> Rounding FracZ’ = (roundup == 1) Qt + 1 : Qt FracZ = (MSB(FracZ’) == “10.”) ? FracZ’ &gt;&gt; 1 : FracZ’ </LI_Title></LI><LI>Required datapath: incrementer(25bit), mux </LI></L><LI><LI_Label>(9)</LI_Label><LI_Title> Output formatting and Exception generation </LI_Title></LI></L><P>Required datapath: multiplier(24bit × 8bit) </P><P>• Exceptions </P><P>These cases do not raise exceptions, but result should be set to special value. When either one of inputs is qNaN, set result to qNaN. When ∞ / 0, set result to ∞. When ∞ / Norm, set result to ∞. When 0 / ∞, set result to 0. When Norm / ∞, set result to 0. </P><L><L><LI><LI_Label>(1)</LI_Label><LI_Title> Invalid </LI_Title></LI><LI>IV = 1 when 0 / 0, set result to qNaN. 
IV = 1 when ∞ / ∞, set result to qNaN. 
IV = 1 when either one of inputs is sNaN, set result to qNaN. 
Otherwise IV = 0. 
</LI></L><LI><LI_Label>(2)</LI_Label><LI_Title> Overflow OV = 1 when ExpZ ≥ 255, set result to ∞. Otherwise OV = 0. </LI_Title></LI><LI><LI_Label>(3)</LI_Label><LI_Title> Divide by Zero D0 = 1 when Norm / 0, set result to ∞. </LI_Title></LI><LI><LI_Label>(4)</LI_Label><LI_Title> Underflow UD = 1 when ExpG ≤ –24, set result to 0. Otherwise UD = 0. </LI_Title></LI><L><LI><LI_Label>(5)</LI_Label><LI_Title> Inexact IX = 1 when OV = 1, IX = 0 when either one of inputs is NaN. Otherwise IX = 0. </LI_Title></LI><LI>Practically multiplicative algorithms such as the one implemented do not produce IEEE754 inexact exceptions correctly. In order to generate correct inexact exceptions, software support for IEEE-754 compatibility is required for division operations. </LI></L><LI><LI_Label>(6)</LI_Label><LI_Title> Denormalized output When –24 ≤ ExpZ ≤ 0, set result to the smallest normalized number, and set UD = 1, IX = 1. </LI_Title></LI></L></Sect><Sect><H4>4-6-2. Implementation of FP-MUL/DIV fused unit </H4><P>There are three major multiply operations in the Taylor-series expansion algorithm with powering units to produce a quotient with 0.5 ulp (unit in the last place) error. One additional multiply operation is required for exact rounding to generate IEEE-754 floating-point standard compliant results. Even though the Taylor-series expansion algorithm with powering units exhibits the highest performance among multiplicative algorithms, it consumes a larger area because the architecture consists of four multipliers, which is not suitable for area-critical applications. The ISI FPU uses a fused floating-point multiply-divide architecture based on Taylor-series expansion with powering units where all multiply operations are executed by one multiplier to maximize the area efficiency, while achieving high performance by using a pipelined architecture. By sharing the 2-stage pipelined multiplier among the multiply operations in the algorithm, the latency becomes longer (12 clock cycles) than the direct implementation of the original algorithm (8 clock cycles). However, through careful pipeline scheduling, a moderately high throughput (one completion every 5 clock cycles) for consecutive divide instructions is achieved with an area that is 1.6 times smaller than the direct implementation.  </P><Figure><ImageData src="images/test_article0_img_35.jpg"/></Figure><P>[ Hardware structure of proposed Multiplier/Divider fused unit ] </P><Figure><ImageData src="images/test_article0_img_36.jpg"/>Cycle Operation Pipeline Stage </Figure><Figure><ImageData src="images/test_article0_img_37.jpg"/></Figure><Figure><ImageData src="images/test_article0_img_38.jpg"/></Figure><P>1 X = ROM(b) </P><P>MD1 </P><P>2 </P><P>M1 = B×X (stage1) </P><P>MD2 </P><P>3 </P><P>M2 = B×X (stage2), M1 = A×X (stage1) </P><P>MD3/MD2 </P><P>4 </P><P>SC = 1–M2, M2 = A×X (stage2) </P><P>MD4/MD3 </P><P>S = 1+SC+SC2+SC3, AX = M2 </P><P>MD5’/MD4 </P><P>5 </P><P>6 </P><P>M1 = AX×S (stage1) </P><P>MD2 </P><P>7 </P><P>M2 = AX×S (stage2) </P><P>MD3 </P><P>8 </P><P>Qt = truncate(M2)+1 </P><P>MD4 </P><P>9 </P><P>M1 = B×Qt (stage1) </P><P>MD2 </P><P>M2 = B×Qt (stage2) </P><P>MD3</P><P>10 </P><P>11 </P><P>R = round(Qt) </P><P>MD4 </P><P>Quotient = format(R) </P><P>MD5</P><P>12 </P><P>[ Summary of operations in each cycle] </P></Sect></Sect><Sect><H3>5. Test Article Pinout </H3><P>The table below lists the pad-to-signal assignment for the test article die as well as the pin-tosignal assignment for test articles that are bonded in PGA181 packages. Pad numbering is consistent with the MOSIS convention for this package; namely, pad 1 is the rightmost pad on the top edge of the chip, and numbering proceeds counter-clockwise. For more detail on this PGA181 package and numbering conventions, refer to documentation found at http://www.mosis.com/Technical/Packaging/Ceramic/menu-pkg-ceramic.html. Not shown on the MOSIS bonding diagrams is locator pin E5, which is a no-connect. </P><Table><TR><TD>Pad Number / Bonding Finger </TD><TD>Pin </TD><TD>Signal </TD><TD>Signal Type </TD><TD>Pad Number / Bonding Finger </TD><TD>Pin </TD><TD>Signal </TD><TD>Signal Type </TD><TD>Pad Number / Bonding Finger </TD><TD>Pin </TD><TD>Signal </TD><TD>Signal Type </TD></TR><TR><TD>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 </TD><TD>B1 C1 D1 E1 F1 G1 H1 C2 D2 E2 F2 G2 H2D3 E3 F3 G3 H3 E4 F4 G4 H4 H5 J4 K4 L4 M4 J3 K3 L3 M3N3J2 K2 L2 M2 N2 P2 J1 K1 L1 M1 N1 P1 R1 M5 M6 M7R2 R3 R4 R5 R6 R7 P3 P4 P5 P6 P7 N4 </TD><TD>NC opcode0 opcode1 opcode2 clk padVDD padVSS en en_input start_div resetn padVDD  padVSS sel0 sel1 A0 A1 padVDD padVSS coreVDD coreVSS A2 A3 A4 coreVDD coreVSS padVDD padVSS A5 A6 A7 A8 A9 padVDD padVSS A10 A11 A12 A13 padVDD padVSS A14 A15 A16 A17 padVDD padVSS A18 A19 A20 A21 padVDD padVSS A22 A23 A24 A25 padVDD padVSS A26 </TD><TD>NC I I I I 2.5V GND I I I I 2.5V GND I I I I 2.5V GND 1.2V GND I I I 1.2V GND 2.5V GND I I I I I 2.5V GND I I I I 2.5V GND I I I I 2.5V GND I I I I 2.5V GND I I I I 2.5V GND I </TD><TD>61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 </TD><TD>N5 N6 N7 M8 M9 M10 M11 L8 M12 N8 N9 N10 N11 N12 N13 P8 P9 P10 P11 P12 P13 P14 R8 R9 R10 R11 R12 R13 R14 R15 P15 N15 M15 L15 K15 J15 H15 N14 M14 L14 K14 J14 H14 M13 L13 K13 J13 H13 L12 K12 J12 H12 H11 G12 F12 E12 D12 G13 F13 E13 </TD><TD>A27 A28 A29 padVDD padVSS A30 A31 B0 B1 padVDD padVSS coreVDD coreVSS B2 B3 B4 B5 padVDD padVSS B6 B7 B8 B9 padVDD padVSS B10 B11 B12 padVDD padVSS padVDD padVSS B13 B14 B15 B16 padVDD padVSS B17 B18 B19 B20 padVDD padVSS B21 B22 B23 B24 B25 coreVDD coreVSS padVDD padVSS B26 B27 B28 B29 coreVDD coreVSS padVDD </TD><TD>I I I 2.5V GND I I I I 2.5V GND 1.2V GND I I I I 2.5V GND I I I I 2.5V GND I I I 2.5V GND 2.5V GND I I I I 2.5V GND I I I I 2.5V GND I I I I I 1.2V GND 2.5V GND I I I I 1.2V GND 2.5V </TD><TD>121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 </TD><TD>D13 C13 G14 F14 E14 D14 C14 B14 G15 F15 E15 D15 C15 B15 A15 D11 D10 D9 A14 A13 A12 A11 A10 A9 B13 B12 B11 B10 B9 C12 C11 C10 C9 D8 D7 D6 D5 E8 D4 C8 C7 C6 C5 C4 C3 B8 B7 B6 B5 B4 B3 B2 A8 A7 A6 A5 A4 A3 A2 A1 </TD><TD>padVSS B30 B31 D0 padVDD padVSS IV IX OV UD padVDD padVSS R0 R1 R2 padVDD padVSS R3 R4 R5 R6 R7 padVDD padVSS R8 R9 R10 R11 padVDD padVSS R12 R13 R14 R15 padVDD padVSS R16 R17 R18 R19 coreVDD coreVSS padVDD padVSS R20 R21 R22 R23 padVDD padVSS R24 R25 R26 R27 padVDD padVSS R28 R29 R30 R31 </TD><TD>GND I I O 2.5V GND O O O O 2.5V GND O O O 2.5V GND O O O O O 2.5V GND O O O O 2.5V GND O O O O 2.5V GND O O O O 1.2V GND 2.5V GND O O O O 2.5V GND O O O O 2.5V GND O O O O </TD></TR></Table><P>37 
</P></Sect><Sect><H3>6. Timing Information </H3><P>All timing information below is based on simulation at worst-case conditions (T = 125°C, Vdd = 1.08V). For simplicity, all inputs have been grouped together.  While set-up times and hold times vary among inputs, the values listed below represent the worst-case values needed for correct operation. </P><P>th</P><P>tsu tpdseq </P><P>CLK </P><P>resetn, opcode[2:0],
 A[31:0], B[31:0], en, 
en_input, start_div 
</P><P>R[31:0], D0, IV, 
IX, OV, UD 
</P><Figure><ImageData src="images/test_article0_img_39.jpg"/></Figure><Figure><ImageData src="images/test_article0_img_40.jpg"/></Figure><Figure><ImageData src="images/test_article0_img_41.jpg"/>stable <Caption><P>out0 </P></Caption></Figure><Table><TR><TH>Parameter </TH><TH>Value </TH></TR><TR><TD>tsu</TD><TD> 2ns </TD></TR><TR><TD>th</TD><TD> 1ns </TD></TR><TR><TD>tpdseq</TD><TD> 6ns </TD></TR></Table><P>In addition to this sequential timing information, there is one combinational path between inputs and outputs involving the output multiplexer select bits, sel[1:0].  </P><Figure><ImageData src="images/test_article0_img_42.jpg"/>Parameter Value tpdcomb 4ns </Figure><P>Functional Testing Strategy </P><P>An approach for applying input stimuli and sampling outputs to perform functional testing is to apply input stimuli changes at the falling edge of the clk signal and sample outputs at the rising edge of clk. This approach was used in simulation to verify the design.  As can be ascertained from the above timing data, such an approach should work up to a frequency of 167MHz, as limited by the tpdseq value, assuming that outputs sampled during any cycle in which sel[1:0] signals change are don’t-cares.  </P></Sect><Sect><H3>7. Physical Chip Dimensions and Core Locations </H3><P>The design submitted for fabrication was prepared with version V1.2.0.2CP of the IBM 9LP PDK and measured 3.52mm x 3.52mm.  With the inclusion of scribe lanes and other margins (refer to http://www.mosis.com/products/assembly/#die-size for examples), the anticipated die size for TA0 is 3.7mm x 3.7mm. The fiducial provided by IBM contains marking identifiers in the lower left and upper right corners of the die and was included in the design file.  Refer to the figure below, which shows relative locations of fiducial markings and the four FPU cores. Each FPU core is approximately 400μm on a side (some layers extend to the left of or below the 0,0 origin by 260nm causing the total size to be slightly larger than 400μm). Additionally, metal test structures were located in the chip design. The gdsii for these metal test structures (filename mtest2.gds) can be found in the design repository at the same directory level as the golden core gdsii. The table below provides x-y coordinate information for the points denoted in the figure. Note that each character in the fiducial lettering is comprised of multiple polygons. </P><P><Figure><ImageData src="images/test_article0_img_43.jpg"/>FPUAFPUB FPUC FPUD 1234A 1234A IBM </Figure>Upper pattern in metal1 Lower pattern in poly </P><P>Metal test structures </P><P>IBM logo in metal1 </P><P>[ Depiction of TA0 Physical Organization (not to scale)] </P><Table><TR><TH>Point of Interest </TH><TH>Coordinates (μm) </TH></TR><TR><TH>x </TH><TH>y </TH></TR><TR><TH>Lower left corner of lower left polygon of the “1” in the polysilicon “1234A” fiducial </TH><TD>3378.675 </TD><TD>3378.675 </TD></TR><TR><TH>Upper right corner of upper right polygon of the “M” in the “IBM” fiducial </TH><TD>141.325 </TD><TD>141.325 </TD></TR><TR><TH>Origin (0,0) of FPUA </TH><TD>1823.48 </TD><TD>1295.34 </TD></TR><TR><TH>Origin (0,0) of FPUB </TH><TD>1823.48 </TD><TD>1853.10 </TD></TR><TR><TH>Origin (0,0) of FPUC </TH><TD>1296.24 </TD><TD>1295.34 </TD></TR><TR><TH>Origin (0,0) of FPUD </TH><TD>1296.24 </TD><TD>1853.10 </TD></TR><TR><TH>Lower left corner of metal test structures </TH><TD>320.92 </TD><TD>3081.38 </TD></TR><TR><TH>Upper right corner of metal test structures </TH><TD>329.95 </TD><TD>3193.02 </TD></TR></Table></Sect></Part></TaggedPDF-doc>