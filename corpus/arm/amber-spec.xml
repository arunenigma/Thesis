<?xml version="1.0" encoding="UTF-8" ?><!-- Created from PDF via Acrobat SaveAsXML --><!-- Mapping Table version: 28-February-2003 --><TaggedPDF-doc><?xpacket begin='﻿' id='W5M0MpCehiHzreSzNTczkc9d'?><?xpacket begin="﻿" id="W5M0MpCehiHzreSzNTczkc9d"?>
<x:xmpmeta xmlns:x="adobe:ns:meta/" x:xmptk="Adobe XMP Core 5.2-c001 63.139439, 2010/09/27-13:37:26        ">
   <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
      <rdf:Description rdf:about=""
            xmlns:xmp="http://ns.adobe.com/xap/1.0/">
         <xmp:CreateDate>2009-11-05T22:47:10Z</xmp:CreateDate>
         <xmp:CreatorTool>Writer</xmp:CreatorTool>
      </rdf:Description>
      <rdf:Description rdf:about=""
            xmlns:pdf="http://ns.adobe.com/pdf/1.3/">
         <pdf:Producer>LibreOffice 3.4</pdf:Producer>
      </rdf:Description>
      <rdf:Description rdf:about=""
            xmlns:dc="http://purl.org/dc/elements/1.1/">
         <dc:format>xml</dc:format>
      </rdf:Description>
   </rdf:RDF>
</x:xmpmeta>
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                           
<?xpacket end="w"?><?xpacket end='r'?><bookmark-tree><bookmark title="1 Introduction"><destination structID="LinkTarget_412"/><bookmark title="1.1 Amber 23 Features"><destination structID="LinkTarget_413"/></bookmark><bookmark title="1.2 Amber 25 Features"><destination structID="LinkTarget_414"/></bookmark></bookmark><bookmark title="2 Amber 23 Pipeline Architecture"><destination structID="LinkTarget_415"/><bookmark title="2.1 ALU"><destination structID="LinkTarget_416"/></bookmark><bookmark title="2.2 Pipeline Operation"><destination structID="LinkTarget_417"/><bookmark title="2.2.1 Load Example"><destination structID="LinkTarget_418"/></bookmark><bookmark title="2.2.2 Store Example"><destination structID="LinkTarget_419"/></bookmark></bookmark></bookmark><bookmark title="3 Instruction Set"><destination structID="LinkTarget_420"/></bookmark><bookmark title="4 Instruction Set Encoding"><destination structID="LinkTarget_421"/><bookmark title="4.1 Condition Encoding"><destination structID="LinkTarget_422"/></bookmark><bookmark title="4.2 Opcode Encoding"><destination structID="LinkTarget_423"/></bookmark><bookmark title="4.3 Shifter Operand Encoding"><destination structID="LinkTarget_424"/><bookmark title="4.3.1 Encode immediate value"><destination structID="LinkTarget_425"/></bookmark></bookmark><bookmark title="4.4 Register transfer offset encoding"><destination structID="LinkTarget_426"/></bookmark><bookmark title="4.5 Shift Encoding"><destination structID="LinkTarget_427"/></bookmark><bookmark title="4.6 Load &amp; Store Multiple"><destination structID="LinkTarget_428"/></bookmark><bookmark title="4.7 Branch offset"><destination structID="LinkTarget_429"/></bookmark><bookmark title="4.8 Booth's Multiplication Algorithm"><destination structID="LinkTarget_430"/></bookmark></bookmark><bookmark title="5 Interrupts"><destination structID="LinkTarget_431"/></bookmark><bookmark title="6 Registers"><destination structID="LinkTarget_432"/></bookmark><bookmark title="7 Cache"><destination structID="LinkTarget_433"/></bookmark><bookmark title="8 Amber Project"><destination structID="LinkTarget_434"/><bookmark title="8.1 Amber Port List"><destination structID="LinkTarget_435"/></bookmark><bookmark title="8.2 Amber 23 Verilog Files"><destination structID="LinkTarget_436"/></bookmark><bookmark title="8.3 Amber 25 Verilog Files"><destination structID="LinkTarget_437"/></bookmark><bookmark title="8.4 Project Directory Structure"><destination structID="LinkTarget_438"/></bookmark></bookmark><bookmark title="9 Amber FPGA System"><destination structID="LinkTarget_439"/></bookmark><bookmark title="10 Verilog simulations"><destination structID="LinkTarget_440"/><bookmark title="10.1 Installing the Amber project"><destination structID="LinkTarget_441"/></bookmark><bookmark title="10.2 Installing the Compiler"><destination structID="LinkTarget_442"/><bookmark title="10.2.1 GNU Tools Usage"><destination structID="LinkTarget_443"/></bookmark></bookmark><bookmark title="10.3 Running Simulations"><destination structID="LinkTarget_444"/><bookmark title="10.3.1 With Modelsim"><destination structID="LinkTarget_445"/></bookmark><bookmark title="10.3.2 With Veritak"><destination structID="LinkTarget_446"/></bookmark></bookmark><bookmark title="10.4 Simulation output files"><destination structID="LinkTarget_447"/><bookmark title="10.4.1 Disassembly Output File"><destination structID="LinkTarget_448"/></bookmark><bookmark title="10.4.2 VCD Output File"><destination structID="LinkTarget_449"/></bookmark><bookmark title="10.4.3 Program Trace Utility"><destination structID="LinkTarget_450"/></bookmark></bookmark><bookmark title="10.5 Hardware Tests"><destination structID="LinkTarget_451"/></bookmark><bookmark title="10.6 C Programs"><destination structID="LinkTarget_452"/><bookmark title="10.6.1 Boot Loader"><destination structID="LinkTarget_453"/></bookmark><bookmark title="10.6.2 Hello World"><destination structID="LinkTarget_454"/></bookmark><bookmark title="10.6.3 Ethmac Test"><destination structID="LinkTarget_455"/></bookmark></bookmark><bookmark title="10.7 Linux"><destination structID="LinkTarget_456"/><bookmark title="10.7.1 Using the pre-compiled memory image"><destination structID="LinkTarget_457"/></bookmark><bookmark title="10.7.2 Building the kernel from source"><destination structID="LinkTarget_458"/></bookmark></bookmark></bookmark><bookmark title="11 FPGA Synthesis"><destination structID="LinkTarget_459"/><bookmark title="11.1 Synthesis Results"><destination structID="LinkTarget_460"/></bookmark></bookmark><bookmark title="12 Using Boot-Loader"><destination structID="LinkTarget_461"/><bookmark title="12.1 Configure HyperTerminal"><destination structID="LinkTarget_462"/></bookmark><bookmark title="12.2 Configure the FPGA"><destination structID="LinkTarget_463"/></bookmark></bookmark><bookmark title="13 License"><destination structID="LinkTarget_464"/></bookmark></bookmark-tree><Part><H1>Amber Open Source Project 
</H1><Sect><H1>Amber 2 Core Specification 
May 2011 
</H1><Sect><H2>Table of Contents </H2><P><Link>1 Introduction </Link><Link>...................................................................................................................................... </Link><Link>3 
</Link></P><P><Link>1.1 Amber 23 Features <Link>......................................................................................................... </Link></Link><Link>4 
</Link></P><P><Link>1.2 Amber 25 Features <Link>......................................................................................................... </Link></Link><Link>4 
</Link><Link>2 Amber 23 Pipeline Architecture </Link><Link>............................................................................. </Link><Link>6 
</Link></P><P><Link>2.1 ALU <Link>............................................................................................................................................. </Link></Link><Link>7 
</Link></P><P><Link>2.2 Pipeline Operation <Link>........................................................................................................... </Link></Link><Link>8 
</Link><Link>3 Instruction Set </Link><Link>............................................................................................................................... </Link><Link>11 
</Link><Link>4 Instruction Set Encoding </Link><Link>................................................................................................ </Link><Link>14 
</Link></P><P><Link>4.1 Condition Encoding <Link>......................................................................................................... </Link></Link><Link>14 
</Link></P><P><Link>4.2 Opcode Encoding <Link>............................................................................................................ </Link></Link><Link>15 
</Link></P><P><Link>4.3 Shifter Operand Encoding <Link>......................................................................................... </Link></Link><Link>15 
</Link></P><P><Link>4.4 Register transfer offset encoding <Link>......................................................................... </Link></Link><Link>16 
</Link></P><P><Link>4.5 Shift Encoding <Link>..................................................................................................................... </Link></Link><Link>17 
</Link></P><P><Link>4.6 Load &amp; Store Multiple <Link>.................................................................................................... </Link></Link><Link>17 
</Link></P><P><Link>4.7 Branch offset <Link>........................................................................................................................ </Link></Link><Link>18 
</Link></P><P><Link>4.8 Booth's Multiplication Algorithm <Link>............................................................................ </Link></Link><Link>18 
</Link><Link>5 Interrupts </Link><Link>.............................................................................................................................................. </Link><Link>20 
</Link></P><P><Link>6 Registers </Link><Link>.............................................................................................................................................. </Link><Link>21 
</Link></P><P><Link>7 Cache </Link><Link>........................................................................................................................................................ </Link><Link>22 
</Link></P><P><Link>8 Amber Project </Link><Link>................................................................................................................................ </Link><Link>23 
</Link></P><P><Link>8.1 Amber Port List <Link>.................................................................................................................. </Link></Link><Link>23 
</Link></P><P><Link>8.2 Amber 23 Verilog Files <Link>................................................................................................. </Link></Link><Link>23 
</Link></P><P><Link>8.3 Amber 25 Verilog Files <Link>................................................................................................. </Link></Link><Link>25 
</Link></P><P><Link>8.4 Project Directory Structure <Link>........................................................................................ </Link></Link><Link>27 
</Link><Link>9 Amber FPGA System </Link><Link>........................................................................................................... </Link><Link>29 
</Link><Link>10 Verilog simulations </Link><Link>................................................................................................................. </Link><Link>31 
</Link></P><P><Link>10.1 Installing the Amber project <Link>...................................................................................... </Link></Link><Link>31 
</Link></P><P><Link>10.2 Installing the Compiler <Link>.................................................................................................. </Link></Link><Link>31 
</Link></P><P><Link>10.3 Running Simulations <Link>...................................................................................................... </Link></Link><Link>32 
</Link></P><P><Link>10.4 Simulation output files <Link>.................................................................................................. </Link></Link><Link>34 
</Link></P><P><Link>10.5 Hardware Tests <Link>.................................................................................................................. </Link></Link><Link>36 
</Link></P><P><Link>10.6 C Programs <Link>........................................................................................................................... </Link></Link><Link>39 
</Link></P><P><Link>10.7 Linux <Link>........................................................................................................................................... </Link></Link><Link>40 
</Link><Link>11 FPGA Synthesis </Link><Link>.......................................................................................................................... </Link><Link>44 
</Link></P><P><Link>11.1 Synthesis Results <Link>............................................................................................................ </Link></Link><Link>45 
</Link><Link>12 Using Boot-Loader </Link><Link>.................................................................................................................. </Link><Link>46 
</Link></P><P><Link>12.1 Configure HyperTerminal <Link>........................................................................................... </Link></Link><Link>46 
</Link></P><P><Link>12.2 Configure the FPGA <Link>....................................................................................................... </Link></Link><Link>47 
</Link><Link>13 License </Link><Link>.................................................................................................................................................... </Link><Link>48 
</Link></P></Sect><Sect><H2 id="LinkTarget_412">1 Introduction </H2><P>The Amber processor core is an ARM-compatible 32-bit RISC processor. The Amber core is fully compatible with the ARM® v2a  instruction set architecture (ISA) and is therefore supported by the GNU toolset. This older version of the ARM instruction set is supported because it is not covered by patents so can be implemented without a license from ARM. The Amber project provides a complete embedded FPGA system incorporating the Amber core and a number of peripherals, including UARTs, timers and an Ethernet MAC. </P><P>There are two versions of the core provided in the Amber project. The Amber 23 has a 3-stage pipeline, a unified instruction &amp; data cache, a Wishbone interface, and is capable of 0.75 DMIPS per MHz. The Amber 25 has a 5-stage pipeline, seperate data and instruction caches, a Wishbone interface, and is capable of 1.0 DMIPS per Mhz. Both cores implement exactly the same ISA and are 100% software compatible. </P><P>The Amber 23 core is a very small 32-bit core that provides good performance. Register based instructions execute in a single cycle, except for instructions involving multiplication. Load and store instructions require three cycles. The core's pipeline is stalled either when a cache miss occurs, or when the core performs a wishbone access. </P><P>The Amber 25 core provides 30% to 40% better performance that the 23 core but is also 30% to 40% larger. Register based instructions execute in a single cycle, except for instructions involving multiplication, or complex shift operations. Load and store instructions also execute in a single cycle unless there is a register conflict with a following instruction. The core's pipeline is stalled when a cache miss occurs in either cache, when an instruction conflict is detected, when a complex shift is executed, or when the core performs a wishbone  access. </P><P>Both cores has been verified by booting a 2.4 Linux kernel. Versions of the Linux kernel from the 2.4 branch and earlier contain configurations for the supported ISA. The 2.6 version of Linux does not explicitly support the ARM v2a ISA so requires more modifications to run. Also note that the cores do not contain a memory management unit (MMU) so they can only run the non-virtual memory variant of Linux. </P><P>The cores were developed in Verilog 2001, and are optimized for FPGA synthesis. For example there is no reset logic, all registers are reset as part of FPGA initialization. The complete system has been tested extensively on the Xilinx SP605 Spartan-6 FPGA board. </P><P>For a description of the ISA, see &quot;Archimedes Operating System -A Dabhand Guide, Copyright Dabs Press 1991&quot;, or &quot;Acorn RISC Machine Family Data Manual, VLSI Technology Inc., 1990&quot;. </P><Sect><H3 id="LinkTarget_413">1.1 Amber 23 Features </H3><L><LI><LI_Label>• </LI_Label><LI_Title>3-stage pipeline. </LI_Title></LI><LI><LI_Label>• </LI_Label><LI_Title>32-bit Wishbone system bus. </LI_Title></LI><LI><LI_Label>• 	</LI_Label><LI_Title>Unified instruction and data cache, with write through and a read-miss replacement policy. The cache can have 2, 3, 4 or 8 ways and each way is 4kB. </LI_Title></LI><LI><LI_Label>• 	</LI_Label><LI_Title>Multiply and multiply-accumulate operations with 32-bit inputs and 32-bit output in 34 clock cycles using the Booth algorithm. This is a small and slow multiplier implementation. </LI_Title></LI><LI><LI_Label>• 	</LI_Label><LI_Title>Little endian only, i.e. Byte 0 is stored in bits 7:0 and byte 3 in bits 31:24. </LI_Title></LI></L><P>The following diagram shows the data flow through the 3-stage core. </P><P>Figure 1 -Amber 23 Core pipeline stages </P><Figure><ImageData src="images/amber-spec_img_0.jpg"/>Stage 1 – Fetch Cache Read Instruction / Data Instruction Decode Decode State Control Signals Register Set Instruction Execute Address Write Data Stage 2 – Decode Stage 3 -Execute Read Data </Figure></Sect><Sect><H3 id="LinkTarget_414">1.2 Amber 25 Features </H3><L><LI><LI_Label>• 	</LI_Label><LI_Title>5-stage pipeline. </LI_Title></LI><LI><LI_Label>• 	</LI_Label><LI_Title>128-bit Wishbone system bus. </LI_Title></LI><LI><LI_Label>• 	</LI_Label><LI_Title>Seperate instruction and data caches. Each cache can be either 2,3,4 or 8 ways and each way is 4kB. Both caches use a read replacement policy and the data cache operates as write through. The instruction cache is read only. </LI_Title></LI><LI><LI_Label>• 	</LI_Label><LI_Title>Multiply and multiply-accumulate operations with 32-bit inputs and 32-bit output in 34 clock cycles using the Booth algorithm. This is a small and slow multiplier implementation. </LI_Title></LI><LI><LI_Label>• 	</LI_Label><LI_Title>Little endian only, i.e. Byte 0 is stored in bits 7:0 and byte 3 in bits 31:24. </LI_Title></LI></L><P>Amber Amber 2 Core Specification May 2011 
</P><P>The following diagram shows the data flow through the 5-stage core. 
</P><P>Figure 2 -Amber 25 Core pipeline stages </P><Figure><ImageData src="images/amber-spec_img_1.jpg"/>Stage 1 – Fetch Instruction Cache Read Instruction Instruction Decode Decode State Control Signals Register Set Instruction Execute Instruction address Stage 3 -Execute Data Cache Data address Write Data Stage 4 -Memory Read Data Stage 5 – Write Back </Figure><P>Released under the GNU Lesser General Public License (v2.1) terms 5 of 48 </P></Sect></Sect><Sect><H2 id="LinkTarget_415">Amber 23 Pipeline Architecture </H2><P>The Amber 23 core has a 3-stage pipeline architecture. The best way to think of the pipeline structure is of a circle. There is no start or end point. The output from each stage is registered and fed into the next stage. The three stages are; </P><L><LI><LI_Label>• 	</LI_Label><LI_Title>Fetch – The cache tag and data RAMs receive an unregistered version of the address output by the execution stage. The registered version of the address is compared to the tag RAM outputs one cycle later to decide if the cache hits or misses. If the cache misses, then the pipeline is stalled while the instruction is fetched from either boot memory or main memory via the Wishbone bus. The cache always does 4-word reads so a complete cache line gets filled. In the case of a cache hit, the output from the cache data RAM goes to the decode stage. This can either be an instruction or data word. </LI_Title></LI><LI><LI_Label>• 	</LI_Label><LI_Title>Decode -The instruction is received from the fetch stage and registered. One cycle later it is decoded and the datapath control signals prepared for the next cycle. This stage contains a state machine that handles multi-cycle instructions and interrupts. </LI_Title></LI><LI><LI_Label>• 	</LI_Label><LI_Title>Execute – The control signals from the decode stage are registered and passed into the execute stage, along with any read data from the fetch stage. The operands are read from the register bank, shifted, combined in the ALU and the result written back. The next address for the fetch stage is generated. </LI_Title></LI></L><P>The following diagram shows the datapath through the three stages in detail. This diagram closely corresponds to the Verilog implementation. Some details, like the wishbone interface and coprocessor #15 have been left out so as not to overload the diagram completely. </P><P>Amber Amber 2 Core Specification May 2011 
</P><P>Figure 3 -Detailed 3-Stage Pipeline Structure </P><P>write_enable address [31:0] address_nxt [11:4] write_data [31:0] </P><Figure><ImageData src="images/amber-spec_img_2.jpg"/>Read Instruction / Data Register Bank PC Rn Select Rm Select Rd/s Select ALU imm32 [31:0] Barrel Shift Amount Select imm_shift_amount [4:0] barrel_shift_function [1:0] Program Counter Select Address Select write_data_wen adr_wen pc_wen reg_bank_wen[14:0] status_wen Byte Enable out [31:0] a_in [31:0] b_in [31:0] flags [3:0] carry barrel_shift_amount_sel [1:0] rm_sel [3:0] rn_sel 3:0] pc_sel [1:0] address_sel [2:0] Byte Enable Select byte_enable_sel 4'hF Status Bits Select status_bits_sel [2:0] IRQ FIRQ read_data [31:0] irq firq ift r_ r [ : ] interrupt_vector Interrupt Vector Select interrupt_vector_sel [2:0] '0x00000010' '0x00000014' Pre-Fetch Instruction Decode State rds_sel [3:0] Write Enable '0x00000018' '0x0000001C' Barrel Shift Data Select barrel_shift_data_sel [1:0] barrel_shift_out Barrel Shift pc_plus4 5'h0 in [31:0] shift_amount [4:0] carry_out out [31:0] +4 Saved Current Instruction Instruction Select pc Register Write Select reg_write_sel [2:0] BL: Save PC-4 to LR address [1:0] Instruction Decode Logic And State Machine rn rd Write Data Encode Single Byte Enable +4 Address address_nxt [1:0] alu_function [8:0] Multiply Write Data Select 4 { rds [7:0] } Coprocessor Write Data copro_write_data_wen multiply_function [1:0] out [31:0] b_in [31:0] Base Address Base Address base_adr_wen barrel_shift_carry a_in [31:0] Status Bits Register Bank PC alu_out -4 (for ldm data aborts) +4 +4 DABT PABT instruction [31:0] rm rn rs pc copro_read_data Data Abort Prefetch Abort ADEX Address Exception Status Bits { address[1:0], 3'd0 } (Used for ldrb Shifts) Cache Data SRAM Address WData Cache Data SRAM Address WData Way Select Word Select Cache Tag SRAM Address WData Cache Tag SRAM Address WData Miss Address Hit? Hit? Cache State Machine address [3:2] address [31:12] Cache State FETCH DECODE EXECUTE '0x00000000' '0x00000004' '0x00000008' '0x0000000C' Execute Control Signals copro_read_data[31:28] flags [1:0] rd </Figure><P>copro_write_data [31:0] write_data [31:0] byte_enable [3:0] write_enable address_nxt [31:0] address [31:0] </P><Sect><H3 id="LinkTarget_416">2.1 ALU </H3><P>The diagram below shows the structure of the Arithmetic Logic Unit (ALU). It consists of a set of different logical functions, a 32-bit adder and a mux to select the function. </P><P>Released under the GNU Lesser General Public License (v2.1) terms 7 of 48 </P><P>Figure 4 -ALU Structure </P><P>a_in [31:0] b_in [31:0] cpsr_carry barrel_shift_carry </P><P>out_sel[2:0] </P><P><Figure><ImageData src="images/amber-spec_img_3.jpg"/>Out Select swap_sel out [31:0] be [3:0] A Select B Select Not Select NOT not_sel Full Adder XOR OR AND BE Encode Zero detect overflow Cin Select cin_sel[1:0] '0' '1' Zero Cout Select bit [31] 5 4 3 1 0 Extend 8 2 </Figure>cout_sel </P><Figure><ImageData src="images/amber-spec_img_4.jpg"/></Figure><Figure><ImageData src="images/amber-spec_img_5.jpg"/></Figure><P>n z v c flags={ n,z,c,v} </P><P>The alu_function[6:0] bus in the core is a concatenation of the individual control signals in the ALU. The following table describes these control signals. </P><P>Table 1 ALU Function Encoding </P><Table><TR><TD>Field </TD><TD>Function </TD></TR><TR><TD>swap_sel </TD><TD>Swaps the a and b inputs </TD></TR><TR><TD>not_sel </TD><TD>Selects the NOT version of b </TD></TR><TR><TD>cin_sel[1:0] </TD><TD>Selects the carry in to the full added from { c_in, !c_in, 1, 0 }. Note that bs_c_in is the carry_in from the barrel shifter. </TD></TR><TR><TD>cout_sel </TD><TD>Selects the carry out from { full_adder_cout, barrel_shifter_cout } </TD></TR><TR><TD>out_sel[2:0] </TD><TD>Selects the ALU output from { 0, b_zero_extend_8, b, and_out, or_out, xor_out, full_adder_out } </TD></TR></Table></Sect><Sect><H3 id="LinkTarget_417">2.2 Pipeline Operation </H3><Sect><H4 id="LinkTarget_418">2.2.1 Load Example </H4><P>The load instruction causes the pipeline to stall for two cycles. This section explains why this is necessary. The following is a simple fragment of assembly code with a single load instructon with register instructions before and after it. </P><Table><TR><TD>0 </TD><TD>mov r0, #0x100 </TD></TR><TR><TD>4 </TD><TD>add r1, r0, #8 </TD></TR><TR><TD>8 </TD><TD>ldr r4, [r1] </TD></TR><TR><TD>c </TD><TD>add r4, r4, r0 </TD></TR></Table><P>The table below shows which instruction is active in each stage of the processor core 
</P><P>for each clock tick. When the core comes out of reset the execute stage starts generating fetch addresses. It starts at 0 and increments by 4 each tick. In tick 1 the first instruction, at address 0, is fetched, This simple example assumes that all accesses are already present in the cache so fetches only take 1 cycle. Otherwise read accesses on the wishbone bus would add additional stalls and complicate this example. </P><P>At tick 2 the first instruction, 0, is decoded and at tick 3 it is executed. This means that the r0 register, which is the destination for instruction 0, does not output the new value until tick 4, where it is used as an input to the second instruction. </P><P>At tick 5 the load instruction, instruction 8, stalls the decode stage. In the execute stage it calculates the load address and this is used by the fetch stage in tick 6. Also in tick 5 the instruction c is saved to the pre_fetch_instruction register. This is used once the load instruction has finished and its use saves needing an additional stall cycle to reread instruction c. </P><P>At tick 6 the value at address 0x108 is fetched and at tick 7 it is written into r4. The new value of r4 is then available for instruction c in tick 8. </P><P>Table 2 Pipeline load example </P><Table><TR><TH>Stage </TH><TH>Tick 0 </TH><TH>Tick 1 </TH><TH>Tick 2 </TH><TH>Tick 3 </TH><TH>Tick 4 </TH><TH>Tick 5 </TH><TH>Tick 6 </TH><TH>Tick 7 </TH><TH>Tick 8 </TH></TR><TR><TD>Fetch </TD><TD/><TD/><TD/><TD/><TD/><TD/><TD/><TD/><TD/></TR><TR><TD>address </TD><TD>-</TD><TD>0 </TD><TD>4 </TD><TD>8 </TD><TD>c </TD><TD>10 </TD><TD>108 </TD><TD>10 </TD><TD>14 </TD></TR><TR><TD>access type </TD><TD/><TD>read </TD><TD>read </TD><TD>read </TD><TD>read </TD><TD>read, </TD><TD>read </TD><TD>read </TD><TD>read </TD></TR><TR><TD/><TD/><TD/><TD/><TD/><TD/><TD>ignored </TD><TD/><TD/><TD/></TR><TR><TD>Decode </TD><TD/><TD/><TD/><TD/><TD/><TD/><TD/><TD/><TD/></TR><TR><TD>instruction </TD><TD>-</TD><TD>-</TD><TD>0 </TD><TD>4 </TD><TD>8 </TD><TD>8 </TD><TD>8 </TD><TD>c </TD><TD>10 </TD></TR><TR><TD>pre_fetch_instruction </TD><TD>-</TD><TD>-</TD><TD>-</TD><TD>-</TD><TD>-</TD><TD>[c] </TD><TD>[c] </TD><TD/><TD/></TR><TR><TD>Execute </TD><TD/><TD/><TD/><TD/><TD/><TD/><TD/><TD/><TD/></TR><TR><TD>instruction </TD><TD>-</TD><TD>-</TD><TD>-</TD><TD>0 </TD><TD>4 </TD><TD>8 </TD><TD>8 </TD><TD>8 </TD><TD>c </TD></TR><TR><TD>address_nxt </TD><TD>0 </TD><TD>4 </TD><TD>8 </TD><TD>c </TD><TD>10 </TD><TD>108 </TD><TD>10 </TD><TD>14 </TD><TD>18 </TD></TR></Table></Sect><Sect><H4 id="LinkTarget_419">2.2.2 Store Example </H4><P>The store instruction also causes the pipeline to stall for two cycles. This section explains why this is necessary. The following is a simple fragment of assembly code with a single store instructon with register instructions before and after it. </P><Table><TR><TD>0 </TD><TD>mov r0, #0x100 </TD></TR><TR><TD>4 </TD><TD>mov r1, #17 </TD></TR><TR><TD>8 </TD><TD>str r1, [r0] </TD></TR><TR><TD>c </TD><TD>add r1, r0, #20 </TD></TR></Table><P>The table below shows which instruction is active in each stage of the processor core for each clock tick. At tick 5 the store instruction, instruction 8, stalls the decode stage. In the execute stage it calculates the store address and this is used by the fetch stage in tick 6. Also in tick 5 the instruction c is saved to the pre_fetch_instruction register. This is used once the store instruction has finished and its use saves needing an additional stall cycle to reread instruction c. In tick 7 the instruction after the store instruction is decoded and in tick 8 it is executed. </P><P>Table 3 Pipeline store example </P><Table><TR><TH>Stage </TH><TH>Tick 0 </TH><TH>Tick 1 </TH><TH>Tick 2 </TH><TH>Tick 3 </TH><TH>Tick 4 </TH><TH>Tick 5 </TH><TH>Tick 6 </TH><TH>Tick 7 </TH><TH>Tick 8 </TH></TR><TR><TD>Fetch </TD><TD/><TD/><TD/><TD/><TD/><TD/><TD/><TD/><TD/></TR><TR><TD>address </TD><TD>-</TD><TD>0 </TD><TD>4 </TD><TD>8 </TD><TD>c </TD><TD>10 </TD><TD>100 </TD><TD>10 </TD><TD>14 </TD></TR><TR><TD>access type </TD><TD/><TD>read </TD><TD>read </TD><TD>read </TD><TD>read </TD><TD>read, </TD><TD>write </TD><TD>read </TD><TD>read </TD></TR><TR><TD/><TD/><TD/><TD/><TD/><TD/><TD>ignored </TD><TD/><TD/><TD/></TR><TR><TD>Decode </TD><TD/><TD/><TD/><TD/><TD/><TD/><TD/><TD/><TD/></TR><TR><TD>instruction </TD><TD>-</TD><TD>-</TD><TD>0 </TD><TD>4 </TD><TD>8 </TD><TD>8 </TD><TD>8 </TD><TD>c </TD><TD>10 </TD></TR><TR><TD>pre_fetch_instruction </TD><TD>-</TD><TD>-</TD><TD>-</TD><TD>-</TD><TD>-</TD><TD>[c] </TD><TD>[c] </TD><TD/><TD/></TR><TR><TD>Execute </TD><TD/><TD/><TD/><TD/><TD/><TD/><TD/><TD/><TD/></TR><TR><TD>instruction </TD><TD>-</TD><TD>-</TD><TD>-</TD><TD>0 </TD><TD>4 </TD><TD>8 </TD><TD>8 </TD><TD>8 </TD><TD>c </TD></TR><TR><TD>address_nxt </TD><TD>0 </TD><TD>4 </TD><TD>8 </TD><TD>c </TD><TD>10 </TD><TD>100 </TD><TD>10 </TD><TD>14 </TD><TD>18 </TD></TR></Table></Sect></Sect></Sect><Sect><H2 id="LinkTarget_420">Instruction Set </H2><P>The following table describes the instructions supported by the Amber 2x core. </P><P>Table 4 Amber 2 core Instruction Set </P><Table><TR><TH>Name </TH><TH>Type </TH><TH>Syntax </TH><TH>Description </TH></TR><TR><TH>adc </TH><TD>REGOP </TD><TD>adc{&lt;cond&gt;}{s} &lt;Rd&gt;, &lt;Rn&gt;, &lt;shifter_operand&gt; </TD><TD>Add with carry adds two values and the Carry flag. </TD></TR><TR><TH>add </TH><TD>REGOP </TD><TD>add{&lt;cond&gt;}{s} &lt;Rd&gt;, &lt;Rn&gt;, &lt;shifter_operand&gt; </TD><TD>Add adds two values. </TD></TR><TR><TH>and </TH><TD>REGOP </TD><TD>and{&lt;cond&gt;}{s} &lt;Rd&gt;, &lt;Rn&gt;, &lt;shifter_operand&gt; </TD><TD>And performs a bitwise AND of two values. </TD></TR><TR><TH>b </TH><TD>BRANCH </TD><TD>b{&lt;cond&gt;} &lt;target_address&gt; </TD><TD>Branch causes a branch to a target address. </TD></TR><TR><TH>bic </TH><TD>REGOP </TD><TD>bic{&lt;cond&gt;}{s} &lt;Rd&gt;, &lt;Rn&gt;, &lt;shifter_operand&gt; </TD><TD>Bit clear performs a bitwise AND of one value with the complement of a second value. </TD></TR><TR><TH>bl </TH><TD>BRANCH </TD><TD>bl{&lt;cond&gt;} &lt;target_address&gt; </TD><TD>Branch and link cause a branch to a target address. The resulting instruction stores a return address in the link register (r14). </TD></TR><TR><TH>cdp </TH><TD>COREGOP </TD><TD>cdp{&lt;cond&gt;} &lt;coproc&gt;, &lt;opcode_1&gt;, &lt;CRd&gt;, &lt;CRn&gt;, &lt;CRm&gt;, &lt;opcode_2&gt; </TD><TD>Coprocessor data processing tells a coprocessor to perform an operation that is independent of Amber registers and memory. This instruction is not currently implemented by the Amber core because there is no coprocessor in the system that requires it. </TD></TR><TR><TH>cmn </TH><TD>REGOP </TD><TD>cmn{&lt;cond&gt;}{p} &lt;Rn&gt;, &lt;shifter_operand&gt; </TD><TD>Compare negative compares one value with the twos complement of a second value, simply by adding the two values together, and sets the status flags. If the p flag is set, the pc and status bits are updated directly by the ALU output. </TD></TR><TR><TH>cmp </TH><TD>REGOP </TD><TD>cmp{&lt;cond&gt;}{p} &lt;Rn&gt;, &lt;shifter_operand&gt; </TD><TD>Compare compares two values by subtracting &lt;shifter operand&gt; from &lt;Rn&gt;, setting the status flags. If the p flag is set, the pc and status bits are updated directly by the ALU output. </TD></TR><TR><TH>eor </TH><TD>REGOP </TD><TD>eor{&lt;cond&gt;}{s} &lt;Rd&gt;, &lt;Rn&gt;, &lt;shifter_operand&gt; </TD><TD>Exclusive OR performs a bitwise XOR of two values. </TD></TR><TR><TH>ldc </TH><TD>CODTRANS </TD><TD>lcd{&lt;cond&gt;} &lt;coproc&gt;, &lt;CRd&gt;, &lt;addressing_mode&gt; </TD><TD>Load coprocessor loads memory data from a sequence of consecutive memory addresses to a coprocessor. This instruction is not currently implemented by the Amber core because there is no coprocessor in the system that requires it. </TD></TR><TR><TH>ldm </TH><TD>MTRANS </TD><TD>ldm{&lt;cond&gt;}&lt;addressing_mode&gt; &lt;Rn&gt;{!}, &lt;registers&gt; </TD><TD>Load multiple loads a non-empty subset, or possibly all, of the general-purpose registers from sequential memory locations. It is useful for block loads, stack operations and procedure exit sequences. </TD></TR><TR><TD>ldm{&lt;cond&gt;}&lt;addressing_mode&gt; &lt;Rn&gt;, &lt;registers_without_pc&gt;^ </TD><TD>This version loads User mode registers when the processor is in a privileged mode. This is useful when performing process swaps. </TD></TR><TR><TD>ldm{&lt;cond&gt;}&lt;addressing_mode&gt; &lt;Rn&gt;{!}, &lt;registers_and_pc&gt;^ </TD><TD>This version loads a subset, or possibly all, of the general-purpose registers and the PC from sequential memory locations. The status bits are also loaded. This is useful for returning from an exception. </TD></TR><TR><TH>ldr </TH><TD>TRANS </TD><TD>ldr{&lt;cond&gt;} &lt;Rd&gt;, &lt;addressing_mode&gt; </TD><TD>Load register loads a word from a memory address. If the address is not word-aligned, then the word is rotated left so that the byte addresses appears in bits [7:0] of Rd. </TD></TR><TR><TH>ldrb </TH><TD>TRANS </TD><TD>ldr{&lt;cond&gt;}b &lt;Rd&gt;, &lt;addressing_mode&gt; </TD><TD>Load register byte loads a byte from memory and zero-extends the byte to a 32-bit word. </TD></TR><TR><TH>mcr </TH><TD>CORTRANS </TD><TD>mcr{&lt;cond&gt;} &lt;coproc&gt;, &lt;opcode_1&gt;, &lt;Rd&gt;, &lt;CRn&gt;, &lt;CRm&gt;{, &lt;opcode_2&gt;} </TD><TD>Move to coprocessor from register passes the value of register &lt;Rd&gt; to a coprocessor. </TD></TR><TR><TH>mla </TH><TD>MULT </TD><TD>mla{&lt;cond&gt;}{s} &lt;Rd&gt;, &lt;Rm&gt;, &lt;Rs&gt;, &lt;Rn&gt; </TD><TD>Multiply accumulate multiplies two signed or unsigned 32bit values, and adds a third 32-bit value. The least significant 32 bits of the result are written to the destination register. </TD></TR><TR><TH>mov </TH><TD>REGOP </TD><TD>mov{&lt;cond&gt;}{s} &lt;Rd&gt;, &lt;shifter_operand&gt; </TD><TD>Move writes a value to the destination register. The value can be either an immediate value or a value from a register, </TD></TR></Table><Table><TR><TH>Name </TH><TH>Type </TH><TH>Syntax </TH><TH>Description </TH></TR><TR><TH/><TD/><TD/><TD>and can be shifted before the write. </TD></TR><TR><TH>mrc </TH><TD>CORTRANS </TD><TD>mrc{&lt;cond&gt;} &lt;coproc&gt;, &lt;opcode_1&gt;, &lt;Rd&gt;, &lt;CRn&gt;, &lt;CRm&gt;{, &lt;opcode_2&gt;} </TD><TD>Move to register from coprocessor causes a coprocessor to transfer a value to an Amber register or to the condition flags. </TD></TR><TR><TH>mul </TH><TD>MULT </TD><TD>mul{&lt;cond&gt;}{s} &lt;Rd&gt;, &lt;Rm&gt;, &lt;Rs&gt; </TD><TD>Multiply multiplies two signed or unsigned 32-bit values. The least significant 32 bits of the result are written to the destination register. </TD></TR><TR><TH>mvn </TH><TD>REGOP </TD><TD>mvn{&lt;cond&gt;}{s} &lt;Rd&gt;, &lt;shifter_operand&gt; </TD><TD>Move not generates the logical ones complement of a value. The value can be either an immediate value or a value from a register, and can be shifted before the MVN operation. </TD></TR><TR><TH>orr </TH><TD>REGOP </TD><TD>orr{&lt;cond&gt;}{s} &lt;Rd&gt;, &lt;Rn&gt;, &lt;shifter_operand&gt; </TD><TD>Logical OR performs a bitwise OR of two values. The first value comes from a register. The second value can be either an immediate value or a value from a register, and can be shifted before the OR operation. </TD></TR><TR><TH>rsb </TH><TD>REGOP </TD><TD>rsb{&lt;cond&gt;}{s} &lt;Rd&gt;, &lt;Rn&gt;, &lt;shifter_operand&gt; </TD><TD>Reverse subtract subtracts a value from a second value. </TD></TR><TR><TH>rsc </TH><TD>REGOP </TD><TD>rsc{&lt;cond&gt;}{s} &lt;Rd&gt;, &lt;Rn&gt;, &lt;shifter_operand&gt; </TD><TD>Reverse subtract with carry subtracts one value from another, taking account of any borrow from a preceding less significant subtraction. The normal order of the operands is reversed, to allow subtraction from a shifted register value, or from an immediate value. </TD></TR><TR><TH>sbc </TH><TD>REGOP </TD><TD>sbc{&lt;cond&gt;}{s} &lt;Rd&gt;, &lt;Rn&gt;, &lt;shifter_operand&gt; </TD><TD>Subtract with carry subtracts the value of its second operand and the value of NOT(Carry flag) from the value of its first operand. The first operand comes from a register. The second operand can be either an immediate value or a value from a register, and can be shifted before the subtraction. </TD></TR><TR><TH>stc </TH><TD>CODTRANS </TD><TD>stc{&lt;cond&gt;} &lt;coproc&gt;, &lt;CRd&gt;, &lt;addressing_mode&gt; </TD><TD>Store coprocessor stores data from a coprocessor to a sequence of consecutive memory addresses. This instruction is not currently implemented by the Amber core because there is no coprocessor in the system that requires it. </TD></TR><TR><TH>stm </TH><TD>MTRANS </TD><TD>stm{&lt;cond&gt;}&lt;addressing_mode&gt; &lt;Rn&gt;{!}, &lt;registers&gt; </TD><TD>Store multiple stores a non-empty subset (or possibly all) of the general-purpose registers to sequential memory locations. The '!' causes Rn to be updated. The registers are stored in sequence, the lowest-numbered register to the lowest memory address (start_address), through to the highest-numbered register to the highest memory address (end_address). </TD></TR><TR><TD>STM{&lt;cond&gt;}&lt;addressing_mode&gt; &lt;Rn&gt;, &lt;registers&gt;^ </TD><TD>This version stores a subset (or possibly all) of the User mode general-purpose registers to sequential memory locations. The registers are stored in sequence, the lowest-numbered register to the lowest memory address (start_address), through to the highest-numbered register to the highest memory address (end_address). </TD></TR><TR><TH>str </TH><TD>TRANS </TD><TD>str{&lt;cond&gt;} &lt;Rd&gt;, &lt;addressing_mode&gt; </TD><TD>Store register stores a word from a register to memory. </TD></TR><TR><TH>strb </TH><TD>TRANS </TD><TD>str{&lt;cond&gt;}b &lt;Rd&gt;, &lt;addressing_mode&gt; </TD><TD>Store register byte stores a byte from the least significant byte of a register to memory. </TD></TR><TR><TH>sub </TH><TD>REGOP </TD><TD>sub{&lt;cond&gt;}{s} &lt;Rd&gt;, &lt;Rn&gt;, &lt;shifter_operand&gt; i.e. Rd = Rn - shifter_operand </TD><TD>Subtract subtracts one value from a second value. </TD></TR><TR><TH>swi </TH><TD>SWI </TD><TD>swi{&lt;cond&gt;} &lt;immed_24&gt; </TD><TD>Software interrupt causes a SWI exception. &lt;immed_24&gt; Is a 24-bit immediate value that is put into bits[23:0] of the instruction. This value is ignored by the Amber core, but can be used by an operating system SWI exception handler to determine what operating system service is being requested. </TD></TR><TR><TH>swp </TH><TD>SWAP </TD><TD>swp{&lt;cond&gt;} &lt;Rd&gt;, &lt;Rm&gt;, [&lt;Rn&gt;] </TD><TD>Swap loads a word from the memory address given by the value of register &lt;Rn&gt;. The value of register &lt;Rm&gt; is then stored to the memory address given by the value of &lt;Rn&gt;, and the original loaded value is written to register &lt;Rd&gt;. If the same register is specified for &lt;Rd&gt; and &lt;Rm&gt;, this instruction swaps the value of the register and the value at the memory address. </TD></TR><TR><TH>swpb </TH><TD>SWAP </TD><TD>swp{&lt;cond&gt;}b &lt;Rd&gt;, &lt;Rm&gt;, [&lt;Rn&gt;] </TD><TD>Swap Byte swaps a byte between registers and memory. It loads a byte from the memory address given by the value of register &lt;Rn&gt;. The value of the least significant byte of register &lt;Rm&gt; is stored to the memory address given by </TD></TR></Table><Table><TR><TH>Name </TH><TH>Type </TH><TH>Syntax </TH><TH>Description </TH></TR><TR><TD/><TD/><TD/><TD>&lt;Rn&gt;, the original loaded value is zero-extended to a 32-bit word, and the word is written to register &lt;Rd&gt;. Can be used to implement semaphores. </TD></TR><TR><TD>teq </TD><TD>REGOP </TD><TD>teq{&lt;cond&gt;}{p} &lt;Rn&gt;, &lt;shifter_operand&gt; </TD><TD>Test equivalence compares a register value with another arithmetic value. The condition flags are updated, based on the result of logically XORing the two values, so that subsequent instructions can be conditionally executed. If the p flag is set, the pc and status bits are updated directly by the ALU output. </TD></TR><TR><TD>tst </TD><TD>REGOP </TD><TD>tst{&lt;cond&gt;}{p} &lt;Rn&gt;, &lt;shifter_operand&gt; </TD><TD>Test compares a register value with another arithmetic value. The condition flags are updated, based on the result of logically ANDing the two values, so that subsequent instructions can be conditionally executed. If the p flag is set, the pc and status bits are updated directly by the ALU output. </TD></TR></Table><P>Amber Amber 2 Core Specification May 2011 
</P></Sect><Sect><H2 id="LinkTarget_421">Instruction Set Encoding </H2><P>Table 5 Overall instruction set encoding table. </P><P>Type </P><P>Data Processing REGOP Multiply MULT Single Data Swap SWAP Single Data Transfer TRANS Block Data Transfer MTRANS Branch BRANCH Coprocessor Data CODTRANS Transfer Coprocessor Data COREGOP Operation Coprocessor CORTRANS Register Transfer Software Interrupt SWI </P><Table><TR><TH>31 </TH><TH>30 </TH><TH>29 </TH><TH>28 </TH><TH>27 </TH><TH>26 </TH><TH>25 </TH><TH>24 </TH><TH>23 </TH><TH>22 </TH><TH>21 </TH><TH>20 </TH><TH>19 </TH><TH>18 </TH><TH>17 </TH><TH>16 </TH><TH>15 </TH><TH>14 </TH><TH>13 </TH><TH>12 </TH><TH>11 </TH><TH>10 </TH><TH>9 </TH><TH>8 </TH><TH>7 </TH><TH>6 </TH><TH>5 </TH><TH>4 </TH><TH>3 </TH><TH>2 </TH><TH>1 </TH><TH>0 </TH></TR><TR><TD/><TD><Link>Cond </Link></TD><TD/><TD>0 </TD><TD>0 </TD><TD>I </TD><TD/><TD><Link>Opcode </Link></TD><TD>S </TD><TD/><TD>Rn </TD><TD/><TD/><TD>Rd </TD><TD><Link>shifter_operand </Link></TD><TD/><TD/></TR><TR><TD/><TD><Link>Cond </Link></TD><TD/><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>A </TD><TD>S </TD><TD/><TD>Rd </TD><TD/><TD/><TD>Rn </TD><TD>Rs </TD><TD>1 </TD><TD>0 </TD><TD>0 </TD><TD>1 </TD><TD/><TD>Rm </TD><TD/></TR><TR><TD/><TD><Link>Cond </Link></TD><TD/><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>1 </TD><TD>0 </TD><TD>B </TD><TD>0 </TD><TD>0 </TD><TD/><TD>Rn </TD><TD/><TD/><TD>Rd </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>0 </TD><TD>1 </TD><TD>0 </TD><TD>0 </TD><TD>1 </TD><TD/><TD>Rm </TD><TD/></TR><TR><TD/><TD><Link>Cond </Link></TD><TD/><TD>0 </TD><TD>1 </TD><TD>I </TD><TD>P </TD><TD>U </TD><TD>B </TD><TD>W </TD><TD>L </TD><TD/><TD>Rn </TD><TD/><TD/><TD>Rd </TD><TD><Link>Offset </Link></TD><TD/><TD/></TR><TR><TD/><TD><Link>Cond </Link></TD><TD/><TD>1 </TD><TD>0 </TD><TD>0 </TD><TD>P </TD><TD>U </TD><TD>S </TD><TD>W </TD><TD>L </TD><TD/><TD>Rn </TD><TD/><TD/><TD>Register List </TD><TD/><TD/></TR><TR><TD/><TD><Link>Cond </Link></TD><TD/><TD>1 </TD><TD>0 </TD><TD>1 </TD><TD>L </TD><TD/><TD/><TD/><TD/><TD/><TD><Link>Offset </Link></TD><TD/><TD/></TR><TR><TD/><TD><Link>Cond </Link></TD><TD/><TD>1 </TD><TD>1 </TD><TD>0 </TD><TD>P </TD><TD>U </TD><TD>N </TD><TD>W </TD><TD>L </TD><TD/><TD>Rn </TD><TD/><TD/><TD>CRd </TD><TD>CP# </TD><TD>Offset </TD><TD/><TD/></TR><TR><TD/><TD><Link>Cond </Link></TD><TD/><TD>1 </TD><TD>1 </TD><TD>1 </TD><TD>0 </TD><TD>CP Opcode </TD><TD/><TD>CRn </TD><TD/><TD/><TD>CRd </TD><TD>CP# </TD><TD>CP </TD><TD>0 </TD><TD/><TD>CRm </TD><TD/></TR><TR><TD/><TD><Link>Cond </Link></TD><TD/><TD>1 </TD><TD>1 </TD><TD>1 </TD><TD>0 </TD><TD>CP Opcode </TD><TD>L </TD><TD/><TD>CRn </TD><TD/><TD/><TD>Rd </TD><TD>CP# </TD><TD>CP </TD><TD>1 </TD><TD/><TD>CRm </TD><TD/></TR><TR><TD/><TD><Link>Cond </Link></TD><TD/><TD>1 </TD><TD>1 </TD><TD>1 </TD><TD>1 </TD><TD/><TD/><TD/><TD/><TD/><TD>Ignored by processor </TD><TD/><TD/></TR><TR><TD>31 </TD><TD>30 </TD><TD>29 </TD><TD>28 </TD><TD>27 </TD><TD>26 </TD><TD>25 </TD><TD>24 </TD><TD>23 </TD><TD>22 </TD><TD>21 </TD><TD>20 </TD><TD>19 </TD><TD>18 </TD><TD>17 </TD><TD>16 </TD><TD>15 </TD><TD>14 </TD><TD>13 </TD><TD>12 </TD><TD>11 </TD><TD>10 </TD><TD>9 </TD><TD>8 </TD><TD>7 </TD><TD>6 </TD><TD>5 </TD><TD>4 </TD><TD>3 </TD><TD>2 </TD><TD>1 </TD><TD>0 </TD></TR></Table><P>Where I25 = Immediate form of shifter_operand L24 = Link; Save PC to LR U23 = 1; address = Rn + offset_12 </P><P>= 0; address = Rn - offset_12 </P><P>B22 = Byte (0 = word) </P><P>A21 = Accumulate </P><P>L20 = Load (0 = store) </P><P>S20 = Update Condition flags </P><P>P24, W21 : Select different modes of operation </P><Sect><H3 id="LinkTarget_422">4.1 Condition Encoding </H3><P>All instructions include a 4-bit condition execution code. The instruction is only executed if the condition specified in the instruction agrees with the current value of the status flags. </P><P>Table 6 Cond: Condition Encoding </P><Table><TR><TH>Condition </TH><TH>Mnemonic extension </TH><TH>Meaning </TH><TH>Condition flag state </TH></TR><TR><TD>4'h0 </TD><TD>eq </TD><TD>Equal </TD><TD>Z set </TD></TR><TR><TD>4'h1 </TD><TD>ne </TD><TD>Not equal </TD><TD>Z clear </TD></TR><TR><TD>4'h2 </TD><TD>cs / hs </TD><TD>Carry set / unsigned higher or same </TD><TD>C set </TD></TR><TR><TD>4'h3 </TD><TD>cc / lo </TD><TD>Carry clear / unsigned lower </TD><TD>C clear </TD></TR></Table><Table><TR><TH>Condition </TH><TH>Mnemonic extension </TH><TH>Meaning </TH><TH>Condition flag state </TH></TR><TR><TD>4'h4 </TD><TD>mi </TD><TD>Minus / negative </TD><TD>N set </TD></TR><TR><TD>4'h5 </TD><TD>pl </TD><TD>Plus / positive or zero </TD><TD>N clear </TD></TR><TR><TD>4'h6 </TD><TD>vs </TD><TD>Overflow </TD><TD>V set </TD></TR><TR><TD>4'h7 </TD><TD>vc </TD><TD>No overflow </TD><TD>V clear </TD></TR><TR><TD>4'h8 </TD><TD>hi </TD><TD>Unsigned higher </TD><TD>C set and Z clear </TD></TR><TR><TD>4'h9 </TD><TD>ls </TD><TD>Unsigned lower or same </TD><TD>C clear or Z set </TD></TR><TR><TD>4'h10 </TD><TD>ge </TD><TD>Signed greater than or equal </TD><TD>N == V </TD></TR><TR><TD>4'h11 </TD><TD>lt </TD><TD>Signed less than </TD><TD>N != V </TD></TR><TR><TD>4'h12 </TD><TD>gt </TD><TD>Signed greater than </TD><TD>Z == 0,N == V </TD></TR><TR><TD>4'h13 </TD><TD>le </TD><TD>Signed less than or equal </TD><TD>Z == 1 or N != V </TD></TR><TR><TD>4'h14 </TD><TD>al </TD><TD>Always (unconditional) </TD><TD>-</TD></TR><TR><TD>4'h15 </TD><TD>-</TD><TD>Invalid condition </TD><TD>-</TD></TR></Table></Sect><Sect><H3 id="LinkTarget_423">4.2 Opcode Encoding 
</H3><P>Table 7 REGOP: Opcode Encoding </P><Table><TR><TH>Opcode </TH><TH>Mnemonic extension </TH><TH>Operation </TH><TH>Action </TH></TR><TR><TD>4'h0 </TD><TD>and </TD><TD>Logical AND </TD><TD>Rd := Rn AND shifter_operand </TD></TR><TR><TD>4'h1 </TD><TD>eor </TD><TD>Logical XOR </TD><TD>Rd := Rn XOR shifter_operand </TD></TR><TR><TD>4'h2 </TD><TD>sub </TD><TD>Subtract </TD><TD>Rd := Rn -shifter_operand </TD></TR><TR><TD>4'h3 </TD><TD>rsb </TD><TD>Reverse subtract </TD><TD>Rd := shifter_operand -Rn </TD></TR><TR><TD>4'h4 </TD><TD>add </TD><TD>Add </TD><TD>Rd := Rn + shifter_operand </TD></TR><TR><TD>4'h5 </TD><TD>adc </TD><TD>Add with carry </TD><TD>Rd := Rn + shifter_operand + Carry Flag </TD></TR><TR><TD>4'h6 </TD><TD>sbc </TD><TD>Subtract with carry </TD><TD>Rd := Rn -shifter_operand -NOT(Carry Flag) </TD></TR><TR><TD>4'h7 </TD><TD>rsc </TD><TD>Reverse subtract with carry </TD><TD>Rd := shifter_operand -Rn -NOT(Carry Flag) </TD></TR><TR><TD>4'h8 </TD><TD>tst </TD><TD>Test </TD><TD>Update flags after Rn AND shifter_operand S bit always set </TD></TR><TR><TD>4'h9 </TD><TD>teq </TD><TD>Test equivalence </TD><TD>Update flags after Rn EOR shifter_operand S bit always set </TD></TR><TR><TD>4'ha </TD><TD>cmp </TD><TD>Compare </TD><TD>Update flags after Rn – shifter_operand S bit always set </TD></TR><TR><TD>4'hb </TD><TD>cmn </TD><TD>Compare negated </TD><TD>Update flags after Rn + shifter_operand S bit always set </TD></TR><TR><TD>4'hc </TD><TD>orr </TD><TD>Logical (inclusive) OR </TD><TD>Rd := Rn OR shifter_operand </TD></TR><TR><TD>4'hd </TD><TD>mov </TD><TD>Move </TD><TD>Rd := shifter_operand (no first operand) </TD></TR><TR><TD>4'he </TD><TD>bic </TD><TD>Bit clear </TD><TD>Rd := Rn AND NOT(shifter_operand) </TD></TR><TR><TD>4'hf </TD><TD>mvn </TD><TD>Move NOT </TD><TD>Rd := NOT shifter_operand (no first operand) </TD></TR></Table></Sect><Sect><H3 id="LinkTarget_424">4.3 Shifter Operand Encoding </H3><P>This section describes the encoding of the shifter operand for register instructions. </P><P>Table 8 REGOP: Shifter Operand Encoding </P><Table><TR><TH>Format </TH><TH>Syntax </TH><TH>25 'I' </TH><TH>11 </TH><TH>10 </TH><TH>9 </TH><TH>8 </TH><TH>7 </TH><TH>6 </TH><TH>5 </TH><TH>4 </TH><TH>3 </TH><TH>2 </TH><TH>1 </TH><TH>0 </TH></TR><TR><TD>32-bit immediate </TD><TD>#&lt;immediate&gt; </TD><TD>1 </TD><TD><Link>encode_imm </Link></TD><TD/><TD/><TD>imm_8 </TD><TD/><TD/></TR><TR><TD>Immediate shifts </TD><TD>&lt;Rm&gt; </TD><TD>0 </TD><TD>5'h0 </TD><TD/><TD>2'h0 </TD><TD>0 </TD><TD/><TD>Rm </TD><TD/></TR><TR><TD/><TD>&lt;Rm&gt;, lsl #&lt;shift_imm&gt; </TD><TD>0 </TD><TD>shift_imm </TD><TD/><TD><Link>Shift </Link></TD><TD>0 </TD><TD/><TD>Rm </TD><TD/></TR><TR><TD/><TD>&lt;Rm&gt;, lsr #&lt;shift_imm&gt; </TD></TR><TR><TD/><TD>&lt;Rm&gt;, asr #&lt;shift_imm&gt; </TD></TR><TR><TD/><TD>&lt;Rm&gt;, ror #&lt;shift_imm&gt; </TD></TR><TR><TD/><TD>&lt;Rm&gt;, rrx </TD><TD>0 </TD><TD>5'h0 </TD><TD/><TD>2'b11 </TD><TD>0 </TD><TD/><TD>Rm </TD><TD/></TR><TR><TD>Register Shifts </TD><TD>&lt;Rm&gt;, lsl &lt;Rs&gt; </TD><TD>0 </TD><TD>Rs </TD><TD>0 </TD><TD><Link>Shift </Link></TD><TD>1 </TD><TD/><TD>Rm </TD><TD/></TR><TR><TD/><TD>&lt;Rm&gt;, lsr &lt;Rs&gt; </TD></TR><TR><TD/><TD>&lt;Rm&gt;, asr &lt;Rs&gt; </TD></TR><TR><TD/><TD>&lt;Rm&gt;, ror &lt;Rs&gt; </TD></TR></Table><Sect><H4 id="LinkTarget_425">4.3.1 Encode immediate value 
</H4><P>Table 9 REGOP: Encode Immediate Value Encoding </P><Table><TR><TD>Value </TD><TD>32-bit immediate value </TD></TR><TR><TD>4'h0 </TD><TD>{ 24'h0, imm_8[7:0] } </TD></TR><TR><TD>4'h1 </TD><TD>{ imm_8[1:0], 24'h0, imm_8[7:2] } </TD></TR><TR><TD>4'h2 </TD><TD>{ imm_8[3:0], 24'h0, imm_8[7:4] } </TD></TR><TR><TD>4'h3 </TD><TD>{ imm_8[5:0], 24'h0, imm_8[7:6] } </TD></TR><TR><TD>4'h4 </TD><TD>{ imm_8[7:0], 24'h0 } </TD></TR><TR><TD>4'h5 </TD><TD>{ 2'h0, imm_8[7:0], 22'h0 } </TD></TR><TR><TD>4'h6 </TD><TD>{ 4'h0, imm_8[7:0], 20'h0 } </TD></TR><TR><TD>4'h7 </TD><TD>{ 6'h0, imm_8[7:0], 18'h0 } </TD></TR><TR><TD>4'h8 </TD><TD>{ 8'h0, imm_8[7:0], 16'h0 } </TD></TR><TR><TD>4'h9 </TD><TD>{ 10'h0, imm_8[7:0], 14'h0 } </TD></TR><TR><TD>4'h10 </TD><TD>{ 12'h0, imm_8[7:0], 12'h0 } </TD></TR><TR><TD>4'h11 </TD><TD>{ 14'h0, imm_8[7:0], 10'h0 } </TD></TR><TR><TD>4'h12 </TD><TD>{ 16'h0, imm_8[7:0], 8'h0 } </TD></TR><TR><TD>4'h13 </TD><TD>{ 18'h0, imm_8[7:0], 6'h0 } </TD></TR><TR><TD>4'h14 </TD><TD>{ 20'h0, imm_8[7:0], 4'h0 } </TD></TR><TR><TD>4'h15 </TD><TD>{ 22'h0, imm_8[7:0], 2'h0 } </TD></TR><Caption><P>Table 10 TRANS: Offset Encoding </P></Caption></Table><P id="LinkTarget_426">4.4 Register transfer offset encoding 
</P><Table><TR><TH>Category </TH><TH>Type </TH><TH>Syntax </TH><TH>25 'I' </TH><TH>24 'P' </TH><TH>23 'U' </TH><TH>22 'B' </TH><TH>21 'W' </TH><TH>20 'L' </TH><TH>11 </TH><TH>10 </TH><TH>9 </TH><TH>8 </TH><TH>7 </TH><TH>6 </TH><TH>5 </TH><TH>4 </TH><TH>3 </TH><TH>2 </TH><TH>1 </TH><TH>0 </TH></TR><TR><TH>Immediate offset / index </TH><TD>Immediate offset </TD><TD>[&lt;Rn&gt;, #+/-&lt;offset_12&gt;] </TD><TD>0 </TD><TD>1 </TD><TD>-</TD><TD>-</TD><TD>0 </TD><TD>-</TD><TD>offset_12 </TD></TR><TR><TD>Immediate pre-indexed </TD><TD>[&lt;Rn&gt;, #+/-&lt;offset_12&gt;]! </TD><TD>0 </TD><TD>1 </TD><TD>-</TD><TD>-</TD><TD>1 </TD><TD>-</TD><TD>offset_12 </TD></TR><TR><TH/><TD>Immediate post-indexed </TD><TD>[&lt;Rn&gt;], #+/-&lt;offset_12&gt; </TD><TD>0 </TD><TD>0 </TD><TD>-</TD><TD>-</TD><TD>0 </TD><TD>-</TD><TD>offset_12 </TD></TR><TR><TH/><TD>Immediate post-indexed, unprivilaged memory access </TD><TD>[&lt;Rn&gt;], #+/-&lt;offset_12&gt; </TD><TD>0 </TD><TD>0 </TD><TD>-</TD><TD>-</TD><TD>1 </TD><TD>-</TD><TD>offset_12 </TD></TR><TR><TH>Register offset / </TH><TD>Register offset </TD><TD>[&lt;Rn&gt;, +/-&lt;Rm&gt;] </TD><TD>1 </TD><TD>1 </TD><TD>-</TD><TD>-</TD><TD>0 </TD><TD>-</TD><TD>8'h0 </TD><TD>Rm </TD></TR></Table><P>Amber Amber 2 Core Specification May 2011 
</P><Table><TR><TH>Category </TH><TH>Type </TH><TH>Syntax </TH><TH>25 'I' </TH><TH>24 'P' </TH><TH>23 'U' </TH><TH>22 'B' </TH><TH>21 'W' </TH><TH>20 'L' </TH><TH>11 </TH><TH>10 </TH><TH>9 </TH><TH>8 </TH><TH>7 </TH><TH>6 </TH><TH>5 </TH><TH>4 </TH><TH>3 </TH><TH>2 </TH><TH>1 </TH><TH>0 </TH></TR><TR><TH>index </TH><TD>Register pre-indexed </TD><TD>[&lt;Rn&gt;, +/-&lt;Rm&gt;]! </TD><TD>1 </TD><TD>1 </TD><TD>-</TD><TD>-</TD><TD>1 </TD><TD>-</TD><TD>8'h0 </TD><TD/><TD/><TD/><TD>Rm </TD><TD/></TR><TR><TD>Register post-indexed </TD><TD>[&lt;Rn&gt;], +/-&lt;Rm&gt; </TD><TD>1 </TD><TD>0 </TD><TD>-</TD><TD>-</TD><TD>0 </TD><TD>-</TD><TD>8'h0 </TD><TD/><TD/><TD/><TD>Rm </TD><TD/></TR><TR><TD>Register post-indexed, unprivilaged memory access </TD><TD>[&lt;Rn&gt;], +/-&lt;Rm&gt; </TD><TD>1 </TD><TD>0 </TD><TD>-</TD><TD>-</TD><TD>1 </TD><TD>-</TD><TD>8'h0 </TD><TD/><TD/><TD/><TD>Rm </TD><TD/></TR><TR><TH>Scaled register offset / index </TH><TD>Scaled register offset </TD><TD>[&lt;Rn&gt;, +/-&lt;Rm&gt;, &lt;shift&gt; #&lt;shift_imm&gt;] </TD><TD>1 </TD><TD>1 </TD><TD>-</TD><TD>-</TD><TD>0 </TD><TD>-</TD><TD>shift_imm </TD><TD><Link>Shift </Link></TD><TD>0 </TD><TD/><TD>Rm </TD><TD/></TR><TR><TD>Scaled register pre-indexed </TD><TD>[&lt;Rn&gt;, +/-&lt;Rm&gt;, &lt;shift&gt; #&lt;shift_imm&gt;]! </TD><TD>1 </TD><TD>1 </TD><TD>-</TD><TD>-</TD><TD>1 </TD><TD>-</TD><TD>shift_imm </TD><TD><Link>Shift </Link></TD><TD>0 </TD><TD/><TD>Rm </TD><TD/></TR><TR><TD>Scaled register post-indexed </TD><TD>[&lt;Rn&gt;], +/-&lt;Rm&gt;, &lt;shift&gt; #&lt;shift_imm&gt; </TD><TD>1 </TD><TD>0 </TD><TD>-</TD><TD>-</TD><TD>0 </TD><TD>-</TD><TD>shift_imm </TD><TD><Link>Shift </Link></TD><TD>0 </TD><TD/><TD>Rm </TD><TD/></TR><TR><TD>Scaled register post-indexed, unprivilaged memory access </TD><TD>[&lt;Rn&gt;], +/-&lt;Rm&gt;, &lt;shift&gt; #&lt;shift_imm&gt; </TD><TD>1 </TD><TD>0 </TD><TD>-</TD><TD>-</TD><TD>1 </TD><TD>-</TD><TD>shift_imm </TD><TD><Link>Shift </Link></TD><TD>0 </TD><TD/><TD>Rm </TD><TD/></TR></Table><P>Where; Pre-indexed: Address adjusted before access Post-indexed: Address adjusted after access I25, P24 and W21 encode the instruction as shown in the table above. U23 = 1; address = Rn + offset_12 </P><P>= 0; address = Rn – offset_12 B22 = 0; data type is 32-bit word = 1; data type is byte L20 = 1; load = 0; store </P></Sect></Sect><Sect><H3 id="LinkTarget_427">4.5 Shift Encoding </H3><P>This encoding is used in both register and single data transfer instructions. </P><Table><Caption><P>Table 11 REGOP, TRANS: Shift Encoding </P></Caption><TR><TH>Conditi on </TH><TH>Type </TH><TH>Syntax </TH></TR><TR><TD>2'h0 </TD><TD>Logical Shift Left </TD><TD>lsl </TD></TR><TR><TD>2'h1 </TD><TD>Logical Shift Right </TD><TD>lsr </TD></TR><TR><TD>2'h2 </TD><TD>Arithmetic Shift Right (sign extend) </TD><TD>asr </TD></TR><TR><TD>2'h3 </TD><TD>Rotate Right with Extent (CO -&gt; bit 31, bit 0 -&gt; CO), if shift amount = 0, else Rotate Right </TD><TD>ror, rrx </TD></TR></Table><P id="LinkTarget_428">4.6 Load &amp; Store Multiple 
</P><Table><Caption><P>Table 12 MTRANS: Index options with ldm and stm </P></Caption><TR><TH>Mode </TH><TH>Stack Load Equivalent </TH><TH>Stack Store Equivalent </TH><TH>Instructions </TH><TH>24 'P' </TH><TH>23 'U' </TH><TH>22 'S' </TH><TH>21 'W ' </TH><TH>20 'L' </TH></TR><TR><TD>Increment After (ia) </TD><TD>Full Descending (fd) </TD><TD>Empty Ascending (ea) </TD><TD>ldmia, stmia, ldmfd, stmea </TD><TD>0 </TD><TD>1 </TD><TD>-</TD><TD>-</TD><TD>-</TD></TR><TR><TD>Increment Before (ib) </TD><TD>Empty Descending (ed) </TD><TD>Full Ascending (fa) </TD><TD>lmdib, stmib, ldmed, stmfa </TD><TD>1 </TD><TD>1 </TD><TD>-</TD><TD>-</TD><TD>-</TD></TR><TR><TD>Decrement After (da) </TD><TD>Full Ascending (fa) </TD><TD>Empty Descending (ed) </TD><TD>ldmda, stmda, ldmfa, stmed </TD><TD>0 </TD><TD>0 </TD><TD>-</TD><TD>-</TD><TD>-</TD></TR></Table><Table><TR><TH>Mode </TH><TH>Stack Load Equivalent </TH><TH>Stack Store Equivalent </TH><TH>Instructions </TH><TH>24 'P' </TH><TH>23 'U' </TH><TH>22 'S' </TH><TH>21 'W ' </TH><TH>20 'L' </TH></TR><TR><TD>Decrement Before (db) </TD><TD>Empty Ascending (ea) </TD><TD>Full Descending (fd) </TD><TD>lmddb, stmdb, ldmea, stmfd </TD><TD>1 </TD><TD>0 </TD><TD>-</TD><TD>-</TD><TD>-</TD></TR></Table><P>S22 </P><P>The S bit for ldm that loads the PC, the S bit indicates that the status bits loaded. For ldm instructions that do not load the PC and all stm instructions, the S bit indicates that when the processor is in a privileged mode, the User mode banked registers are transferred instead of the registers of the current mode. Ldm with the S bit set is unpredictable in User mode. </P><P>W21 
Indicates that the base register is updated after the transfer. 
</P><P>L20 
Distinguishes between Load (L==1) and Store (L==0) instructions. 
</P></Sect><Sect><H3 id="LinkTarget_429">4.7 Branch offset </H3><P>Branch instructions contain an offset in the lower 24 bits of the instruction. This offset is combined with the current pc value to calculate the branch target, as follows: </P><L><LI><LI_Label>1. 	</LI_Label><LI_Title>Shift the 24-bit signed immediate value left two bits to form a 26-bit value. </LI_Title></LI><LI><LI_Label>2. 	</LI_Label><LI_Title>Add this to the pc. </LI_Title></LI></L></Sect><Sect><H3 id="LinkTarget_430">4.8 Booth's Multiplication Algorithm </H3><P>Booth's algorithm involves repeatedly adding one of two predetermined values A and S to a product P, then performing a rightward arithmetic shift on P. Let m and r be the multiplicand and multiplier, respectively; and let x and y represent the number of bits in m and r. </P><P>1. 	Determine the values of A and S, and the initial value of P. All of these numbers should have a length equal to (x + y + 1). </P><L><LI><LI_Label>1. 	</LI_Label><LI_Title>A: Fill the most significant (leftmost) bits with the value of m. Fill the remaining (y + 1) bits with zeros. </LI_Title></LI><LI><LI_Label>2. 	</LI_Label><LI_Title>S: Fill the most significant bits with the value of (−m) in two's complement notation. Fill the remaining (y + 1) bits with zeros. </LI_Title></LI><LI><LI_Label>3. 	</LI_Label><LI_Title>P: Fill the most significant x bits with zeros. To the right of this, append the value of r. Fill the least significant (rightmost) bit with a zero. </LI_Title></LI></L><P>2. Examine the two least significant (rightmost) bits of P. </P><L><LI><LI_Label>1.</LI_Label><LI_Title> If they are 01, find the value of P + A. Ignore any overflow. </LI_Title></LI><LI><LI_Label>2.</LI_Label><LI_Title> If they are 10, find the value of P + S. Ignore any overflow. </LI_Title></LI></L><P>Amber Amber 2 Core Specification 	May 2011 
</P><L><LI><LI_Label>3.</LI_Label><LI_Title> If they are 00, do nothing. Use P directly in the next step. </LI_Title></LI><LI><LI_Label>4.</LI_Label><LI_Title> If they are 11, do nothing. Use P directly in the next step. </LI_Title></LI></L><L><LI><LI_Label>3. 	</LI_Label><LI_Title>Arithmetically shift the value obtained in the 2nd step by a single place to the right. Let P now equal this new value. </LI_Title></LI><LI><LI_Label>4. 	</LI_Label><LI_Title>Repeat steps 2 and 3 until they have been done y times. </LI_Title></LI><LI><LI_Label>5. </LI_Label><LI_Title>Drop the least significant (rightmost) bit from P. This is the product of m and r. Here is the algorithm in C-code form; </LI_Title></LI></L><Figure><ImageData src="images/amber-spec_img_6.jpg"/>unsigned int mul ( unsigned int Rm, unsigned int Rs ) { unsigned int multiply_result_hi, multiply_result_lo, n, booth_bits; for (n=0;n&lt;33;n++){ if (n==0) { booth_bits = ((Rs &amp; 1)&lt;&lt;1); multiply_result_lo = Rs; if (booth_bits == 1) { multiply_result_hi = Rm; } else if (booth_bits == 2) { multiply_result_hi = ~Rm + 1;} else { multiply_result_hi = 0; } } else { booth_bits = multiply_result &amp; 3; multiply_result_lo = (multiply_result_lo &gt;&gt;1) | (( multiply_result_hi &amp; 1)&lt;&lt;31); multiply_result_hi = (multiply_result_hi &gt;&gt;1) | (multiply_result_hi &amp; 0x80000000); if (booth_bits == 1) { multiply_result_hi = multiply_result_hi + Rm; } if (booth_bits == 2) { multiply_result_hi = multiply_result_hi + (~Rm + 1); } } </Figure><P>} 
</P><P>return multiply_result_lo; 
} 
</P><P>Amber Amber 2 Core Specification May 2011 
</P></Sect></Sect><Sect><H2 id="LinkTarget_431">Interrupts </H2><Table><Caption><P>Table 13 Interrupt Types </P></Caption><TR><TH>Interrupt Type </TH><TH>Processor Mode </TH><TH>Address </TH></TR><TR><TD>Reset </TD><TD>Supervisor (svc) </TD><TD>0x00000000 </TD></TR><TR><TD>Undefined Instructions </TD><TD>Supervisor (svc) </TD><TD>0x00000004 </TD></TR><TR><TD>Software Interrupt (SWI) </TD><TD>Supervisor (svc) </TD><TD>0x00000008 </TD></TR><TR><TD>Prefetch Abort (instruction fetch memory abort) </TD><TD>Supervisor (svc) </TD><TD>0x0000000C </TD></TR><TR><TD>Data Abort (data access memory abort) </TD><TD>Supervisor (svc) </TD><TD>0x00000010 </TD></TR><TR><TD>Address exception </TD><TD>Supervisor (svc) </TD><TD>0x00000014 </TD></TR><TR><TD>IRQ (interrupt) </TD><TD>IRQ (irq) </TD><TD>0x00000018 </TD></TR><TR><TD>FIRQ (fast interrupt) </TD><TD>FIRQ (firq) </TD><TD>0x0000001C </TD></TR><TR><TD>-</TD><TD>User (usr) </TD><TD>-</TD></TR></Table><P>The modes other than User mode are known as privileged modes. They have full access to system resources and can change mode freely. When an exception occurs, the banked versions of r14, the link register, is used to save the pc value and status bits. </P></Sect><Sect><H2 id="LinkTarget_432">Registers </H2><Table><Caption><P>Table 14 Register Sets </P></Caption><TR><TH>User (USR) </TH><TH>Supervisor (SVC) </TH><TH>Interrupt (IRQ) </TH><TH>Fast Interrupt (FIRQ) </TH></TR><TR><TD/><TD>r0 </TD><TD/></TR><TR><TD/><TD>r1 </TD><TD/></TR><TR><TD/><TD>r2 </TD><TD/></TR><TR><TD/><TD>r3 </TD><TD/></TR><TR><TD/><TD>r4 </TD><TD/></TR><TR><TD/><TD>r5 </TD><TD/></TR><TR><TD/><TD>r6 </TD><TD/></TR><TR><TD/><TD>r6 </TD><TD/></TR><TR><TD/><TD>r7 </TD><TD/></TR><TR><TD/><TD>r8 </TD><TD>r8_firq </TD></TR><TR><TD/><TD>r9 </TD><TD>r9_firq </TD></TR><TR><TD/><TD>r10 </TD><TD>r10_firq </TD></TR><TR><TD/><TD>r11 (fp ) </TD><TD>r11_firq </TD></TR><TR><TD/><TD>r12 ( ip ) </TD><TD>r12_firq </TD></TR><TR><TD>r13 ( sp ) </TD><TD>r13_svc </TD><TD>r13_irq </TD><TD>r13_firq </TD></TR><TR><TD>r14 ( lp ) </TD><TD>r14_svc </TD><TD>r14_irq </TD><TD>r14_firq </TD></TR><TR><TD/><TD>r15 ( pc ) </TD><TD/></TR></Table><P>Table 15 Status Bits – Part of the PC </P><Table><TR><TH>Field </TH><TH>Position </TH><TH>Type </TH><TH>Description </TH></TR><TR><TD>flags </TD><TD>[31:28] </TD><TD>User Writable </TD><TD>{ Negative, Zero, Carry, oVerflow } </TD></TR><TR><TD>I </TD><TD>27 </TD><TD>Privileged </TD><TD>IRQ mask, disables IRQs when high </TD></TR><TR><TD>F </TD><TD>26 </TD><TD>Privileged </TD><TD>FIRQ Mask, disables FIRQs when high </TD></TR><TR><TD>mode </TD><TD>[1:0] </TD><TD>Privileged </TD><TD>Processor mode 3 -Supervisor 2 -Interrupt 1 -Fast Interrupt 0 -User </TD></TR></Table></Sect><Sect><H2 id="LinkTarget_433">Cache </H2><P>The Amber cache size is optimized to use FPGA Block RAMs. Each way has 256 lines of 16 bytes. 256 lines x 16 bytes x 2 ways = 8k bytes. The address tag is 20 bits. Each cache can be configured with either 2, 3, 4 or 8 ways. </P><P>Table 16 Cache Specification </P><Table><TR><TH>Ways </TH><TH>2 </TH><TH>3 </TH><TH>4 </TH><TH>8 </TH></TR><TR><TH>Lines per way </TH><TD>256 </TD><TD>256 </TD><TD>256 </TD><TD>256 </TD></TR><TR><TH>Words per line </TH><TD>4 </TD><TD>4 </TD><TD>4 </TD><TD>4 </TD></TR><TR><TH>Total words </TH><TD>2048 </TD><TD>3072 </TD><TD>4096 </TD><TD>8192 </TD></TR><TR><TH>Total bytes </TH><TD>8192 </TD><TD>12288 </TD><TD>16384 </TD><TD>32768 </TD></TR><TR><TH>FPGA 9K Block RAMs </TH><TD>8 + 2 = 10 </TD><TD>12 + 3 = 15 </TD><TD>16 + 4 = 20 </TD><TD>32 + 8 = 40 </TD></TR></Table><Sect><H2 id="LinkTarget_434">8 Amber Project </H2><P>The Amber project is a complete processor system implemented on an FPGA development board. The purpose of the project is to provide an evironment that gives an example usage of the Amber 2 core, and supports a set of tests that verify the correct functionality of the code. This is especially important if modificatiosn to the core are made. </P><Sect><H3 id="LinkTarget_435">8.1 Amber Port List </H3><P>The following table gives the port list for the Amber 2x core. The Amber 23 and Amber 25 cores have identical port lists. </P><Table><Caption><P>Table 17 Amber 2x Core Port List </P></Caption><TR><TH>Name </TH><TH>Width </TH><TH>Direction </TH><TH>Description </TH></TR><TR><TD>i_clk </TD><TD>1 </TD><TD>in </TD><TD>Clock input. The core only has a single clock. The Wishbone interface also works on this clock. </TD></TR><TR><TD>i_irq </TD><TD>1 </TD><TD>in </TD><TD>Interrupt request, active high. Causes the core to switch to IRQ mode and jump to the IRQ address vector when asserted. The switch does not occur until the end of the current instruction. For example if the core is executing a stm instruction it could take 40 or 50 cycles to complete this instruction. Once the instruction has completed the core will jump to the IRQ vector and execute the instruction at that location. </TD></TR><TR><TD>i_firq </TD><TD>1 </TD><TD>in </TD><TD>Fast Interrupt request, active high. Causes the core to switch to FIRQ mode and jump to the FIRQ address vector when asserted. Again the core makes the switch after the current instruction has completed. </TD></TR><TR><TD>i_system_rdy </TD><TD>1 </TD><TD>in </TD><TD>Connected to the stall signal that stalls the decode and execute stages of the core. The system uses this signal to freeze the core until the DDR3 main memory initialization has completed. </TD></TR><TR><TD>Wishbone Interface </TD><TD/><TD/><TD/></TR><TR><TD>o_wb_adr </TD><TD>32 </TD><TD>out </TD><TD>Byte address. Note that the core only generates 26-bit instruction addresses but can generate full 32-bit data addresses. </TD></TR><TR><TD>o_wb_sel </TD><TD>4 </TD><TD>out </TD><TD>Byte enable for writes. Bit 0 corresponds to byte 0 which is bits [7:0] on the data buses. </TD></TR><TR><TD>o_wb_we </TD><TD>1 </TD><TD>out </TD><TD>Write enable, active high. </TD></TR><TR><TD>i_wb_dat </TD><TD>32 </TD><TD>in </TD><TD>Read data. Active when i_wb_ack is asserted in a read cycle. </TD></TR><TR><TD>o_wb_dat </TD><TD>32 </TD><TD>out </TD><TD>Write data. Active when o_wb_stb is high. </TD></TR><TR><TD>o_wb_cyc </TD><TD>1 </TD><TD>out </TD><TD>Holds bus ownership during multi-cycle accesses. </TD></TR><TR><TD>o_wb_stb </TD><TD>1 </TD><TD>out </TD><TD>Per-cycle strobe. </TD></TR><TR><TD>i_wb_ack </TD><TD>1 </TD><TD>in </TD><TD>Used to terminate read and write accesses. </TD></TR><TR><TD>i_wb_err </TD><TD>1 </TD><TD>in </TD><TD>Used to indicate an error on an access. Currently not used within the Amber 2 core. </TD></TR></Table></Sect><Sect><H3 id="LinkTarget_436">8.2 Amber 23 Verilog Files </H3><P>The following table describes each Verilog source file in the Amber23 core. These files are located in $AMBER_BASE/hw/vlog/amber23. </P><Table><Caption><P>Table 18 Amber 23 Core Source Files </P></Caption><TR><TD>Name </TD><TD>Description </TD></TR><TR><TD>a23_config_definesv </TD><TD>Defines used to configure the amber core. The number of ways in the cache is configurable. Also contains a set of debug switches which enable debug messages to be printed during simulation. </TD></TR><TR><TD>a23_localparams.v </TD><TD>Local parameters used in various amber source files. </TD></TR><TR><TD>a23_wishbone.v </TD><TD>The Wishbone interface connecting the Execute stage and Cache to the rest of the system. Instantiated in a23_fetch. </TD></TR><TR><TD>a23_alu.v </TD><TD>The arithmetic logic unit. Includes a 32-bit 2's compliment adder/subtractor as well as logical functions such as AND and XOR. </TD></TR><TR><TD>a23_functions.v </TD><TD>Common Verilog functions. </TD></TR><TR><TD>a23_core.v </TD><TD>Top-level Amber module. </TD></TR><TR><TD>a23_barrel_shifter.v </TD><TD>32-bit barrel shifter instantiated in Execute. </TD></TR><TR><TD>a23_cache.v </TD><TD>Synthesizable cache. Instantiated in a23_fetch. Cache misses cause the core to stall. The cache then issues a quad-word read on the wishbone bus, starting with the word that missed, and wrapping at the quad-word boundary. </TD></TR><TR><TD>a23_coprocessor.v </TD><TD>Co-processor 15 registers and control signals. Instantiated in a23_core. </TD></TR><TR><TD>a23_decode.v </TD><TD>The instruction decode pipeline stage. Instantiated in a23_core. </TD></TR><TR><TD>a23_decompile.v </TD><TD>The decompiler. This is a non-synthesizable debug module. It creates the amber.dis file which lists every instruction executed by the core. </TD></TR><TR><TD>a23_execute.v </TD><TD>The execute pipeline stage. Instantiated in a23_core. It contains the alu, multiply, and register_bank sub-modules. </TD></TR><TR><TD>a23_fetch.v </TD><TD>The Fetch stage. This contains the Cache and Wishbone interface modules. It is instantiated in a23_core. </TD></TR><TR><TD>a23_multiply.v </TD><TD>32-bit 2's compliment multiply and multiply-accumulate unit. Uses the Booth algorithm and takes 34 cycles to complete a signed multiply-accumulate operation but is quite small in logic area. </TD></TR><TR><TD>a23_register_bank.v </TD><TD>Contains all 27 registers r0 to r15 for each mode of operation. Registers are implemented as real flipflops in the FPGA. This allows multiple read and write access to the bank simultaneously. </TD></TR></Table><P>The following diagram shows the Verilog module structure within the Amber 23 core. </P><P>Figure 5 -Amber 23 Core Verilog Structure </P><Figure><ImageData src="images/amber-spec_img_7.jpg"/>a23_decode.v Instruction decode a23_fetch.v Address &amp; Write Data a23_core.v a23_wishbone.v Wishbone Interface Wishbone I/F IRQ FIRQ a23_cache.v Unified instruction and data cache Read Data execute.v a23_register_bank.v 27 Registers a23_multiply.v 32-bit Multiply &amp; Accumulate a23_barrel_shift.v 32-bit Barrel Shifter a23_alu.v 32-bit ALU Control &amp; Read Data </Figure></Sect><Sect><H3 id="LinkTarget_437">8.3 Amber 25 Verilog Files </H3><P>The following table describes each Verilog source file in the Amber25 core. These files are located in $AMBER_BASE/hw/vlog/amber25. </P><P>Table 19 Amber 25 Core Source Files </P><P>Name Description </P><P>a25_config_definesv Defines used to configure the amber core. The number of ways in the cache is configurable. Also contains a set of debug switches which enable debug messages to be printed during simulation. </P><P>a25_localparams.v Local parameters used in various amber source files. </P><P>a25_wishbone.v The Wishbone interface connecting the Execute stage, instruction cache and data cache to the rest of the system. Instantiated in a25_core. </P><P>a25_wishbone_buf.v An access buffer for the wishbone interface. Either a single read request or two write requests can be buffered in each instance of the buffer. The buffer is instantiated 3 times, for instruction fetches, uncached data read/writes and cached data read/writes. </P><Table><TR><TD>Name </TD><TD>Description </TD></TR><TR><TD>a25_alu.v </TD><TD>The arithmetic logic unit. Includes a 32-bit 2's compliment adder/subtractor as well as logical functions such as AND and XOR. </TD></TR><TR><TD>a25_functions.v </TD><TD>Common Verilog functions. </TD></TR><TR><TD>a25_core.v </TD><TD>Top-level Amber module. </TD></TR><TR><TD>a25_barrel_shifter.v </TD><TD>32-bit barrel shifter instantiated in a25_execute. </TD></TR><TR><TD>a25_shifter.v </TD><TD>Contains the actual barrel shift logic. A parameter controls whether it provides a full barrel shifter or a fast barrel shifter. One of each is instantiated by the a25_barrel_shifter. </TD></TR><TR><TD>a25_coprocessor.v </TD><TD>Co-processor 15 registers and control signals. Instantiated in a25_core. </TD></TR><TR><TD>a25_dcache.v </TD><TD>Synthesizable data cache. Instantiated in a25_mem. Cache misses cause the core to stall. The cache then issues a quad-word read on the wishbone bus, starting with the word that missed, and wrapping at the quad-word boundary. </TD></TR><TR><TD>a25_decode.v </TD><TD>The instruction decode pipeline stage. Instantiated in a25_core. </TD></TR><TR><TD>a25_decompile.v </TD><TD>The decompiler. This is a non-synthesizable debug module. It creates the amber.dis file which lists every instruction executed by the core. </TD></TR><TR><TD>a25_execute.v </TD><TD>The execute pipeline stage. Instantiated in a25_core. It contains the alu, multiply, and register_bank sub-modules. </TD></TR><TR><TD>a25_fetch.v </TD><TD>The Fetch stage. This contains the instruction cache module. It is instantiated in a25_core. </TD></TR><TR><TD>a25_icache.v </TD><TD>Synthesizable instruction cache. Instantiated in a25_fetch. Cache misses cause the core to stall. The cache then issues a quad-word read on the wishbone bus, starting with the word that missed, and wrapping at the quad-word boundary. </TD></TR><TR><TD>a25_mem.v </TD><TD>The Memory stage. This contains the data cache module. It is instantiated in a25_core. </TD></TR><TR><TD>a25_multiply.v </TD><TD>32-bit 2's compliment multiply and multiply-accumulate unit. Uses the Booth algorithm and takes 34 cycles to complete a signed multiply-accumulate operation but is quite small in logic area. </TD></TR><TR><TD>a25_register_bank.v </TD><TD>Contains all 27 registers r0 to r15 for each mode of operation. Registers are implemented as real flipflops in the FPGA. This allows multiple read and write access to the bank simultaneously. </TD></TR><TR><TD>a25_write_back </TD><TD>The Write Back stage. Registers the read data from the data cache before sending it back to a25_execute. It is instantiated in a25_core/ </TD></TR></Table><P>The following diagram shows the Verilog module structure within the Amber25 core. </P><P>Figure 6 -Amber 25 Core Verilog Structure </P><Figure><ImageData src="images/amber-spec_img_8.jpg"/>a25_decode.v Instruction decode a25_fetch.v Instruction Address a25_core.v a23_wishbone.v Wishbone Interface Wishbone I/F IRQ FIRQ a25_icache.v Instruction cache Instruction execute.v a25_register_bank.v 27 Registers a25_multiply.v 32-bit Multiply &amp; Accumulate a25_barrel_shift.v 32-bit Barrel Shifter a25_alu.v 32-bit ALU Control a25_mem.v Data Address, Write Data a25_dcache.v Data cache Read Data a25_write_back.v Write back stage </Figure></Sect><Sect><H3 id="LinkTarget_438">8.4 Project Directory Structure </H3><P>The following table describes the directories and sub-directories  located under $AMBER_BASE. </P><Table><Caption><P>Table 20 Project directory structure </P></Caption><TR><TD>Directory </TD><TD>Description </TD></TR><TR><TD>doc </TD><TD>Contains all project documentation. </TD></TR><TR><TD>hw </TD><TD>Contains all Verilog source files, simulations and synthesis scripts, and hardware test source files. </TD></TR><TR><TD>hw/fpga </TD><TD>Files relating to FPGA synthesis. </TD></TR><TR><TD>hw/fpga/bin </TD><TD>Contains the FPGA synthesis makefile and supporting scripts. </TD></TR><TR><TD>hw/fpga/bitfiles </TD><TD>This directory is created during the FPGA synthsis process. It is used to store the final bitfile generated at the end of the FPGA syntheis process. </TD></TR><TR><TD>hw/fpga/log </TD><TD>This directory is created during the FPGA synthsis process. It is used to store log files </TD></TR></Table><Table><TR><TD>Directory </TD><TD>Description </TD></TR><TR><TD/><TD>for each step of the FPGA synthesis process. </TD></TR><TR><TD>hw/fpga/work </TD><TD>This directory is created during the FPGA synthsis process. It is used to store temporary files created during the FPGA synthsis process. These files get erased when a new synthess run is started. </TD></TR><TR><TD>hw/sim </TD><TD>Where tests are run from. The Verilog simulator work directory, wave dump and any other simulation output files go in here. </TD></TR><TR><TD>hw/tests </TD><TD>Holds a set of hardware tests written in assembly. These tests focus on verifying the correct operation of the instruction set. If any modifications are made to the Amber core it is important that these tests still pass. </TD></TR><TR><TD>hw/tools </TD><TD>Holds scripts used to run Verilog simulations. </TD></TR><TR><TD>hw/vlog </TD><TD>Verilog source files. </TD></TR><TR><TD>hw/vlog/amber23 </TD><TD>Amber 23 core Verilog source files. </TD></TR><TR><TD>hw/vlog/amber25 </TD><TD>Amber 25 core Verilog source files. </TD></TR><TR><TD>hw/vlog/ethmac </TD><TD>The Ethernet MAC Verilog source files. These files come from the Opencores Ethmac project and are reproduced here for convenience. </TD></TR><TR><TD>hw/vlog/lib </TD><TD>Hardware libary Verilog files including memory models. The Amber project provides a simple generic library that is normally used for simulations. It also provides some wrappers for Xilinx library elements. </TD></TR><TR><TD>hw/vlog/system </TD><TD>FPGA system Verilog source files. </TD></TR><TR><TD>hw/vlog/tb </TD><TD>Testbench Verilog files. </TD></TR><TR><TD>hw/vlog/xs6_ddr3 </TD><TD>Xilinx Spartan-6 DDR3 controller Verilog files go in here. These are not provided with the project for copyright reasons. They are needed to implement the Amber system on a Spartan-6 development board and must be generated in Xilinx Coregen. </TD></TR><TR><TD>hw/vlog/xv6_ddr3 </TD><TD>Xilinx Virtex-6 DDR3 controller Verilog files go in here. These are not provided with the project for copyright reasons. They are needed to implement the Amber system on a Virtex-6 development board and must be generated in Xilinx Coregen. </TD></TR><TR><TD>sw </TD><TD>Contains C source files for applications that run on the Amber system, as well as some utilities that aid in debugging the system. </TD></TR><TR><TD>sw/boot-loader </TD><TD>C, assembly sources and a makefile for the boot-loader application. </TD></TR><TR><TD>sw/ethmac-test </TD><TD>C, assembly sources and a makefile for the ethmac-test application. This is a simple application that sends Ethernet packets through the Ethernet MAC in loopback mode to verify correct operation. </TD></TR><TR><TD>sw/hello-world </TD><TD>C, assembly source and a makefile for a simple stand-alone application example. </TD></TR><TR><TD>sw/include </TD><TD>Common C, assembly and makefile include files. </TD></TR><TR><TD>sw/mini-libc </TD><TD>C, assembly sources and a makefile to build the object that comprise a very small and limited stand-alone replacement for the libc library. </TD></TR><TR><TD>sw/tools </TD><TD>Shell scripts and C source files for compile and debug utilities. </TD></TR><TR><TD>sw/vmlinux </TD><TD>Contains the .mem and .dis files for the vmlinux simulation. </TD></TR></Table></Sect></Sect></Sect><Sect><H2 id="LinkTarget_439">Amber FPGA System </H2><P>The FPGA system included with the Amber project is a complete embedded processor system which included all peripherals needed to run Linux, including UART, timers and an Ethernet (MII) port. The following diagram shows the entire system. </P><P>Figure 7 -Amber System </P><P>MII Ethernet I/F </P><Figure><ImageData src="images/amber-spec_img_9.jpg"/></Figure><P>UART I/F </P><P>UART I/F </P><P>irq </P><P><Figure><ImageData src="images/amber-spec_img_10.jpg"/></Figure>firq </P><P>a2x_core.v </P><P>Amber 2x processor core </P><Figure><ImageData src="images/amber-spec_img_11.jpg"/></Figure><Figure><ImageData src="images/amber-spec_img_12.jpg"/>wishbone_arbiter.v eth_top.v B10/100 Ethernet MAC boot_mem.v 8kB embedded SRAM – contains boot loader code uart.v UART 0 Statically configurable simple UART uart.v UART 1 Statically configurable simple UART </Figure><P>clocks_resets.v </P><P>Instantiates PLL and reset generation logic </P><P>system.v </P><P>interrupt_controller.v Primary interrupt controller </P><P>timer_module.v </P><P>Configurable timers </P><P>test_module.v </P><P>Test and debug registers </P><P>wb_xs6_ddr3_bridge.v </P><P>Wishbone to Xilinx </P><P>Spartan-6 DDR3 </P><P>controller bridge </P><P>mcb_ddr3.v </P><P>Xilinx Spartan-6 
DDR3 controller 
</P><Figure><ImageData src="images/amber-spec_img_13.jpg"/></Figure><Figure><ImageData src="images/amber-spec_img_14.jpg"/></Figure><P>DDR3 SDRAM I/F </P><P>All the Verilog source code was specifially developed for this project with the exception of the following modules; </P><L><L><LI><LI_Label>• 	</LI_Label><LI_Title>mcb_ddr3.v. The Xilinx Spartan-6 DDR3 controller was generated by the Xilinx Coregen tool. The files are not included with the project for copyright reasons. It is up to the user to optain the ISE software from Xilinx and generate the correct memory controller. Note that Wishbone bridge modules </LI_Title></LI><LI>are included that support both the Xilinx Spartan-6 DDR3 controller and the Virtex-6 controller. </LI></L><LI><LI_Label>• 	</LI_Label><LI_Title>eth_top.v. This module is from the Opencores Ethernet MAC 10/100 Mbps project. The Verilog code is included for convenience. It has not been modified, except to provide a memory module for the Spartan-6 FPGA. </LI_Title></LI></L><Sect><H2 id="LinkTarget_440">10 Verilog simulations </H2><Sect><H3 id="LinkTarget_441">10.1 Installing the Amber project </H3><P>If you have not already done so, you need to download the Amber project from Opencores.org. The Amber project includes all the Verilog source files, tests written in assembly, a boot loader application written in C and scripts to compile, simulate and synthesize the code. You can either download a tar.gz file from the Opencores website or better still, connect to the Opencores Subversion server to download the project. This can be done on a Linux PC as follows; </P><P>mkdir /&lt;your amber install path&gt;/ 
cd /&lt;your amber install path&gt;/ 
svn --username &lt;your opencores account name&gt; --password &lt;your opencores password&gt; \ 
co http://opencores.org/ocsvn/amber/amber/trunk 
</P></Sect><Sect><H3 id="LinkTarget_442">10.2 Installing the Compiler </H3><P>Tests need to be compiled before you can run simulations. You need to install a GNU cross-compiler to do this. The easiest way to install the GNU tool chain is to download a ready made package. Code Sourcery provides a free one. To download the Code Sourcery package, go to this page </P><P><Link>http://www.codesourcery.com/sgpp/lite/arm </Link></P><P>and click on 'Download the current release'. This brings up the following page; </P><P>Figure 8 -Code Sourcery GNU Download </P><Figure><ImageData src="images/amber-spec_img_15.jpg"/></Figure><P>Select the GNU/Linux version and then the IA32 GNU/Linux Installer on the next page. Once the package is installed, add the following to your .bashrc file, where the PATH is set to where you install the Code Sourcery GNU package. </P><Figure><ImageData src="images/amber-spec_img_16.jpg"/># Change /proj/amber to where you saved the amber package on your system export AMBER_BASE=/&lt;your amber install path&gt;/trunk # Change /opt/Sourcery to where the package is installed on your system PATH=/&lt;your code sourcery install path&gt;/bin:${PATH} # AMBER_CROSSTOOL is the name added to the start of each GNU tool in </Figure><P>Amber Amber 2 Core Specification May 2011 
</P><Figure><ImageData src="images/amber-spec_img_17.jpg"/># the Code Sourcery bin directory. This variable is used in various makefiles to set # the correct tool to compile code for the Amber core export AMBER_CROSSTOOL=arm-none-linux-gnueabi # Xilinx ISE installation directory # This should be configured for you when you install ISE. # But check that is has the correct value </Figure><P># It is used in the run script to locate the Xilinx library elements. 
</P><P>export XILINX=/opt/Xilinx/11.1/ISE 
</P><Sect><H4 id="LinkTarget_443">10.2.1 GNU Tools Usage </H4><P>It's important to remember to use the correct switches with the GNU tools to restrict the ISA to the set of instructions supported by the Amber 2 core. The switches are already set in the makefiles included with the Amber 2 core. Here are the switches to use with gcc (arm-none-linux-gnueabi-gcc);</P><P> -march=armv2a -mno-thumb-interwork 
</P><P>These switches specify the correct version of the ISA, and tell the compiler not to create bx instructions. Here is the switch to use with the GNU linker, arm-nonelinux-gnueabi-ld; </P><P>--fix-v4bx 
</P><P>This switch converts any bx instructions (which are not supported) to 'mov pc, lr'. Here is an example usage from the boot-loader make process; </P><P>arm-none-linux-gnueabi-gcc -c -Os -march=armv2a -mno-thumb-interwork -ffreestanding 
</P><P>-I../include -c -o boot-loader.o boot-loader.c 
arm-none-linux-gnueabi-gcc -I../include -c -o start.o start.S 
arm-none-linux-gnueabi-gcc -c -Os -march=armv2a -mno-thumb-interwork -ffreestanding 
</P><P>-I../include -c -o crc16.o crc16.c 
arm-none-linux-gnueabi-gcc -c -Os -march=armv2a -mno-thumb-interwork -ffreestanding 
-I../include -c -o xmodem.o xmodem.c 
arm-none-linux-gnueabi-gcc -c -Os -march=armv2a -mno-thumb-interwork -ffreestanding 
-I../include -c -o elfsplitter.o elfsplitter.c 
</P><P>arm-none-linux-gnueabi-ld -Bstatic -Map boot-loader.map --strip-debug --fix-v4bx -o bootloader.elf -T sections.lds boot-loader.o start.o crc16.o xmodem.o elfsplitter.o 
../mini-libc/printf.o ../mini-libc/libc_asm.o ../mini-libc/memcpy.o 
</P><P>arm-none-linux-gnueabi-objcopy -R .comment -R .note boot-loader.elf 
../tools/amber-elfsplitter boot-loader.elf &gt; boot-loader.mem 
../tools/amber-memparams.sh boot-loader.mem boot-loader_memparams.v 
arm-none-linux-gnueabi-objdump -C -S -EL boot-loader.elf &gt; boot-loader.dis 
</P><P>A full list of compile switches for gcc can be found here; </P><P><Link>http://gcc.gnu.org/onlinedocs/gcc-4.5.2/gcc/ARM-Options.html#ARM-Options </Link></P><P>And for ld here; </P><P><Link>http://sourceware.org/binutils/docs-2.21/ld/ARM.html#ARM </Link></P></Sect></Sect><Sect><H3 id="LinkTarget_444">10.3 Running Simulations </H3><P>You should be able to use any Verilog-2001 compatible simulator to run simulations of the Amber 2 Core. The project comes with run scripts and project files for the Modelsim SE v6.5 and Veritak simulators. To run simulations using the Xilinx library models for RAMs, PLLs etc., you also need to have Xilinx ISE installed. </P><Sect><H4 id="LinkTarget_445">10.3.1 With Modelsim </H4><P>A script to run tests with Modelsim is included, $AMBER_BASE/hw/tools/run.sh. This script calls a makefile to compile the test, then calls the modelsim tools to compile and run the simulation, as follows; </P><L><LI><LI_Label>1. 	</LI_Label><LI_Title>vlib to create a modelsim library work directory, if not already created. </LI_Title></LI><LI><LI_Label>2. 	</LI_Label><LI_Title>vlog to compile the Verilog source code. </LI_Title></LI><LI><LI_Label>3. 	</LI_Label><LI_Title>vsim to run the simulation, either in command line mode or with the full user interface, depending on the switches passed into the run script. </LI_Title></LI></L><P>For ease of use, create a link to this script in the sim directory, and make sure all scripts have the execute bit set; </P><P>cd $AMBER_BASE 
chmod +x hw/tools/*.sh sw/tools/*.sh 
ln -s ../tools/run.sh hw/sim/run 
</P><P>Then to run a test, simply type run with the test name. The -g switch brings up the Modelsim GUI. To run in command line mode, just omit this switch; </P><P>cd $AMBER_BASE/hw/sim 
run add -g 
</P><P>To get a list of the switches that run understands, type 'run -h', e.g. 
</P><Figure><ImageData src="images/amber-spec_img_18.jpg"/>cd $AMBER_BASE/hw/sim run -h Usage: run &lt;test_name&gt; [-a] [-g] [-d] [-t] [-s] [-v] -h : Help -a : Run hardware tests (all tests in $AMBER_BASE/hw/tests) -g : Use Modelsim GUI -d &lt;cycle number to start dumping&gt;: Create vcd file -t &lt;cycle number to start dumping&gt;: Create vcd file and terminate -s : Use Xilinx Spatran6 Libraries (slower sim) -v : Use Xilinx Virtex6 Libraries (slower sim) -5 : Use Amber25 core instead of Amber23 core </Figure></Sect><Sect><H4 id="LinkTarget_446">10.3.2 With Veritak </H4><P>To download a trial version of the Veritak Verilog simulator for free, visit </P><P><Link>http://www.sugawara-systems.com. </Link></P><P>To create a Veritak project for Amber, start Veritak and select the menu item Verilog Project -&gt; New Verilog Project. Save the project in the $AMBER_BASE/hw/sim directory. Next the 'Select files to compile' dialogue comes up. Select the 'Import source files' button. This reads in the file $AMBER_BASE/hw/sim/veritak_src_files.txt. Then click 'Save Project'. </P><P>Before compiling the project, make sure that defines propagate throughout the design. In Verilog Project -&gt; Project Settings, make sure that Define Propagation is set to 'Throughout Project'. </P><P>To set the name of the test to run, edit the file $AMBER_BASE/hw/vlog/system_config_defines.v and change BOOT_MEM_FILE and AMBER_TEST_NAME to the name of the test you want to run. Then compile this test; </P><P>cd $AMBER_BASE/hw/tests 
make TEST=&lt;test name> 
</P><P>Now select the menu item 'Load Verilog Project' and select the project you created. You can now run the test. </P></Sect></Sect><Sect><H3 id="LinkTarget_447">10.4 Simulation output files </H3><Sect><H4 id="LinkTarget_448">10.4.1 Disassembly Output File </H4><P>The disassembly file, amber.dis, is generated by default during a simulation. It is located in the $AMBER_BASE/hw/sim directory. This file is very useful for debugging software as it shows every instruction executed by the core and the result of all load and store operations. </P><P>This file is generated by default. To turn off generation, comment the line where AMBER_DECOMPILE is defined in $AMBER_BASE/hw/vlog/amber/amber_config_defines.v. </P><P>Below is an example of the dissassembly output file. The first column gives the time that the instruction was executed. The time is specified in sys_clk ticks. The second column gives the address of the instruction being executed and the next column gives the instruction. If an instruction is not executed because of a conditional execution code, this is marked with a '–' character in front of the instruction. For load and store instructions, the actual memory access is given below the instruction. This is the complete listing for the add test.</P><Figure><ImageData src="images/amber-spec_img_19.jpg"/> 264 0: mov r1, #3 267 4: mov r2, #1 270 8: add r3, r1, r2 273 c: cmp r3, #4 276 10: -movne r10, #10 279 14: -bne b4 282 18: mov r4, #0 285 1c: mov r5, #0 288 20: add r6, r5, r4 291 24: cmp r6, #0 294 28: -movne r10, #20 297 2c: -bne b4 300 30: mov r7, #0 303 34: mvn r8, #0 306 38: add r9, r7, r8 309 3c: cmn r9, #1 312 40: -movne r10, #30 315 44: -bne b4 318 48: mvn r1, #0 321 4c: mov r2, #0 324 50: add r3, r1, r2 327 54: cmn r3, #1 330 58: -movne r10, #40 333 5c: -bne b4 336 60: mvn r4, #0 339 64: mvn r5, #0 342 68: add r6, r4, r5 345 6c: cmn r6, #2 348 70: -movne r10, #50 351 74: -bne b4</Figure><P> 354 78: mvn r7, #0 
</P><Figure><ImageData src="images/amber-spec_img_20.jpg"/> 357 7c: mvn r8, #254 360 80: add r9, r7, r8 363 84: cmn r9, #256 366 88: -movne r10, #60 369 8c: -bne b4 372 90: ldr r1, [pc, #60] 377 read addr d4, data 7fffffff 381 94: mov r2, #1 384 98: adds r3, r1, r2 387 9c: -bvc b4 390 a0: ldr r0, [pc, #48] 395 read addr d8, data 80000000 399 a4: cmp r0, r3 402 a8: -movne r10, #70 405 ac: -bne b4 408 b0: b c0 410 jump from b0 to c0, r0 80000000, r1 7fffffff 417 c0: ldr r11, [pc, #8] 422 read addr d0, data f0000000</Figure><P> 426 c4: mov r10, #17
 429 c8: str r10, [r11]
 432 write addr f0000000, data 00000011, be f 
</P></Sect><Sect><H4 id="LinkTarget_449">10.4.2 VCD Output File </H4><P>The VCD dump file is $AMBER_BASE/hw/sim/sim.vcd. </P><P>The VCD dump file, sim.vcd, is useful for debugging very long simulations where you just want to get waves for a period of time around where a bug is occurring. Usually with long simulations you can not dump the entire simulation because the dump file would get too large. You can use the free waveform viewer, gtkwave, to view this file. </P><P>To create a VCD output file, you can use the -d or -t switch with the run script. Alternatively you can uncomment the defines AMBER_DUMP_VCD and AMBER_DUMP_START in the file $AMBER_BASE/hw/vlog/system/system_config_defines.v. </P><P>For example, </P><P>run ethmac-test -t 50000 
</P><P>This runs the test ethmac-test, and turns on waveform dumping at system clock tick 50,000. The dumping continues for a few thousand cycles and then the test terminates with a fatal error. The lenght of time the dumping runs for is configured with the AMBER_DUMP_LENGTH define in $AMBER_BASE/hw/vlog/system/system_config_defines.v. </P><P>The signals included in the VCD dump file are specified in the file $AMBER_BASE/hw/vlog/tb/dumpvcd.v. </P><P>The following diagram shows a screen grab of the GTKWave viewer viewing the sim.vcd dump file created. </P><P>Figure 9 -GTKWave waveform viewer </P><Figure><ImageData src="images/amber-spec_img_21.jpg"/></Figure></Sect><Sect><H4 id="LinkTarget_450">10.4.3 Program Trace Utility </H4><P>A utility is provided that traces all function calls made during a Verilog simulation. Here is an example usage; </P><P>cd $AMBER_BASE/hw/sim 
run ethmac-test 
ln -s ../../sw/tools/amber-jumps.sh jumps 
jumps ethmac-test 
</P><P>This produces the following output. The left column gives the time of the event. The next colum gives the name of the calling function. The next column gives the value of the r0 register. This register holds the first parameter passed in function calls. The next column gives the name of the function called.</P><Table><TR><TH> 276031 u main -&gt; </TH><TH>( 00008dec, ) printf u </TH></TR><TR><TH>276104 u printf -&gt; </TH><TD>( 07ffff8c, ) print u </TD></TR><TR><TH>276311 u print -&gt; </TH><TD>( 00000053, ) _outbyte u </TD></TR><TR><TH>276411 </TH><TD>print &lt;-</TD><TD>( 00000053, ) </TD></TR><TR><TH>etc. </TH><TD/></TR></Table></Sect></Sect><Sect><H3 id="LinkTarget_451">10.5 Hardware Tests </H3><P>The Amber package contains a set of tests which are used to verify the correct operation of all the instructions, interrupts, the cache and peripherals. The tests are written in assembly. Several of the tests were added when a specific bug was found while debugging the core. To run one of the tests, use run &lt;test-name&gt;, e.g. </P><P>cd $AMBER_BASE/hw/sim 
run barrel_shift 
</P><P>Each test generates pass or fail when it completes, e.g. 
</P><P># ++++++++++++++++++++ 
# Passed barrel_shift 
# ++++++++++++++++++++ 
</P><P>To run the complete test suite; 
</P><P>cd $AMBER_BASE/hw/sim 
run -a 
</P><P>Once the run is complete look at the output file hw-tests.log in the $AMBER_BASE/hw/sim/ directory to check the results. All tests should pass. </P><P>The following table describes each test. The source files for these tests are in the directory $AMBER_BASE/hw/tests. </P><Table><Caption><P>Table 21 Amber Core Hardware Verification Tests </P></Caption><TR><TD>Name </TD><TD>Description </TD></TR><TR><TD>adc </TD><TD>Tests the adc instruction. Adds 3 32-bit numbers using adc and checks the result. </TD></TR><TR><TD>addr_ex </TD><TD>Tests an address exception interrupt. Sets the pc to 0x3fffffc and executes a nop. The pc then increments to 0x4000000 triggering an address exception. </TD></TR><TR><TD>add </TD><TD>Tests the add instruction. Runs through a set of additions of positive and negative numbers, checking that the results are correct. Also tests that the 's' flag on the instruction correctly sets the condition flags. </TD></TR><TR><TD>barrel_shift_rs </TD><TD>Tests the barrel shift operation with a mov instruction, when the shift amount is a register value. Test that shift of 0 leaves Rm unchanged. Tests that a shift of &gt; 32 sets Rm and carry out to 0. </TD></TR><TR><TD>barrel_shift </TD><TD>Tests the barrel shift operation with a mov instruction when the shift amount is an immediate value.Tests lsl, lsr and ror. </TD></TR><TR><TD>bcc </TD><TD>Tests branch on carry clear. </TD></TR><TR><TD>bic_bug </TD><TD>Test added to catch specific bug with the bic instruction. The following instruction stored the result in r3, instead of r2 tst r2, r0, lsl r3 bicne r2, r2, r0, lsl r3 </TD></TR><TR><TD>bl </TD><TD>Test Branch and Link instruction. Checks that the correct return address is stored in the link register (r14). </TD></TR><TR><TD>cache1 </TD><TD>Contains a long but simple code sequence. The entire sequence can fit in the cache. This sequence is executes 4 times, so three times it will execute from the cache. Test passes if sequence executes correctly. </TD></TR><TR><TD>cache2 </TD><TD>Tests simple interactin between cached data and uncached instruction accesses. </TD></TR><TR><TD>cache3 </TD><TD>Tests that the cache can write to and read back multiple times from 2k words in sequence in memory -the size of the cache. </TD></TR><TR><TD>cacheable_area </TD><TD>Tests the cacheable area co-processor function. </TD></TR><TR><TD>cache_flush </TD><TD>Tests the cache flush function. Does a flush in the middle of a sequence of data reads. Checks that all the data reads are correct. </TD></TR><TR><TD>cache_swap_bug </TD><TD>Tests the interaction between a swap instruction and the cache. Runs through a main loop multiple times with different numbers of nop instructions before the swp instruction to test a range of timing interactions between the cache state machine and the swap instruction. </TD></TR><TR><TD>cache_swap </TD><TD>Fills up the cache and then does a swap access to data in the cache. That data should be invalidated. Check by reading it again. </TD></TR><TR><TD>change_mode </TD><TD>Tests teq, tst, cmp and cmn with the p flag set. Starts in supervisor mode, changes to Interrupt </TD></TR></Table><Table><TR><TD>Name </TD><TD>Description </TD></TR><TR><TD/><TD>mode then Fast Interrupt mode, then supervisor mode again and finally User mode. </TD></TR><TR><TD>change_sbits </TD><TD>Change status bits. Tests movs where the destination register is r15, the pc. Depending on the processor mode and whether the s bit is set or not, some or none of the status bits will change. </TD></TR><TR><TD>conflict_rd </TD><TD>Tests that a register conflict between a ldr and a regop that changes the value of the same register is handled correctly. </TD></TR><TR><TD>ddr31 </TD><TD>Word accesses to random addresses in DDR3 memory. The test creates a list of addresses in an area of boot_mem. It then writes to all addresses with data value equal to address. Finally it reads back all locations checking that the read value is correct. </TD></TR><TR><TD>ddr32 </TD><TD>Tests byte read and write accesses to DDR3 memory. </TD></TR><TR><TD>ddr33 </TD><TD>Test back to back write-read accesses to DDR3 memory. </TD></TR><TR><TD>ethmac_mem </TD><TD>Tests wishbone access to the internal memory in the Ethernet MAC module. </TD></TR><TR><TD>ethmac_reg </TD><TD>Tests wishbone access to registers in the Ethernet MAC module. </TD></TR><TR><TD>ethmac_tx </TD><TD>Tests ethernet MAC frame transmit and receive functions and Ethmac DMA access to hiboot mem. Ethmac is put in loopback mode and a packet is transmitted and received. </TD></TR><TR><TD>firq </TD><TD>Executes 20 FIRQs at random times while executing a small loop of code. The interrupts are triggered using a ransom timer. Test checks the full set of FIRQ registers (r8 to r14) and will only pass if all interrupts are handled correctly. </TD></TR><TR><TD>flow_bug </TD><TD>The core was illegally skipping an instruction after a sequence of 3 conditional not-execute instructions and 1 conditional execute instruction. </TD></TR><TR><TD>flow1 </TD><TD>Tests instruction and data flow. Specifically tests that a stm writing to cached memory also writes all data through to main memory. </TD></TR><TR><TD>flow2 </TD><TD>Tests that a stream of str instrutions writing to cached memory works correctly. </TD></TR><TR><TD>flow3 </TD><TD>Tests ldm where the pc is loaded which causes a jump. At the same time the mode is changed. This is repeated with the cache enabled. </TD></TR><TR><TD>hiboot_mem </TD><TD>Tests wishbone read and write access to hi (non-cachable) boot SRAM. </TD></TR><TR><TD>inflate_bug </TD><TD>A load store sequence was found to not execute correctly. </TD></TR><TR><TD>irq </TD><TD>Tests running a simple algorithm to add a bunch of numbers and check that the result is correct. This algorithm runs 80 times. During this, a whole bunch of IRQ interrupts are triggered using the random timer. </TD></TR><TR><TD>irq_stm </TD><TD>Tests executes a loop of stm instructions. During this, a whole bunch of IRQ interrupts are triggered using the random timer. The test checks that the stm is not executed twice in a row, once before the interrupt and again after the interrupt. </TD></TR><TR><TD>ldm_stm_onetwo </TD><TD>Tests ldm and stm of single registers with cache enabled. Tests ldm and stm of 2 registers with cache enabled. </TD></TR><TR><TD>ldm1 </TD><TD>Tests the standard form of ldm. </TD></TR><TR><TD>ldm2 </TD><TD>Tests ldm where the user mode registers are loaded whilst in a privileged mode. </TD></TR><TR><TD>ldm3 </TD><TD>Tests ldm where the status bits are also loaded. </TD></TR><TR><TD>ldm4 </TD><TD>Tests the usage of ldm in User Mode where the status bits are loaded. The s bit should be ignored in User Mode. </TD></TR><TR><TD>ldr </TD><TD>Tests ldr and ldrb with all the different addressing modes. </TD></TR><TR><TD>ldr_str_pc </TD><TD>Tests lrd and str of r15. </TD></TR><TR><TD>mla </TD><TD>Tests the mla (multiply and accumulate) instruction. </TD></TR><TR><TD>mlas_bug </TD><TD>Bug with Multiply Accumulate. The flags were gettting set 1 cycle early. </TD></TR><TR><TD>movs_bug </TD><TD>Tests a movs followed by a sequence of ldr and str instructions with different condition fields. </TD></TR><TR><TD>mul </TD><TD>Tests the mul (multiply) instruction. </TD></TR><TR><TD>sbc </TD><TD>Tests the 'subtract with carry' instruction by doing 3 64-bit subtractions. </TD></TR><TR><TD>stm_stream </TD><TD>Generates as dense a stream of writes as possible to check that the memory subsystem can cope with this worst case. </TD></TR><TR><TD>stm1 </TD><TD>Tests the normal operation of the stm instruction. </TD></TR><TR><TD>stm2 </TD><TD>Test jumps into user mode, loads some values into registers r8 -r14, then jumps to FIRQ and saves the user mode registers to memory. </TD></TR><TR><TD>strb </TD><TD>Tests str and strb with different indexing modes. </TD></TR><TR><TD>sub </TD><TD>Tests sub and subs. </TD></TR></Table><P>Amber Amber 2 Core Specification May 2011 
</P><Table><TR><TD>Name </TD><TD>Description </TD></TR><TR><TD>swi </TD><TD>Tests the software interrupt – swi. </TD></TR><TR><TD>swp_lock_bug </TD><TD>Bug broke an instruction read immediately after a swp instruction. </TD></TR><TR><TD>swp </TD><TD>Tests swp and swpb. </TD></TR><TR><TD>uart_reg </TD><TD>Tests wishbone read and write access to the Amber UART registers. </TD></TR><TR><TD>uart_rxint </TD><TD>Tests the UART receive interrupt function. Some text is sent from the test_uart to the uart and an interrupt generated. </TD></TR><TR><TD>uart_rx </TD><TD>Tests the UART receive function. </TD></TR><TR><TD>uart_tx </TD><TD>Uses the tb_uart in loopback mode to verify the transmitted data. </TD></TR><TR><TD>undefined_ins </TD><TD>Tests Undefined Instruction Interrupt. Fires a few unsupported floating point unit (FPU) instructions into the core. These cause undefined instruction interrupts when executed. </TD></TR></Table></Sect><Sect><H3 id="LinkTarget_452">10.6 C Programs </H3><P>In addition to the short assembly language tests, some longer programs written in C are included with the Amber system. These can be used to further test and verify the system, or as a basis to develop your own applications. </P><P>The source code for these programs is in $AMBER_BASE/sw. </P><Sect><H4 id="LinkTarget_453">10.6.1 Boot Loader </H4><P>This is located in $AMBER_BASE/sw/boot-loader. It can be run in simulation as follows; </P><P>cd $AMBER_BASE/hw/sim 
run boot-loader 
</P><P>The simulation output looks like the following; 
</P><Figure><ImageData src="images/amber-spec_img_22.jpg"/># Test boot-loader, log file boot-loader.log # Load boot memory from ../../sw/boot-loader/boot-loader.mem # Read in 1928 lines # Amber Boot Loader v20110202130047 # Commands # l : Load elf file # b &lt;address&gt; : Load binary file to &lt;address&gt; # d &lt;start address&gt; &lt;num bytes&gt; : Dump mem # h : Print help message # j : Execute loaded elf, jumping to 0x00080000 # p &lt;address&gt; : Print ascii mem until first 0 # r &lt;address&gt; : Read mem # s : Core status # w &lt;address&gt; &lt;value&gt; : Write mem # r 0 0000000c # r 1 00001b76 # r 2 00000000 # r 3 00000000 # r 4 deadbeef # r 5 deadbeef # r 6 deadbeef # r 7 deadbeef # r 8 deadbeef # r 9 deadbeef # r10 deadbeef # r11 deadbeef # r12 00000048 # r13 600002f7 # sp 01ffff80 # pc 600002f3 # # ----------------------------------------------------------------------------# Amber Core </Figure><P># User FIRQ IRQ &gt; SVC 
</P><Figure><ImageData src="images/amber-spec_img_23.jpg"/># r0 0x00000001 # r1 0x00001c35 # r2 0x00000000 # r3 0x00000000 # r4 0xdeadbeef # r5 0xdeadbeef # r6 0xdeadbeef # r7 0xdeadbeef # r8 0xdeadbeef 0xdeadbeef # r9 0xdeadbeef 0xdeadbeef # r10 0x00000011 0xdeadbeef # r11 0xf0000000 0xdeadbeef # r12 0x00000048 0xdeadbeef # r13 0xdeadbeef 0xdeadbeef 0xdeadbeef 0x01ffffc0 # r14 (lr) 0xdeadbeef 0xdeadbeef 0xdeadbeef 0x20000763 # r15 (pc) 0x00001250 # # Status Bits: N=0, Z=1, C=1, V=0, IRQ Mask 0, FIRQ Mask 0, Mode = Supervisor # ----------------------------------------------------------------------------</Figure><P># 
# ++++++++++++++++++++ 
# Passed boot-loader 
# ++++++++++++++++++++ 
</P><P>The boot loader is used to download longer applications onto the FPGA development board via the UART port and using Hyper Terminal on a host Windows PC. </P></Sect><Sect><H4 id="LinkTarget_454">10.6.2 Hello World </H4><P>This is located in $AMBER_BASE/sw/hello-world. It can be run in simulation as follows; </P><P>cd $AMBER_BASE/hw/sim 
run hello-world 
</P><P>This is a very simple example of a stand alone C program. The printf function it uses is contained in  $AMBER_BASE/sw/mini-libc, so that it can run on an FPGA without access to a real libc library file. </P></Sect><Sect><H4 id="LinkTarget_455">10.6.3 Ethmac Test </H4><P>This is located in $AMBER_BASE/sw/ethmac-test. This is designed to be loaded and run by the boot loader. It is a simple test of the Ethernet MAC module in loopback mode. It can be run in simulation as follows; </P><P>cd $AMBER_BASE/hw/sim 
run ethmac-test 
</P></Sect></Sect><Sect><H3 id="LinkTarget_456">10.7 Linux </H3><Sect><H4 id="LinkTarget_457">10.7.1 Using the pre-compiled memory image </H4><P>A memory file is provided to run a simulation of Linux booting. The main reason for providing this file is to have a long test to further validate the correct operation of the core. This file was created from a modified version of the 2.4.27 kernel with the patch-2.4.27-vrs1.bz2 patch file applied and then some modifications made to source files to support the specific hardware in the Amber 2 FPGA. </P><P>The vmlinux.mem memory file contains an embedded ext2 format ramdisk image </P><P>Amber Amber 2 Core Specification May 2011 
</P><P>which contains the hello-world program, but renamed as /sbin/init. The kernel mounts the ramdisk as /dev/root and runs init. This program prints &quot;Hello, World&quot; and writes the test pass value to the simulation control register. To run this simulation; </P><P>cd $AMBER_BASE/hw/sim 
run vmlinux 
</P><P>This simulation takes about 6 million ticks to run to completion, or between 5 minutes and an hour of wall time depending on your simulator and PC. The following is the output from this simulation; </P><P># Amber Boot Loader v20110117211518 
</P><P># j 0x2080000 
</P><P># 
</P><P># Linux version 2.4.27-vrs1 (conor@server) (gcc version 4.5.1 (Sourcery G++ Lite 2010.0950) ) #354 Tue Feb 1 17:56:00 GMT 2011 
</P><Figure><ImageData src="images/amber-spec_img_24.jpg"/># CPU: Amber 2 revision 0 # Machine: Amber-FPGA-System # On node 0 totalpages: 1024 # zone(0): 1024 pages. # zone(1): 0 pages. # zone(2): 0 pages. # Kernel command line: console=ttyAM0 mem=32M root=/dev/ram # Calibrating delay loop... 19.91 BogoMIPS # Memory: 32MB = 32MB total # Memory: 31136KB available (493K code, 195K data, 32K init) # Dentry cache hash table entries: 4096 (order: 0, 32768 bytes) # Inode cache hash table entries: 4096 (order: 0, 32768 bytes) # Mount cache hash table entries: 4096 (order: 0, 32768 bytes) # Buffer cache hash table entries: 8192 (order: 0, 32768 bytes) # Page-cache hash table entries: 8192 (order: 0, 32768 bytes) # POSIX conformance testing by UNIFIX # Linux NET4.0 for Linux 2.4 # Based upon Swansea University Computer Society NET3.039 # Starting kswapd # ttyAM0 at MMIO 0x16000000 (irq = 1) is a WSBN # pty: 256 Unix98 ptys configured # RAMDISK driver initialized: 16 RAM disks of 208K size 1024 blocksize # NetWinder Floating Point Emulator V0.97 (double precision) # RAMDISK: ext2 filesystem found at block 8388608 # RAMDISK: Loading 200 blocks [1 disk] into ram disk... done. # Freeing initrd memory: 200K # VFS: Mounted root (ext2 filesystem) readonly. # Freeing init memory: 32K # Hello, World! # # ----------------------------------------------------------------------------# Amber Core # &gt; User FIRQ IRQ SVC # r0 0x00000010 # r1 0x0080ee00 # r2 0x00000000 # r3 0x00000000 # r4 0x00000000 # r5 0x00000000 # r6 0x00000000 # r7 0x00000000 # r8 0x00000000 0xdeadbeef # r9 0x00000000 0xdeadbeef # r10 0x00000011 0xdeadbeef # r11 0xf0000000 0xdeadbeef # r12 0x00000000 0xdeadbeef # r13 0x019fff40 0xdeadbeef 0x0210bca4 0x02161fe8 # r14 (lr) 0x00000000 0xdeadbeef 0x220a437f 0x0080e428 # r15 (pc) 0x0080e800 # # Status Bits: N=0, Z=1, C=1, V=0, IRQ Mask 0, FIRQ Mask 0, Mode = User # ----------------------------------------------------------------------------# # ++++++++++++++++++++ </Figure><P># Passed vmlinux 
# ++++++++++++++++++++ 
</P><P>The program trace utility can be used to trace the Linux execution, as follows; 
</P><P>Amber Amber 2 Core Specification May 2011 
</P><P>cd $AMBER_BASE/hw/sim 
ln -s ../../sw/tools/amber-jumps.sh jumps 
jumps vmlinux 
</P></Sect><Sect><H4 id="LinkTarget_458">10.7.2 Building the kernel from source </H4><P>1. Create a RAM disk image </P><P>The RAM disk image file is the ext2 format disk image that Linux mounts as part of the boot process. It contains a bare bones Linux file system and an init file (which is just the hello-world program renamed in this case). The init file is executed at the end of the Linux boot process. The file is incorporated into the vmlinux.mem file for simulations. </P><Figure><ImageData src="images/amber-spec_img_25.jpg"/># Set the location on your system where the Amber project is located export AMBER_BASE=/proj/opencores-svn/trunk # Pick a directory on your system where you want to build Linux export LINUX_WORK_DIR=/proj/amber2-linux # Build hello-world, which is used as the init program cd $AMBER_BASE/sw/hello-world make clean; make test -e ${LINUX_WORK_DIR} || mkdir ${LINUX_WORK_DIR} cd ${LINUX_WORK_DIR} # Need root permissions to mount disks su root # Create a blank disk image dd if=/dev/zero of=initrd bs=200k count=1 mke2fs -F -m0 -b 1024 initrd # Mount the disk image so you can add contents test -e mnt || mkdir mnt mount -t ext2 -o loop initrd ${LINUX_WORK_DIR}/mnt # Add directories mkdir ${LINUX_WORK_DIR}/mnt/sbin mkdir ${LINUX_WORK_DIR}/mnt/dev mkdir ${LINUX_WORK_DIR}/mnt/bin mkdir ${LINUX_WORK_DIR}/mnt/etc mkdir ${LINUX_WORK_DIR}/mnt/proc mkdir ${LINUX_WORK_DIR}/mnt/lib # Add nodes mknod ${LINUX_WORK_DIR}/mnt/dev/console c 5 1 mknod ${LINUX_WORK_DIR}/mnt/dev/tty2 c 4 2 mknod ${LINUX_WORK_DIR}/mnt/dev/null c 1 3 mknod ${LINUX_WORK_DIR}/mnt/dev/loop0 b 7 0 chmod 600 ${LINUX_WORK_DIR}/mnt/dev/* # Add files cp $AMBER_BASE/sw/hello-world/hello-world.elf ${LINUX_WORK_DIR}/mnt/sbin/init chmod +x ${LINUX_WORK_DIR}/mnt/sbin/init # Check that stuff got added. Should be about 27% full now df ${LINUX_WORK_DIR}/mnt # Unmount umount ${LINUX_WORK_DIR}/mnt exit </Figure><P># Copy the disk image to the Amber project area 
cp initrd $AMBER_BASE/sw/vmlinux 
</P><P>2. Build the kernel </P><P>The following steps download the kernal source code, apply two patch files, build a kernel elf image and convert it into a .mem file for Verilog simulations. At the end of </P><P>Amber Amber 2 Core Specification May 2011 
</P><P>this process you will have a working base from which to modify the kernel or build your own applications to run in Linux on the Amber processor core. </P><Figure><ImageData src="images/amber-spec_img_26.jpg"/># Set the location on your system where the Amber project is located export AMBER_BASE=/proj/opencores-svn/trunk # Pick a directory on your system where you want to build Linux export LINUX_WORK_DIR=/proj/amber2-linux # Set the GNU cross-tool name export AMBER_CROSSTOOL=arm-none-linux-gnueabi # Create the Linux build directory test -e ${LINUX_WORK_DIR} || mkdir ${LINUX_WORK_DIR} cd ${LINUX_WORK_DIR} # Download the kernel source wget http://www.kernel.org/pub/linux/kernel/v2.4/linux-2.4.27.tar.gz tar zxf linux-2.4.27.tar.gz # Create a convenient link ln -s linux-2.4.27 linux cd linux # Apply the two patch files provided with the Amber project cp ${AMBER_BASE}/sw/vmlinux/patch-2.4.27-vrs1.bz2 . cp ${AMBER_BASE}/sw/vmlinux/patch-2.4.27-amber2.bz2 . bzip2 -d patch-2.4.27-vrs1.bz2 bzip2 -d patch-2.4.27-amber2.bz2 patch -p1 &lt; patch-2.4.27-vrs1 patch -p1 &lt; patch-2.4.27-amber2 # Build the kernel and create a .mem file for simulations make dep make vmlinux # You should now have an elf vmlinux image of about 790KB in size cp vmlinux vmlinux_unstripped # Remove comments and notes from the elf image ${AMBER_CROSSTOOL}-objcopy -R .comment -R .note vmlinux # Change the addresses from virtual to physical ${AMBER_CROSSTOOL}-objcopy --change-addresses -0x02000000 vmlinux # Convert the elf image to a .mem file $AMBER_BASE/sw/tools/amber-elfsplitter vmlinux &gt; vmlinux.mem # Add the ram disk image to the .mem file $AMBER_BASE/sw/tools/amber-bin2mem ${AMBER_BASE}/sw/vmlinux/initrd 800000 &gt;&gt; vmlinux.mem # Create a disassembly file to aid with debugging ${AMBER_CROSSTOOL}-objdump -C -S -EL vmlinux_unstripped &gt; vmlinux.dis # Copy the .mem and .dis files into the Amber project area for simulations cp vmlinux.mem $AMBER_BASE/sw/vmlinux/vmlinux.mem cp vmlinux.dis $AMBER_BASE/sw/vmlinux/vmlinux.dis </Figure><P># Run the Linux simulation to verify that you have a good kernel image 
cd $AMBER_BASE/hw/sim 
run vmlinux 
</P></Sect></Sect></Sect><Sect><H2 id="LinkTarget_459">11 FPGA Synthesis </H2><P>A makefile is provided that performs synthesis of the system to a Xilinx Spartan-6 or Virtex-6 FPGA. To use this makefile you must have Xilinx ISE installed. I have tested it with ISE v11.5. The makefile is quite flexible. To see all its options, type; </P><P>cd $AMBER_BASE/hw/fpga/bin 
make help 
</P><P>To use the script to perform a complete synthesis run from start to finish and generate a bitfile; </P><P>cd $AMBER_BASE/hw/fpga/bin 
chmod +x *.sh 
make new 
</P><P>The script performs the following steps </P><L><LI><LI_Label>1. 	</LI_Label><LI_Title>Compiles the boot loader program in $AMBER_BASE/sw/boot-loader, to ensure the latest version goes into the boot_mem ram blocks. </LI_Title></LI><LI><LI_Label>2. 	</LI_Label><LI_Title>Runs xst to synthesize the top-level Verilog file $AMBER_BASE/hw/vlog/system/system.v and everything inside it. </LI_Title></LI><LI><LI_Label>3. 	</LI_Label><LI_Title>Runs ngbbuild to create the initial FPGA netlist. </LI_Title></LI><LI><LI_Label>4. 	</LI_Label><LI_Title>Runs map to do placement. </LI_Title></LI><LI><LI_Label>5. 	</LI_Label><LI_Title>Runs par to do routing. </LI_Title></LI><LI><LI_Label>6. 	</LI_Label><LI_Title>Runs bitgen to create an FPGA bitfile in the bitfile directory. </LI_Title></LI><LI><LI_Label>7. 	</LI_Label><LI_Title>Runs trce to do timing analysis on the finished FPGA. </LI_Title></LI></L><P>The Spartan-6 FPGA target device is the default. To compile for the Virtex-6 FPGA, set VIRTEX6=1 on the command line, e.g. </P><P>cd $AMBER_BASE/hw/fpga/bin 
make new VIRTEX6=1 
</P><P>The Amber 23 core is the default. To synthesize the Amber 25 core instead, set A25=1 on the command line, e.g. </P><P>cd $AMBER_BASE/hw/fpga/bin 
make new A25=1 
</P><P>If the par step fails (timing or area constrains not met), you can rerun map and par with a different seed. Simply call the makefile again without the new switch. The makefile will automatically increment the seed, e.g. </P><P>cd $AMBER_BASE/hw/fpga/bin 
</P><P>make 
</P><P>The system clock speed is configured within the FPGA makefile, $AMBER_BASE/hw/fpga/bin/Makefile. To change it, change the value of AMBER_CLK_DIVIDER in that file. The system clock frequency is equal to the PLL's VCO clock frequency divided by AMBER_CLK_DIVIDER. By default it is set to 40MHz for Spartan-6 and 80MHz for Virtex-6. </P><Sect><H3 id="LinkTarget_460">11.1 Synthesis Results </H3><P>The following table shows the resource utilisation for synthesizing the complete Amber system, including the Amber core and all peripherals, with different core configurations. All these results are for the Spartan-6 45T FPGA device with a system clock frequency of 40MHz. The relative size column just considers the number of LUTs uses, as this is usually the critical resource in an FPGA. </P><Table><Caption><P>Table 22 Amber system synthesis results </P></Caption><TR><TH>Core Type and Cache Configuration </TH><TH>vmlinux run time / ticks </TH><TH>Registers </TH><TH>LUTs </TH><TH>RAM16 </TH><TH/><TH>RAM8 </TH><TH/><TH>Relative Linux Performance </TH><TH>Relative Size (LUTs) </TH></TR><TR><TH>A23 8KB </TH><TD>6,201,231 </TD><TD>4,604 </TD><TD>8,712 </TD><TD/><TD>4 </TD><TD/><TD>11 </TD><TD>100% </TD><TD>100% </TD></TR><TR><TH>A23 12KB </TH><TD>5,959,867 </TD><TD>4,634 </TD><TD>8,717 </TD><TD/><TD>4 </TD><TD/><TD>16 </TD><TD>104% </TD><TD>100% </TD></TR><TR><TH>A23 16KB </TH><TD>5,873,135 </TD><TD>4,653 </TD><TD>8,879 </TD><TD/><TD>4 </TD><TD/><TD>21 </TD><TD>106% </TD><TD>102% </TD></TR><TR><TH>A23 32KB </TH><TD>5,712,401 </TD><TD>4,767 </TD><TD>9,348 </TD><TD/><TD>4 </TD><TD/><TD>41 </TD><TD>109% </TD><TD>107% </TD></TR><TR><TH>A25 8KB/8KB </TH><TD>4,607,818 </TD><TD>5,726 </TD><TD>11,763 </TD><TD/><TD>4 </TD><TD/><TD>21 </TD><TD>135% </TD><TD>135% </TD></TR><TR><TH>A25 12KB/12KB </TH><TD>4,554,457 </TD><TD>5,705 </TD><TD>11,633 </TD><TD/><TD>4 </TD><TD/><TD>31 </TD><TD>136% </TD><TD>134% </TD></TR><TR><TH>A25 16KB/16KB </TH><TD>4,537,860 </TD><TD>5,792 </TD><TD>12,020 </TD><TD/><TD>4 </TD><TD/><TD>41 </TD><TD>137% </TD><TD>138% </TD></TR><TR><TH>A25 32KB/32KB </TH><TD>4,513,264 </TD><TD>5,823 </TD><TD>13,021 </TD><TD/><TD>4 </TD><TD/><TD>81 </TD><TD>137% </TD><TD>149% </TD></TR></Table></Sect></Sect><Sect><H2 id="LinkTarget_461">12 Using Boot-Loader </H2><P>If you have a development board with a UART connection to a PC you can use boot-loader to download and run applications on the board. I have tested this with the Xilinx SP605 development board. It provides a UART connection via a USB port on the board. </P><Sect><H3 id="LinkTarget_462">12.1 Configure HyperTerminal </H3><P>Run HyperTerminal on the PC. This is a free application supplied with Windows. In Windows XP it is available on the Start Menu under All Programs -&gt; Accessories -&gt; Communications -&gt; HyperTerminal </P><P>When HyperTerminal starts it brings up the new connection dialogue. The first screen of this dialogue asks you to name the connection. Name it anything you like. </P><Figure><ImageData src="images/amber-spec_img_27.jpg"/></Figure><P>On the next screen select the com port. This will depend on your PC. For me the correct port is COM14. Check the documentation for your FPGA board. </P><Figure><ImageData src="images/amber-spec_img_28.jpg"/></Figure><P>The final screen sets the connection speed and type. Select 921600 bits per second, 8 
</P><P>data bits, no parity bits, 1 stop bit and hardware flow control. This is the default speed of the UART and is configured within the Verilog code, in the file $AMBER_BASE/hw/vlog/system/system_config_defines.v. It can be changed prior to FPGA synthesis. </P><Figure><ImageData src="images/amber-spec_img_29.jpg"/></Figure></Sect><Sect><H3 id="LinkTarget_463">12.2 Configure the FPGA </H3><P>Load the bitfile into the FPGA on the development board. This can be done using Xilinx iMPACT. Once the FPGA is configured the boot loader will print some messages via the UART interface onto the HyperTerminal screen, as follows; </P><Figure><ImageData src="images/amber-spec_img_30.jpg"/></Figure><P>You can now load and run applications using the boot loader. For example, to load the ethmac-test application, type 'l' and hit return. This puts the boot loader into a loop waiting to receive a file. Next select the Transfer-&gt; Send File menu item on HyperTerminal. Select the 1K Xmodem protocol. Then click on browse and select the ethmac-test.elf file in $AMBER_BASE/sw/ethmac-test. The elf file in generated when you run make in that directory. The file downloads to the board. Type 'j' to run it. </P><Table><TR><TH>Amber Amber 2 Core Specification May 2011 </TH></TR><TR><TH id="LinkTarget_464">13 License </TH></TR><TR><TH>All source code provided in the Amber package is release under the following license terms; </TH></TR></Table><Figure><ImageData src="images/amber-spec_img_31.jpg"/>Copyright (C) 2010 Authors and OPENCORES.ORG This source file may be used and distributed without restriction provided that this copyright statement is not removed from the file and that any derivative work contains the original copyright notice and the associated disclaimer. This source file is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version. This source is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details. You should have received a copy of the GNU Lesser General Public License along with this source; if not, download it from http://www.opencores.org/lgpl.shtml Author(s): - Conor Santifort, csantifort.amber@gmail.com </Figure></Sect></Sect></Sect></Sect></Part></TaggedPDF-doc>